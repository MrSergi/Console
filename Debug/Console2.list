
E:\project\Armazila\src\Console\Debug\Console2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001e4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000039cc  080001e4  080001e4  000101e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000240  08003bb0  08003bb0  00013bb0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08003df0  08003df0  00013df0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08003df4  08003df4  00013df4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000028  20000000  08003df8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00001bc0  20000028  08003e20  00020028  2**2
                  ALLOC
  7 ._user_heap_stack 00000200  20001be8  08003e20  00021be8  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  00020028  2**0
                  CONTENTS, READONLY
  9 .debug_info   00005bd5  00000000  00000000  00020051  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001585  00000000  00000000  00025c26  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000840  00000000  00000000  000271b0  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000768  00000000  00000000  000279f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00002fe9  00000000  00000000  00028158  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000027ab  00000000  00000000  0002b141  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007e  00000000  00000000  0002d8ec  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00002138  00000000  00000000  0002d96c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001e4 <__do_global_dtors_aux>:
 80001e4:	b510      	push	{r4, lr}
 80001e6:	4c05      	ldr	r4, [pc, #20]	; (80001fc <__do_global_dtors_aux+0x18>)
 80001e8:	7823      	ldrb	r3, [r4, #0]
 80001ea:	b933      	cbnz	r3, 80001fa <__do_global_dtors_aux+0x16>
 80001ec:	4b04      	ldr	r3, [pc, #16]	; (8000200 <__do_global_dtors_aux+0x1c>)
 80001ee:	b113      	cbz	r3, 80001f6 <__do_global_dtors_aux+0x12>
 80001f0:	4804      	ldr	r0, [pc, #16]	; (8000204 <__do_global_dtors_aux+0x20>)
 80001f2:	f3af 8000 	nop.w
 80001f6:	2301      	movs	r3, #1
 80001f8:	7023      	strb	r3, [r4, #0]
 80001fa:	bd10      	pop	{r4, pc}
 80001fc:	20000028 	.word	0x20000028
 8000200:	00000000 	.word	0x00000000
 8000204:	08003b98 	.word	0x08003b98

08000208 <frame_dummy>:
 8000208:	b508      	push	{r3, lr}
 800020a:	4b03      	ldr	r3, [pc, #12]	; (8000218 <frame_dummy+0x10>)
 800020c:	b11b      	cbz	r3, 8000216 <frame_dummy+0xe>
 800020e:	4903      	ldr	r1, [pc, #12]	; (800021c <frame_dummy+0x14>)
 8000210:	4803      	ldr	r0, [pc, #12]	; (8000220 <frame_dummy+0x18>)
 8000212:	f3af 8000 	nop.w
 8000216:	bd08      	pop	{r3, pc}
 8000218:	00000000 	.word	0x00000000
 800021c:	2000002c 	.word	0x2000002c
 8000220:	08003b98 	.word	0x08003b98

08000224 <strcmp>:
 8000224:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000228:	f811 3b01 	ldrb.w	r3, [r1], #1
 800022c:	2a01      	cmp	r2, #1
 800022e:	bf28      	it	cs
 8000230:	429a      	cmpcs	r2, r3
 8000232:	d0f7      	beq.n	8000224 <strcmp>
 8000234:	1ad0      	subs	r0, r2, r3
 8000236:	4770      	bx	lr

08000238 <strlen>:
 8000238:	4603      	mov	r3, r0
 800023a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800023e:	2a00      	cmp	r2, #0
 8000240:	d1fb      	bne.n	800023a <strlen+0x2>
 8000242:	1a18      	subs	r0, r3, r0
 8000244:	3801      	subs	r0, #1
 8000246:	4770      	bx	lr

08000248 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 8000248:	b480      	push	{r7}
 800024a:	b085      	sub	sp, #20
 800024c:	af00      	add	r7, sp, #0
 800024e:	60f8      	str	r0, [r7, #12]
 8000250:	60b9      	str	r1, [r7, #8]
 8000252:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8000254:	68fb      	ldr	r3, [r7, #12]
 8000256:	3b04      	subs	r3, #4
 8000258:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800025a:	68fb      	ldr	r3, [r7, #12]
 800025c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000260:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000262:	68fb      	ldr	r3, [r7, #12]
 8000264:	3b04      	subs	r3, #4
 8000266:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 8000268:	68ba      	ldr	r2, [r7, #8]
 800026a:	68fb      	ldr	r3, [r7, #12]
 800026c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800026e:	68fb      	ldr	r3, [r7, #12]
 8000270:	3b04      	subs	r3, #4
 8000272:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8000274:	4a08      	ldr	r2, [pc, #32]	; (8000298 <pxPortInitialiseStack+0x50>)
 8000276:	68fb      	ldr	r3, [r7, #12]
 8000278:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 800027a:	68fb      	ldr	r3, [r7, #12]
 800027c:	3b14      	subs	r3, #20
 800027e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8000280:	687a      	ldr	r2, [r7, #4]
 8000282:	68fb      	ldr	r3, [r7, #12]
 8000284:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8000286:	68fb      	ldr	r3, [r7, #12]
 8000288:	3b20      	subs	r3, #32
 800028a:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 800028c:	68fb      	ldr	r3, [r7, #12]
}
 800028e:	4618      	mov	r0, r3
 8000290:	3714      	adds	r7, #20
 8000292:	46bd      	mov	sp, r7
 8000294:	bc80      	pop	{r7}
 8000296:	4770      	bx	lr
 8000298:	0800029d 	.word	0x0800029d

0800029c <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 800029c:	b580      	push	{r7, lr}
 800029e:	af00      	add	r7, sp, #0
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
 80002a0:	f000 f878 	bl	8000394 <ulPortSetInterruptMask>
	for( ;; );
 80002a4:	e7fe      	b.n	80002a4 <prvTaskExitError+0x8>
 80002a6:	bf00      	nop

080002a8 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 80002a8:	4b07      	ldr	r3, [pc, #28]	; (80002c8 <pxCurrentTCBConst2>)
 80002aa:	6819      	ldr	r1, [r3, #0]
 80002ac:	6808      	ldr	r0, [r1, #0]
 80002ae:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80002b2:	f380 8809 	msr	PSP, r0
 80002b6:	f3bf 8f6f 	isb	sy
 80002ba:	f04f 0000 	mov.w	r0, #0
 80002be:	f380 8811 	msr	BASEPRI, r0
 80002c2:	f04e 0e0d 	orr.w	lr, lr, #13
 80002c6:	4770      	bx	lr

080002c8 <pxCurrentTCBConst2>:
 80002c8:	20001858 	.word	0x20001858
					"	bx r14							\n"
					"									\n"
					"	.align 2						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 80002cc:	bf00      	nop
 80002ce:	bf00      	nop

080002d0 <prvPortStartFirstTask>:
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 80002d0:	4806      	ldr	r0, [pc, #24]	; (80002ec <prvPortStartFirstTask+0x1c>)
 80002d2:	6800      	ldr	r0, [r0, #0]
 80002d4:	6800      	ldr	r0, [r0, #0]
 80002d6:	f380 8808 	msr	MSP, r0
 80002da:	b662      	cpsie	i
 80002dc:	f3bf 8f4f 	dsb	sy
 80002e0:	f3bf 8f6f 	isb	sy
 80002e4:	df00      	svc	0
 80002e6:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 80002e8:	bf00      	nop
 80002ea:	0000      	.short	0x0000
 80002ec:	e000ed08 	.word	0xe000ed08

080002f0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 80002f0:	b580      	push	{r7, lr}
 80002f2:	af00      	add	r7, sp, #0
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80002f4:	4a0b      	ldr	r2, [pc, #44]	; (8000324 <xPortStartScheduler+0x34>)
 80002f6:	4b0b      	ldr	r3, [pc, #44]	; (8000324 <xPortStartScheduler+0x34>)
 80002f8:	681b      	ldr	r3, [r3, #0]
 80002fa:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80002fe:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8000300:	4a08      	ldr	r2, [pc, #32]	; (8000324 <xPortStartScheduler+0x34>)
 8000302:	4b08      	ldr	r3, [pc, #32]	; (8000324 <xPortStartScheduler+0x34>)
 8000304:	681b      	ldr	r3, [r3, #0]
 8000306:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800030a:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 800030c:	f000 f888 	bl	8000420 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8000310:	4b05      	ldr	r3, [pc, #20]	; (8000328 <xPortStartScheduler+0x38>)
 8000312:	2200      	movs	r2, #0
 8000314:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8000316:	f7ff ffdb 	bl	80002d0 <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 800031a:	f7ff ffbf 	bl	800029c <prvTaskExitError>

	/* Should not get here! */
	return 0;
 800031e:	2300      	movs	r3, #0
}
 8000320:	4618      	mov	r0, r3
 8000322:	bd80      	pop	{r7, pc}
 8000324:	e000ed20 	.word	0xe000ed20
 8000328:	20000000 	.word	0x20000000

0800032c <vPortYield>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
 800032c:	b480      	push	{r7}
 800032e:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8000330:	4b05      	ldr	r3, [pc, #20]	; (8000348 <vPortYield+0x1c>)
 8000332:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000336:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 8000338:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800033c:	f3bf 8f6f 	isb	sy
}
 8000340:	bf00      	nop
 8000342:	46bd      	mov	sp, r7
 8000344:	bc80      	pop	{r7}
 8000346:	4770      	bx	lr
 8000348:	e000ed04 	.word	0xe000ed04

0800034c <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800034c:	b580      	push	{r7, lr}
 800034e:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 8000350:	f000 f820 	bl	8000394 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 8000354:	4b05      	ldr	r3, [pc, #20]	; (800036c <vPortEnterCritical+0x20>)
 8000356:	681b      	ldr	r3, [r3, #0]
 8000358:	3301      	adds	r3, #1
 800035a:	4a04      	ldr	r2, [pc, #16]	; (800036c <vPortEnterCritical+0x20>)
 800035c:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 800035e:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8000362:	f3bf 8f6f 	isb	sy
}
 8000366:	bf00      	nop
 8000368:	bd80      	pop	{r7, pc}
 800036a:	bf00      	nop
 800036c:	20000000 	.word	0x20000000

08000370 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8000370:	b580      	push	{r7, lr}
 8000372:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
 8000374:	4b06      	ldr	r3, [pc, #24]	; (8000390 <vPortExitCritical+0x20>)
 8000376:	681b      	ldr	r3, [r3, #0]
 8000378:	3b01      	subs	r3, #1
 800037a:	4a05      	ldr	r2, [pc, #20]	; (8000390 <vPortExitCritical+0x20>)
 800037c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800037e:	4b04      	ldr	r3, [pc, #16]	; (8000390 <vPortExitCritical+0x20>)
 8000380:	681b      	ldr	r3, [r3, #0]
 8000382:	2b00      	cmp	r3, #0
 8000384:	d102      	bne.n	800038c <vPortExitCritical+0x1c>
	{
		portENABLE_INTERRUPTS();
 8000386:	2000      	movs	r0, #0
 8000388:	f000 f80e 	bl	80003a8 <vPortClearInterruptMask>
	}
}
 800038c:	bf00      	nop
 800038e:	bd80      	pop	{r7, pc}
 8000390:	20000000 	.word	0x20000000

08000394 <ulPortSetInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) uint32_t ulPortSetInterruptMask( void )
{
	__asm volatile														\
 8000394:	f3ef 8011 	mrs	r0, BASEPRI
 8000398:	f04f 01bf 	mov.w	r1, #191	; 0xbf
 800039c:	f381 8811 	msr	BASEPRI, r1
 80003a0:	4770      	bx	lr
		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
 80003a2:	2300      	movs	r3, #0
}
 80003a4:	4618      	mov	r0, r3
 80003a6:	bf00      	nop

080003a8 <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( uint32_t ulNewMaskValue )
{
	__asm volatile													\
 80003a8:	f380 8811 	msr	BASEPRI, r0
 80003ac:	4770      	bx	lr
		:::"r0"														\
	);

	/* Just to avoid compiler warnings. */
	( void ) ulNewMaskValue;
}
 80003ae:	bf00      	nop

080003b0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80003b0:	f3ef 8009 	mrs	r0, PSP
 80003b4:	f3bf 8f6f 	isb	sy
 80003b8:	4b0d      	ldr	r3, [pc, #52]	; (80003f0 <pxCurrentTCBConst>)
 80003ba:	681a      	ldr	r2, [r3, #0]
 80003bc:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80003c0:	6010      	str	r0, [r2, #0]
 80003c2:	e92d 4008 	stmdb	sp!, {r3, lr}
 80003c6:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 80003ca:	f380 8811 	msr	BASEPRI, r0
 80003ce:	f000 ff31 	bl	8001234 <vTaskSwitchContext>
 80003d2:	f04f 0000 	mov.w	r0, #0
 80003d6:	f380 8811 	msr	BASEPRI, r0
 80003da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80003de:	6819      	ldr	r1, [r3, #0]
 80003e0:	6808      	ldr	r0, [r1, #0]
 80003e2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80003e6:	f380 8809 	msr	PSP, r0
 80003ea:	f3bf 8f6f 	isb	sy
 80003ee:	4770      	bx	lr

080003f0 <pxCurrentTCBConst>:
 80003f0:	20001858 	.word	0x20001858
	"										\n"
	"	.align 2							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 80003f4:	bf00      	nop
 80003f6:	bf00      	nop

080003f8 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80003f8:	b580      	push	{r7, lr}
 80003fa:	af00      	add	r7, sp, #0
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 80003fc:	f7ff ffca 	bl	8000394 <ulPortSetInterruptMask>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8000400:	f000 fe6a 	bl	80010d8 <xTaskIncrementTick>
 8000404:	4603      	mov	r3, r0
 8000406:	2b00      	cmp	r3, #0
 8000408:	d003      	beq.n	8000412 <SysTick_Handler+0x1a>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800040a:	4b04      	ldr	r3, [pc, #16]	; (800041c <SysTick_Handler+0x24>)
 800040c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000410:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8000412:	2000      	movs	r0, #0
 8000414:	f7ff ffc8 	bl	80003a8 <vPortClearInterruptMask>
}
 8000418:	bf00      	nop
 800041a:	bd80      	pop	{r7, pc}
 800041c:	e000ed04 	.word	0xe000ed04

08000420 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 8000420:	b480      	push	{r7}
 8000422:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8000424:	4b05      	ldr	r3, [pc, #20]	; (800043c <vPortSetupTimerInterrupt+0x1c>)
 8000426:	f645 52bf 	movw	r2, #23999	; 0x5dbf
 800042a:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800042c:	4b04      	ldr	r3, [pc, #16]	; (8000440 <vPortSetupTimerInterrupt+0x20>)
 800042e:	2207      	movs	r2, #7
 8000430:	601a      	str	r2, [r3, #0]
}
 8000432:	bf00      	nop
 8000434:	46bd      	mov	sp, r7
 8000436:	bc80      	pop	{r7}
 8000438:	4770      	bx	lr
 800043a:	bf00      	nop
 800043c:	e000e014 	.word	0xe000e014
 8000440:	e000e010 	.word	0xe000e010

08000444 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8000444:	b580      	push	{r7, lr}
 8000446:	b088      	sub	sp, #32
 8000448:	af00      	add	r7, sp, #0
 800044a:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 800044c:	2300      	movs	r3, #0
 800044e:	617b      	str	r3, [r7, #20]

	vTaskSuspendAll();
 8000450:	f000 fdb6 	bl	8000fc0 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 8000454:	4b3e      	ldr	r3, [pc, #248]	; (8000550 <pvPortMalloc+0x10c>)
 8000456:	681b      	ldr	r3, [r3, #0]
 8000458:	2b00      	cmp	r3, #0
 800045a:	d104      	bne.n	8000466 <pvPortMalloc+0x22>
		{
			prvHeapInit();
 800045c:	f000 f8ba 	bl	80005d4 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
 8000460:	4b3b      	ldr	r3, [pc, #236]	; (8000550 <pvPortMalloc+0x10c>)
 8000462:	2201      	movs	r2, #1
 8000464:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 8000466:	687b      	ldr	r3, [r7, #4]
 8000468:	2b00      	cmp	r3, #0
 800046a:	d00e      	beq.n	800048a <pvPortMalloc+0x46>
		{
			xWantedSize += heapSTRUCT_SIZE;
 800046c:	2308      	movs	r3, #8
 800046e:	461a      	mov	r2, r3
 8000470:	687b      	ldr	r3, [r7, #4]
 8000472:	4413      	add	r3, r2
 8000474:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
 8000476:	687b      	ldr	r3, [r7, #4]
 8000478:	f003 0307 	and.w	r3, r3, #7
 800047c:	2b00      	cmp	r3, #0
 800047e:	d004      	beq.n	800048a <pvPortMalloc+0x46>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8000480:	687b      	ldr	r3, [r7, #4]
 8000482:	f023 0307 	bic.w	r3, r3, #7
 8000486:	3308      	adds	r3, #8
 8000488:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 800048a:	687b      	ldr	r3, [r7, #4]
 800048c:	2b00      	cmp	r3, #0
 800048e:	d057      	beq.n	8000540 <pvPortMalloc+0xfc>
 8000490:	687b      	ldr	r3, [r7, #4]
 8000492:	f241 72f7 	movw	r2, #6135	; 0x17f7
 8000496:	4293      	cmp	r3, r2
 8000498:	d852      	bhi.n	8000540 <pvPortMalloc+0xfc>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 800049a:	4b2e      	ldr	r3, [pc, #184]	; (8000554 <pvPortMalloc+0x110>)
 800049c:	61bb      	str	r3, [r7, #24]
			pxBlock = xStart.pxNextFreeBlock;
 800049e:	4b2d      	ldr	r3, [pc, #180]	; (8000554 <pvPortMalloc+0x110>)
 80004a0:	681b      	ldr	r3, [r3, #0]
 80004a2:	61fb      	str	r3, [r7, #28]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80004a4:	e004      	b.n	80004b0 <pvPortMalloc+0x6c>
			{
				pxPreviousBlock = pxBlock;
 80004a6:	69fb      	ldr	r3, [r7, #28]
 80004a8:	61bb      	str	r3, [r7, #24]
				pxBlock = pxBlock->pxNextFreeBlock;
 80004aa:	69fb      	ldr	r3, [r7, #28]
 80004ac:	681b      	ldr	r3, [r3, #0]
 80004ae:	61fb      	str	r3, [r7, #28]
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80004b0:	69fb      	ldr	r3, [r7, #28]
 80004b2:	685a      	ldr	r2, [r3, #4]
 80004b4:	687b      	ldr	r3, [r7, #4]
 80004b6:	429a      	cmp	r2, r3
 80004b8:	d203      	bcs.n	80004c2 <pvPortMalloc+0x7e>
 80004ba:	69fb      	ldr	r3, [r7, #28]
 80004bc:	681b      	ldr	r3, [r3, #0]
 80004be:	2b00      	cmp	r3, #0
 80004c0:	d1f1      	bne.n	80004a6 <pvPortMalloc+0x62>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 80004c2:	69fb      	ldr	r3, [r7, #28]
 80004c4:	4a24      	ldr	r2, [pc, #144]	; (8000558 <pvPortMalloc+0x114>)
 80004c6:	4293      	cmp	r3, r2
 80004c8:	d03a      	beq.n	8000540 <pvPortMalloc+0xfc>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 80004ca:	69bb      	ldr	r3, [r7, #24]
 80004cc:	681b      	ldr	r3, [r3, #0]
 80004ce:	2208      	movs	r2, #8
 80004d0:	4413      	add	r3, r2
 80004d2:	617b      	str	r3, [r7, #20]

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80004d4:	69fb      	ldr	r3, [r7, #28]
 80004d6:	681a      	ldr	r2, [r3, #0]
 80004d8:	69bb      	ldr	r3, [r7, #24]
 80004da:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80004dc:	69fb      	ldr	r3, [r7, #28]
 80004de:	685a      	ldr	r2, [r3, #4]
 80004e0:	687b      	ldr	r3, [r7, #4]
 80004e2:	1ad3      	subs	r3, r2, r3
 80004e4:	2208      	movs	r2, #8
 80004e6:	0052      	lsls	r2, r2, #1
 80004e8:	4293      	cmp	r3, r2
 80004ea:	d922      	bls.n	8000532 <pvPortMalloc+0xee>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80004ec:	69fa      	ldr	r2, [r7, #28]
 80004ee:	687b      	ldr	r3, [r7, #4]
 80004f0:	4413      	add	r3, r2
 80004f2:	60fb      	str	r3, [r7, #12]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80004f4:	69fb      	ldr	r3, [r7, #28]
 80004f6:	685a      	ldr	r2, [r3, #4]
 80004f8:	687b      	ldr	r3, [r7, #4]
 80004fa:	1ad2      	subs	r2, r2, r3
 80004fc:	68fb      	ldr	r3, [r7, #12]
 80004fe:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
 8000500:	69fb      	ldr	r3, [r7, #28]
 8000502:	687a      	ldr	r2, [r7, #4]
 8000504:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8000506:	68fb      	ldr	r3, [r7, #12]
 8000508:	685b      	ldr	r3, [r3, #4]
 800050a:	60bb      	str	r3, [r7, #8]
 800050c:	4b11      	ldr	r3, [pc, #68]	; (8000554 <pvPortMalloc+0x110>)
 800050e:	613b      	str	r3, [r7, #16]
 8000510:	e002      	b.n	8000518 <pvPortMalloc+0xd4>
 8000512:	693b      	ldr	r3, [r7, #16]
 8000514:	681b      	ldr	r3, [r3, #0]
 8000516:	613b      	str	r3, [r7, #16]
 8000518:	693b      	ldr	r3, [r7, #16]
 800051a:	681b      	ldr	r3, [r3, #0]
 800051c:	685a      	ldr	r2, [r3, #4]
 800051e:	68bb      	ldr	r3, [r7, #8]
 8000520:	429a      	cmp	r2, r3
 8000522:	d3f6      	bcc.n	8000512 <pvPortMalloc+0xce>
 8000524:	693b      	ldr	r3, [r7, #16]
 8000526:	681a      	ldr	r2, [r3, #0]
 8000528:	68fb      	ldr	r3, [r7, #12]
 800052a:	601a      	str	r2, [r3, #0]
 800052c:	693b      	ldr	r3, [r7, #16]
 800052e:	68fa      	ldr	r2, [r7, #12]
 8000530:	601a      	str	r2, [r3, #0]
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 8000532:	4b0a      	ldr	r3, [pc, #40]	; (800055c <pvPortMalloc+0x118>)
 8000534:	681a      	ldr	r2, [r3, #0]
 8000536:	69fb      	ldr	r3, [r7, #28]
 8000538:	685b      	ldr	r3, [r3, #4]
 800053a:	1ad3      	subs	r3, r2, r3
 800053c:	4a07      	ldr	r2, [pc, #28]	; (800055c <pvPortMalloc+0x118>)
 800053e:	6013      	str	r3, [r2, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8000540:	f000 fd4c 	bl	8000fdc <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 8000544:	697b      	ldr	r3, [r7, #20]
}
 8000546:	4618      	mov	r0, r3
 8000548:	3720      	adds	r7, #32
 800054a:	46bd      	mov	sp, r7
 800054c:	bd80      	pop	{r7, pc}
 800054e:	bf00      	nop
 8000550:	20001854 	.word	0x20001854
 8000554:	20001844 	.word	0x20001844
 8000558:	2000184c 	.word	0x2000184c
 800055c:	20000004 	.word	0x20000004

08000560 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8000560:	b580      	push	{r7, lr}
 8000562:	b086      	sub	sp, #24
 8000564:	af00      	add	r7, sp, #0
 8000566:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 8000568:	687b      	ldr	r3, [r7, #4]
 800056a:	613b      	str	r3, [r7, #16]
BlockLink_t *pxLink;

	if( pv != NULL )
 800056c:	687b      	ldr	r3, [r7, #4]
 800056e:	2b00      	cmp	r3, #0
 8000570:	d027      	beq.n	80005c2 <vPortFree+0x62>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 8000572:	2308      	movs	r3, #8
 8000574:	425b      	negs	r3, r3
 8000576:	693a      	ldr	r2, [r7, #16]
 8000578:	4413      	add	r3, r2
 800057a:	613b      	str	r3, [r7, #16]

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
 800057c:	693b      	ldr	r3, [r7, #16]
 800057e:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
 8000580:	f000 fd1e 	bl	8000fc0 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8000584:	68fb      	ldr	r3, [r7, #12]
 8000586:	685b      	ldr	r3, [r3, #4]
 8000588:	60bb      	str	r3, [r7, #8]
 800058a:	4b10      	ldr	r3, [pc, #64]	; (80005cc <vPortFree+0x6c>)
 800058c:	617b      	str	r3, [r7, #20]
 800058e:	e002      	b.n	8000596 <vPortFree+0x36>
 8000590:	697b      	ldr	r3, [r7, #20]
 8000592:	681b      	ldr	r3, [r3, #0]
 8000594:	617b      	str	r3, [r7, #20]
 8000596:	697b      	ldr	r3, [r7, #20]
 8000598:	681b      	ldr	r3, [r3, #0]
 800059a:	685a      	ldr	r2, [r3, #4]
 800059c:	68bb      	ldr	r3, [r7, #8]
 800059e:	429a      	cmp	r2, r3
 80005a0:	d3f6      	bcc.n	8000590 <vPortFree+0x30>
 80005a2:	697b      	ldr	r3, [r7, #20]
 80005a4:	681a      	ldr	r2, [r3, #0]
 80005a6:	68fb      	ldr	r3, [r7, #12]
 80005a8:	601a      	str	r2, [r3, #0]
 80005aa:	697b      	ldr	r3, [r7, #20]
 80005ac:	68fa      	ldr	r2, [r7, #12]
 80005ae:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
 80005b0:	68fb      	ldr	r3, [r7, #12]
 80005b2:	685a      	ldr	r2, [r3, #4]
 80005b4:	4b06      	ldr	r3, [pc, #24]	; (80005d0 <vPortFree+0x70>)
 80005b6:	681b      	ldr	r3, [r3, #0]
 80005b8:	4413      	add	r3, r2
 80005ba:	4a05      	ldr	r2, [pc, #20]	; (80005d0 <vPortFree+0x70>)
 80005bc:	6013      	str	r3, [r2, #0]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 80005be:	f000 fd0d 	bl	8000fdc <xTaskResumeAll>
	}
}
 80005c2:	bf00      	nop
 80005c4:	3718      	adds	r7, #24
 80005c6:	46bd      	mov	sp, r7
 80005c8:	bd80      	pop	{r7, pc}
 80005ca:	bf00      	nop
 80005cc:	20001844 	.word	0x20001844
 80005d0:	20000004 	.word	0x20000004

080005d4 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 80005d4:	b480      	push	{r7}
 80005d6:	b083      	sub	sp, #12
 80005d8:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 80005da:	4b0f      	ldr	r3, [pc, #60]	; (8000618 <prvHeapInit+0x44>)
 80005dc:	f023 0307 	bic.w	r3, r3, #7
 80005e0:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80005e2:	4a0e      	ldr	r2, [pc, #56]	; (800061c <prvHeapInit+0x48>)
 80005e4:	687b      	ldr	r3, [r7, #4]
 80005e6:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 80005e8:	4b0c      	ldr	r3, [pc, #48]	; (800061c <prvHeapInit+0x48>)
 80005ea:	2200      	movs	r2, #0
 80005ec:	605a      	str	r2, [r3, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 80005ee:	4b0c      	ldr	r3, [pc, #48]	; (8000620 <prvHeapInit+0x4c>)
 80005f0:	f241 72f8 	movw	r2, #6136	; 0x17f8
 80005f4:	605a      	str	r2, [r3, #4]
	xEnd.pxNextFreeBlock = NULL;
 80005f6:	4b0a      	ldr	r3, [pc, #40]	; (8000620 <prvHeapInit+0x4c>)
 80005f8:	2200      	movs	r2, #0
 80005fa:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 80005fc:	687b      	ldr	r3, [r7, #4]
 80005fe:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 8000600:	683b      	ldr	r3, [r7, #0]
 8000602:	f241 72f8 	movw	r2, #6136	; 0x17f8
 8000606:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 8000608:	683b      	ldr	r3, [r7, #0]
 800060a:	4a05      	ldr	r2, [pc, #20]	; (8000620 <prvHeapInit+0x4c>)
 800060c:	601a      	str	r2, [r3, #0]
}
 800060e:	bf00      	nop
 8000610:	370c      	adds	r7, #12
 8000612:	46bd      	mov	sp, r7
 8000614:	bc80      	pop	{r7}
 8000616:	4770      	bx	lr
 8000618:	2000004c 	.word	0x2000004c
 800061c:	20001844 	.word	0x20001844
 8000620:	2000184c 	.word	0x2000184c

08000624 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 8000624:	b480      	push	{r7}
 8000626:	b083      	sub	sp, #12
 8000628:	af00      	add	r7, sp, #0
 800062a:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800062c:	687b      	ldr	r3, [r7, #4]
 800062e:	f103 0208 	add.w	r2, r3, #8
 8000632:	687b      	ldr	r3, [r7, #4]
 8000634:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000636:	687b      	ldr	r3, [r7, #4]
 8000638:	f04f 32ff 	mov.w	r2, #4294967295
 800063c:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800063e:	687b      	ldr	r3, [r7, #4]
 8000640:	f103 0208 	add.w	r2, r3, #8
 8000644:	687b      	ldr	r3, [r7, #4]
 8000646:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000648:	687b      	ldr	r3, [r7, #4]
 800064a:	f103 0208 	add.w	r2, r3, #8
 800064e:	687b      	ldr	r3, [r7, #4]
 8000650:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8000652:	687b      	ldr	r3, [r7, #4]
 8000654:	2200      	movs	r2, #0
 8000656:	601a      	str	r2, [r3, #0]
}
 8000658:	bf00      	nop
 800065a:	370c      	adds	r7, #12
 800065c:	46bd      	mov	sp, r7
 800065e:	bc80      	pop	{r7}
 8000660:	4770      	bx	lr
 8000662:	bf00      	nop

08000664 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 8000664:	b480      	push	{r7}
 8000666:	b083      	sub	sp, #12
 8000668:	af00      	add	r7, sp, #0
 800066a:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800066c:	687b      	ldr	r3, [r7, #4]
 800066e:	2200      	movs	r2, #0
 8000670:	611a      	str	r2, [r3, #16]
}
 8000672:	bf00      	nop
 8000674:	370c      	adds	r7, #12
 8000676:	46bd      	mov	sp, r7
 8000678:	bc80      	pop	{r7}
 800067a:	4770      	bx	lr

0800067c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800067c:	b480      	push	{r7}
 800067e:	b085      	sub	sp, #20
 8000680:	af00      	add	r7, sp, #0
 8000682:	6078      	str	r0, [r7, #4]
 8000684:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 8000686:	687b      	ldr	r3, [r7, #4]
 8000688:	685b      	ldr	r3, [r3, #4]
 800068a:	60fb      	str	r3, [r7, #12]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 800068c:	683b      	ldr	r3, [r7, #0]
 800068e:	68fa      	ldr	r2, [r7, #12]
 8000690:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8000692:	68fb      	ldr	r3, [r7, #12]
 8000694:	689a      	ldr	r2, [r3, #8]
 8000696:	683b      	ldr	r3, [r7, #0]
 8000698:	609a      	str	r2, [r3, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800069a:	68fb      	ldr	r3, [r7, #12]
 800069c:	689b      	ldr	r3, [r3, #8]
 800069e:	683a      	ldr	r2, [r7, #0]
 80006a0:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80006a2:	68fb      	ldr	r3, [r7, #12]
 80006a4:	683a      	ldr	r2, [r7, #0]
 80006a6:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80006a8:	683b      	ldr	r3, [r7, #0]
 80006aa:	687a      	ldr	r2, [r7, #4]
 80006ac:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 80006ae:	687b      	ldr	r3, [r7, #4]
 80006b0:	681b      	ldr	r3, [r3, #0]
 80006b2:	1c5a      	adds	r2, r3, #1
 80006b4:	687b      	ldr	r3, [r7, #4]
 80006b6:	601a      	str	r2, [r3, #0]
}
 80006b8:	bf00      	nop
 80006ba:	3714      	adds	r7, #20
 80006bc:	46bd      	mov	sp, r7
 80006be:	bc80      	pop	{r7}
 80006c0:	4770      	bx	lr
 80006c2:	bf00      	nop

080006c4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80006c4:	b480      	push	{r7}
 80006c6:	b085      	sub	sp, #20
 80006c8:	af00      	add	r7, sp, #0
 80006ca:	6078      	str	r0, [r7, #4]
 80006cc:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80006ce:	683b      	ldr	r3, [r7, #0]
 80006d0:	681b      	ldr	r3, [r3, #0]
 80006d2:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80006d4:	68bb      	ldr	r3, [r7, #8]
 80006d6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80006da:	d103      	bne.n	80006e4 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80006dc:	687b      	ldr	r3, [r7, #4]
 80006de:	691b      	ldr	r3, [r3, #16]
 80006e0:	60fb      	str	r3, [r7, #12]
 80006e2:	e00c      	b.n	80006fe <vListInsert+0x3a>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80006e4:	687b      	ldr	r3, [r7, #4]
 80006e6:	3308      	adds	r3, #8
 80006e8:	60fb      	str	r3, [r7, #12]
 80006ea:	e002      	b.n	80006f2 <vListInsert+0x2e>
 80006ec:	68fb      	ldr	r3, [r7, #12]
 80006ee:	685b      	ldr	r3, [r3, #4]
 80006f0:	60fb      	str	r3, [r7, #12]
 80006f2:	68fb      	ldr	r3, [r7, #12]
 80006f4:	685b      	ldr	r3, [r3, #4]
 80006f6:	681a      	ldr	r2, [r3, #0]
 80006f8:	68bb      	ldr	r3, [r7, #8]
 80006fa:	429a      	cmp	r2, r3
 80006fc:	d9f6      	bls.n	80006ec <vListInsert+0x28>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80006fe:	68fb      	ldr	r3, [r7, #12]
 8000700:	685a      	ldr	r2, [r3, #4]
 8000702:	683b      	ldr	r3, [r7, #0]
 8000704:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8000706:	683b      	ldr	r3, [r7, #0]
 8000708:	685b      	ldr	r3, [r3, #4]
 800070a:	683a      	ldr	r2, [r7, #0]
 800070c:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800070e:	683b      	ldr	r3, [r7, #0]
 8000710:	68fa      	ldr	r2, [r7, #12]
 8000712:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 8000714:	68fb      	ldr	r3, [r7, #12]
 8000716:	683a      	ldr	r2, [r7, #0]
 8000718:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800071a:	683b      	ldr	r3, [r7, #0]
 800071c:	687a      	ldr	r2, [r7, #4]
 800071e:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000720:	687b      	ldr	r3, [r7, #4]
 8000722:	681b      	ldr	r3, [r3, #0]
 8000724:	1c5a      	adds	r2, r3, #1
 8000726:	687b      	ldr	r3, [r7, #4]
 8000728:	601a      	str	r2, [r3, #0]
}
 800072a:	bf00      	nop
 800072c:	3714      	adds	r7, #20
 800072e:	46bd      	mov	sp, r7
 8000730:	bc80      	pop	{r7}
 8000732:	4770      	bx	lr

08000734 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8000734:	b480      	push	{r7}
 8000736:	b085      	sub	sp, #20
 8000738:	af00      	add	r7, sp, #0
 800073a:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800073c:	687b      	ldr	r3, [r7, #4]
 800073e:	691b      	ldr	r3, [r3, #16]
 8000740:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000742:	687b      	ldr	r3, [r7, #4]
 8000744:	685b      	ldr	r3, [r3, #4]
 8000746:	687a      	ldr	r2, [r7, #4]
 8000748:	6892      	ldr	r2, [r2, #8]
 800074a:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800074c:	687b      	ldr	r3, [r7, #4]
 800074e:	689b      	ldr	r3, [r3, #8]
 8000750:	687a      	ldr	r2, [r7, #4]
 8000752:	6852      	ldr	r2, [r2, #4]
 8000754:	605a      	str	r2, [r3, #4]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000756:	68fb      	ldr	r3, [r7, #12]
 8000758:	685a      	ldr	r2, [r3, #4]
 800075a:	687b      	ldr	r3, [r7, #4]
 800075c:	429a      	cmp	r2, r3
 800075e:	d103      	bne.n	8000768 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000760:	687b      	ldr	r3, [r7, #4]
 8000762:	689a      	ldr	r2, [r3, #8]
 8000764:	68fb      	ldr	r3, [r7, #12]
 8000766:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8000768:	687b      	ldr	r3, [r7, #4]
 800076a:	2200      	movs	r2, #0
 800076c:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 800076e:	68fb      	ldr	r3, [r7, #12]
 8000770:	681b      	ldr	r3, [r3, #0]
 8000772:	1e5a      	subs	r2, r3, #1
 8000774:	68fb      	ldr	r3, [r7, #12]
 8000776:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8000778:	68fb      	ldr	r3, [r7, #12]
 800077a:	681b      	ldr	r3, [r3, #0]
}
 800077c:	4618      	mov	r0, r3
 800077e:	3714      	adds	r7, #20
 8000780:	46bd      	mov	sp, r7
 8000782:	bc80      	pop	{r7}
 8000784:	4770      	bx	lr
 8000786:	bf00      	nop

08000788 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 8000788:	b580      	push	{r7, lr}
 800078a:	b084      	sub	sp, #16
 800078c:	af00      	add	r7, sp, #0
 800078e:	6078      	str	r0, [r7, #4]
 8000790:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 8000792:	687b      	ldr	r3, [r7, #4]
 8000794:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 8000796:	f7ff fdd9 	bl	800034c <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800079a:	68fb      	ldr	r3, [r7, #12]
 800079c:	681a      	ldr	r2, [r3, #0]
 800079e:	68fb      	ldr	r3, [r7, #12]
 80007a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80007a2:	68f9      	ldr	r1, [r7, #12]
 80007a4:	6c09      	ldr	r1, [r1, #64]	; 0x40
 80007a6:	fb01 f303 	mul.w	r3, r1, r3
 80007aa:	441a      	add	r2, r3
 80007ac:	68fb      	ldr	r3, [r7, #12]
 80007ae:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80007b0:	68fb      	ldr	r3, [r7, #12]
 80007b2:	2200      	movs	r2, #0
 80007b4:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80007b6:	68fb      	ldr	r3, [r7, #12]
 80007b8:	681a      	ldr	r2, [r3, #0]
 80007ba:	68fb      	ldr	r3, [r7, #12]
 80007bc:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80007be:	68fb      	ldr	r3, [r7, #12]
 80007c0:	681a      	ldr	r2, [r3, #0]
 80007c2:	68fb      	ldr	r3, [r7, #12]
 80007c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80007c6:	3b01      	subs	r3, #1
 80007c8:	68f9      	ldr	r1, [r7, #12]
 80007ca:	6c09      	ldr	r1, [r1, #64]	; 0x40
 80007cc:	fb01 f303 	mul.w	r3, r1, r3
 80007d0:	441a      	add	r2, r3
 80007d2:	68fb      	ldr	r3, [r7, #12]
 80007d4:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
 80007d6:	68fb      	ldr	r3, [r7, #12]
 80007d8:	f04f 32ff 	mov.w	r2, #4294967295
 80007dc:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 80007de:	68fb      	ldr	r3, [r7, #12]
 80007e0:	f04f 32ff 	mov.w	r2, #4294967295
 80007e4:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 80007e6:	683b      	ldr	r3, [r7, #0]
 80007e8:	2b00      	cmp	r3, #0
 80007ea:	d10e      	bne.n	800080a <xQueueGenericReset+0x82>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80007ec:	68fb      	ldr	r3, [r7, #12]
 80007ee:	691b      	ldr	r3, [r3, #16]
 80007f0:	2b00      	cmp	r3, #0
 80007f2:	d014      	beq.n	800081e <xQueueGenericReset+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 80007f4:	68fb      	ldr	r3, [r7, #12]
 80007f6:	3310      	adds	r3, #16
 80007f8:	4618      	mov	r0, r3
 80007fa:	f000 fd97 	bl	800132c <xTaskRemoveFromEventList>
 80007fe:	4603      	mov	r3, r0
 8000800:	2b01      	cmp	r3, #1
 8000802:	d10c      	bne.n	800081e <xQueueGenericReset+0x96>
				{
					queueYIELD_IF_USING_PREEMPTION();
 8000804:	f7ff fd92 	bl	800032c <vPortYield>
 8000808:	e009      	b.n	800081e <xQueueGenericReset+0x96>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800080a:	68fb      	ldr	r3, [r7, #12]
 800080c:	3310      	adds	r3, #16
 800080e:	4618      	mov	r0, r3
 8000810:	f7ff ff08 	bl	8000624 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8000814:	68fb      	ldr	r3, [r7, #12]
 8000816:	3324      	adds	r3, #36	; 0x24
 8000818:	4618      	mov	r0, r3
 800081a:	f7ff ff03 	bl	8000624 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 800081e:	f7ff fda7 	bl	8000370 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 8000822:	2301      	movs	r3, #1
}
 8000824:	4618      	mov	r0, r3
 8000826:	3710      	adds	r7, #16
 8000828:	46bd      	mov	sp, r7
 800082a:	bd80      	pop	{r7, pc}

0800082c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
 800082c:	b580      	push	{r7, lr}
 800082e:	b088      	sub	sp, #32
 8000830:	af00      	add	r7, sp, #0
 8000832:	60f8      	str	r0, [r7, #12]
 8000834:	60b9      	str	r1, [r7, #8]
 8000836:	4613      	mov	r3, r2
 8000838:	71fb      	strb	r3, [r7, #7]
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
 800083a:	2300      	movs	r3, #0
 800083c:	61fb      	str	r3, [r7, #28]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
 800083e:	68fb      	ldr	r3, [r7, #12]
 8000840:	2b00      	cmp	r3, #0
 8000842:	d026      	beq.n	8000892 <xQueueGenericCreate+0x66>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 8000844:	204c      	movs	r0, #76	; 0x4c
 8000846:	f7ff fdfd 	bl	8000444 <pvPortMalloc>
 800084a:	61b8      	str	r0, [r7, #24]
		if( pxNewQueue != NULL )
 800084c:	69bb      	ldr	r3, [r7, #24]
 800084e:	2b00      	cmp	r3, #0
 8000850:	d01f      	beq.n	8000892 <xQueueGenericCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000852:	68fb      	ldr	r3, [r7, #12]
 8000854:	68ba      	ldr	r2, [r7, #8]
 8000856:	fb02 f303 	mul.w	r3, r2, r3
 800085a:	3301      	adds	r3, #1
 800085c:	617b      	str	r3, [r7, #20]

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
 800085e:	6978      	ldr	r0, [r7, #20]
 8000860:	f7ff fdf0 	bl	8000444 <pvPortMalloc>
 8000864:	4602      	mov	r2, r0
 8000866:	69bb      	ldr	r3, [r7, #24]
 8000868:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
 800086a:	69bb      	ldr	r3, [r7, #24]
 800086c:	681b      	ldr	r3, [r3, #0]
 800086e:	2b00      	cmp	r3, #0
 8000870:	d00c      	beq.n	800088c <xQueueGenericCreate+0x60>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
 8000872:	69bb      	ldr	r3, [r7, #24]
 8000874:	68fa      	ldr	r2, [r7, #12]
 8000876:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 8000878:	69bb      	ldr	r3, [r7, #24]
 800087a:	68ba      	ldr	r2, [r7, #8]
 800087c:	641a      	str	r2, [r3, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800087e:	2101      	movs	r1, #1
 8000880:	69b8      	ldr	r0, [r7, #24]
 8000882:	f7ff ff81 	bl	8000788 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
 8000886:	69bb      	ldr	r3, [r7, #24]
 8000888:	61fb      	str	r3, [r7, #28]
 800088a:	e002      	b.n	8000892 <xQueueGenericCreate+0x66>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
 800088c:	69b8      	ldr	r0, [r7, #24]
 800088e:	f7ff fe67 	bl	8000560 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
 8000892:	69fb      	ldr	r3, [r7, #28]
}
 8000894:	4618      	mov	r0, r3
 8000896:	3720      	adds	r7, #32
 8000898:	46bd      	mov	sp, r7
 800089a:	bd80      	pop	{r7, pc}

0800089c <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 800089c:	b580      	push	{r7, lr}
 800089e:	b084      	sub	sp, #16
 80008a0:	af00      	add	r7, sp, #0
 80008a2:	6078      	str	r0, [r7, #4]
 80008a4:	6039      	str	r1, [r7, #0]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80008a6:	2202      	movs	r2, #2
 80008a8:	2100      	movs	r1, #0
 80008aa:	6878      	ldr	r0, [r7, #4]
 80008ac:	f7ff ffbe 	bl	800082c <xQueueGenericCreate>
 80008b0:	60f8      	str	r0, [r7, #12]

		if( xHandle != NULL )
 80008b2:	68fb      	ldr	r3, [r7, #12]
 80008b4:	2b00      	cmp	r3, #0
 80008b6:	d002      	beq.n	80008be <xQueueCreateCountingSemaphore+0x22>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80008b8:	68fb      	ldr	r3, [r7, #12]
 80008ba:	683a      	ldr	r2, [r7, #0]
 80008bc:	639a      	str	r2, [r3, #56]	; 0x38
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
 80008be:	68fb      	ldr	r3, [r7, #12]
	}
 80008c0:	4618      	mov	r0, r3
 80008c2:	3710      	adds	r7, #16
 80008c4:	46bd      	mov	sp, r7
 80008c6:	bd80      	pop	{r7, pc}

080008c8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 80008c8:	b580      	push	{r7, lr}
 80008ca:	b088      	sub	sp, #32
 80008cc:	af00      	add	r7, sp, #0
 80008ce:	60f8      	str	r0, [r7, #12]
 80008d0:	60b9      	str	r1, [r7, #8]
 80008d2:	607a      	str	r2, [r7, #4]
 80008d4:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
 80008d6:	2300      	movs	r3, #0
 80008d8:	61fb      	str	r3, [r7, #28]
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 80008da:	68fb      	ldr	r3, [r7, #12]
 80008dc:	61bb      	str	r3, [r7, #24]
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 80008de:	f7ff fd35 	bl	800034c <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80008e2:	69bb      	ldr	r3, [r7, #24]
 80008e4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80008e6:	69bb      	ldr	r3, [r7, #24]
 80008e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80008ea:	429a      	cmp	r2, r3
 80008ec:	d302      	bcc.n	80008f4 <xQueueGenericSend+0x2c>
 80008ee:	683b      	ldr	r3, [r7, #0]
 80008f0:	2b02      	cmp	r3, #2
 80008f2:	d116      	bne.n	8000922 <xQueueGenericSend+0x5a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80008f4:	683a      	ldr	r2, [r7, #0]
 80008f6:	68b9      	ldr	r1, [r7, #8]
 80008f8:	69b8      	ldr	r0, [r7, #24]
 80008fa:	f000 f967 	bl	8000bcc <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80008fe:	69bb      	ldr	r3, [r7, #24]
 8000900:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000902:	2b00      	cmp	r3, #0
 8000904:	d009      	beq.n	800091a <xQueueGenericSend+0x52>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 8000906:	69bb      	ldr	r3, [r7, #24]
 8000908:	3324      	adds	r3, #36	; 0x24
 800090a:	4618      	mov	r0, r3
 800090c:	f000 fd0e 	bl	800132c <xTaskRemoveFromEventList>
 8000910:	4603      	mov	r3, r0
 8000912:	2b01      	cmp	r3, #1
 8000914:	d101      	bne.n	800091a <xQueueGenericSend+0x52>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 8000916:	f7ff fd09 	bl	800032c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 800091a:	f7ff fd29 	bl	8000370 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 800091e:	2301      	movs	r3, #1
 8000920:	e056      	b.n	80009d0 <xQueueGenericSend+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8000922:	687b      	ldr	r3, [r7, #4]
 8000924:	2b00      	cmp	r3, #0
 8000926:	d103      	bne.n	8000930 <xQueueGenericSend+0x68>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8000928:	f7ff fd22 	bl	8000370 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 800092c:	2300      	movs	r3, #0
 800092e:	e04f      	b.n	80009d0 <xQueueGenericSend+0x108>
				}
				else if( xEntryTimeSet == pdFALSE )
 8000930:	69fb      	ldr	r3, [r7, #28]
 8000932:	2b00      	cmp	r3, #0
 8000934:	d106      	bne.n	8000944 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8000936:	f107 0310 	add.w	r3, r7, #16
 800093a:	4618      	mov	r0, r3
 800093c:	f000 fd4c 	bl	80013d8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8000940:	2301      	movs	r3, #1
 8000942:	61fb      	str	r3, [r7, #28]
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8000944:	f7ff fd14 	bl	8000370 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8000948:	f000 fb3a 	bl	8000fc0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800094c:	f7ff fcfe 	bl	800034c <vPortEnterCritical>
 8000950:	69bb      	ldr	r3, [r7, #24]
 8000952:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000954:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000958:	d102      	bne.n	8000960 <xQueueGenericSend+0x98>
 800095a:	69bb      	ldr	r3, [r7, #24]
 800095c:	2200      	movs	r2, #0
 800095e:	645a      	str	r2, [r3, #68]	; 0x44
 8000960:	69bb      	ldr	r3, [r7, #24]
 8000962:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000964:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000968:	d102      	bne.n	8000970 <xQueueGenericSend+0xa8>
 800096a:	69bb      	ldr	r3, [r7, #24]
 800096c:	2200      	movs	r2, #0
 800096e:	649a      	str	r2, [r3, #72]	; 0x48
 8000970:	f7ff fcfe 	bl	8000370 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000974:	1d3a      	adds	r2, r7, #4
 8000976:	f107 0310 	add.w	r3, r7, #16
 800097a:	4611      	mov	r1, r2
 800097c:	4618      	mov	r0, r3
 800097e:	f000 fd41 	bl	8001404 <xTaskCheckForTimeOut>
 8000982:	4603      	mov	r3, r0
 8000984:	2b00      	cmp	r3, #0
 8000986:	d11d      	bne.n	80009c4 <xQueueGenericSend+0xfc>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8000988:	69b8      	ldr	r0, [r7, #24]
 800098a:	f000 fa0f 	bl	8000dac <prvIsQueueFull>
 800098e:	4603      	mov	r3, r0
 8000990:	2b00      	cmp	r3, #0
 8000992:	d011      	beq.n	80009b8 <xQueueGenericSend+0xf0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8000994:	69bb      	ldr	r3, [r7, #24]
 8000996:	3310      	adds	r3, #16
 8000998:	687a      	ldr	r2, [r7, #4]
 800099a:	4611      	mov	r1, r2
 800099c:	4618      	mov	r0, r3
 800099e:	f000 fc95 	bl	80012cc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 80009a2:	69b8      	ldr	r0, [r7, #24]
 80009a4:	f000 f9a0 	bl	8000ce8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 80009a8:	f000 fb18 	bl	8000fdc <xTaskResumeAll>
 80009ac:	4603      	mov	r3, r0
 80009ae:	2b00      	cmp	r3, #0
 80009b0:	d195      	bne.n	80008de <xQueueGenericSend+0x16>
				{
					portYIELD_WITHIN_API();
 80009b2:	f7ff fcbb 	bl	800032c <vPortYield>
 80009b6:	e792      	b.n	80008de <xQueueGenericSend+0x16>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80009b8:	69b8      	ldr	r0, [r7, #24]
 80009ba:	f000 f995 	bl	8000ce8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80009be:	f000 fb0d 	bl	8000fdc <xTaskResumeAll>
 80009c2:	e78c      	b.n	80008de <xQueueGenericSend+0x16>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 80009c4:	69b8      	ldr	r0, [r7, #24]
 80009c6:	f000 f98f 	bl	8000ce8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80009ca:	f000 fb07 	bl	8000fdc <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 80009ce:	2300      	movs	r3, #0
		}
	}
}
 80009d0:	4618      	mov	r0, r3
 80009d2:	3720      	adds	r7, #32
 80009d4:	46bd      	mov	sp, r7
 80009d6:	bd80      	pop	{r7, pc}

080009d8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 80009d8:	b580      	push	{r7, lr}
 80009da:	b088      	sub	sp, #32
 80009dc:	af00      	add	r7, sp, #0
 80009de:	60f8      	str	r0, [r7, #12]
 80009e0:	60b9      	str	r1, [r7, #8]
 80009e2:	607a      	str	r2, [r7, #4]
 80009e4:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 80009e6:	68fb      	ldr	r3, [r7, #12]
 80009e8:	61bb      	str	r3, [r7, #24]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80009ea:	f7ff fcd3 	bl	8000394 <ulPortSetInterruptMask>
 80009ee:	6178      	str	r0, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80009f0:	69bb      	ldr	r3, [r7, #24]
 80009f2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80009f4:	69bb      	ldr	r3, [r7, #24]
 80009f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80009f8:	429a      	cmp	r2, r3
 80009fa:	d302      	bcc.n	8000a02 <xQueueGenericSendFromISR+0x2a>
 80009fc:	683b      	ldr	r3, [r7, #0]
 80009fe:	2b02      	cmp	r3, #2
 8000a00:	d124      	bne.n	8000a4c <xQueueGenericSendFromISR+0x74>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8000a02:	683a      	ldr	r2, [r7, #0]
 8000a04:	68b9      	ldr	r1, [r7, #8]
 8000a06:	69b8      	ldr	r0, [r7, #24]
 8000a08:	f000 f8e0 	bl	8000bcc <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 8000a0c:	69bb      	ldr	r3, [r7, #24]
 8000a0e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000a10:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000a14:	d112      	bne.n	8000a3c <xQueueGenericSendFromISR+0x64>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000a16:	69bb      	ldr	r3, [r7, #24]
 8000a18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000a1a:	2b00      	cmp	r3, #0
 8000a1c:	d013      	beq.n	8000a46 <xQueueGenericSendFromISR+0x6e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000a1e:	69bb      	ldr	r3, [r7, #24]
 8000a20:	3324      	adds	r3, #36	; 0x24
 8000a22:	4618      	mov	r0, r3
 8000a24:	f000 fc82 	bl	800132c <xTaskRemoveFromEventList>
 8000a28:	4603      	mov	r3, r0
 8000a2a:	2b00      	cmp	r3, #0
 8000a2c:	d00b      	beq.n	8000a46 <xQueueGenericSendFromISR+0x6e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 8000a2e:	687b      	ldr	r3, [r7, #4]
 8000a30:	2b00      	cmp	r3, #0
 8000a32:	d008      	beq.n	8000a46 <xQueueGenericSendFromISR+0x6e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8000a34:	687b      	ldr	r3, [r7, #4]
 8000a36:	2201      	movs	r2, #1
 8000a38:	601a      	str	r2, [r3, #0]
 8000a3a:	e004      	b.n	8000a46 <xQueueGenericSendFromISR+0x6e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 8000a3c:	69bb      	ldr	r3, [r7, #24]
 8000a3e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000a40:	1c5a      	adds	r2, r3, #1
 8000a42:	69bb      	ldr	r3, [r7, #24]
 8000a44:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
 8000a46:	2301      	movs	r3, #1
 8000a48:	61fb      	str	r3, [r7, #28]
 8000a4a:	e001      	b.n	8000a50 <xQueueGenericSendFromISR+0x78>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8000a4c:	2300      	movs	r3, #0
 8000a4e:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8000a50:	6978      	ldr	r0, [r7, #20]
 8000a52:	f7ff fca9 	bl	80003a8 <vPortClearInterruptMask>

	return xReturn;
 8000a56:	69fb      	ldr	r3, [r7, #28]
}
 8000a58:	4618      	mov	r0, r3
 8000a5a:	3720      	adds	r7, #32
 8000a5c:	46bd      	mov	sp, r7
 8000a5e:	bd80      	pop	{r7, pc}

08000a60 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 8000a60:	b580      	push	{r7, lr}
 8000a62:	b08a      	sub	sp, #40	; 0x28
 8000a64:	af00      	add	r7, sp, #0
 8000a66:	60f8      	str	r0, [r7, #12]
 8000a68:	60b9      	str	r1, [r7, #8]
 8000a6a:	607a      	str	r2, [r7, #4]
 8000a6c:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
 8000a6e:	2300      	movs	r3, #0
 8000a70:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 8000a72:	68fb      	ldr	r3, [r7, #12]
 8000a74:	623b      	str	r3, [r7, #32]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8000a76:	f7ff fc69 	bl	800034c <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000a7a:	6a3b      	ldr	r3, [r7, #32]
 8000a7c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000a7e:	2b00      	cmp	r3, #0
 8000a80:	d03b      	beq.n	8000afa <xQueueGenericReceive+0x9a>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8000a82:	6a3b      	ldr	r3, [r7, #32]
 8000a84:	68db      	ldr	r3, [r3, #12]
 8000a86:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8000a88:	68b9      	ldr	r1, [r7, #8]
 8000a8a:	6a38      	ldr	r0, [r7, #32]
 8000a8c:	f000 f906 	bl	8000c9c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8000a90:	683b      	ldr	r3, [r7, #0]
 8000a92:	2b00      	cmp	r3, #0
 8000a94:	d11c      	bne.n	8000ad0 <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 8000a96:	6a3b      	ldr	r3, [r7, #32]
 8000a98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000a9a:	1e5a      	subs	r2, r3, #1
 8000a9c:	6a3b      	ldr	r3, [r7, #32]
 8000a9e:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8000aa0:	6a3b      	ldr	r3, [r7, #32]
 8000aa2:	681b      	ldr	r3, [r3, #0]
 8000aa4:	2b00      	cmp	r3, #0
 8000aa6:	d104      	bne.n	8000ab2 <xQueueGenericReceive+0x52>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8000aa8:	f000 fe64 	bl	8001774 <xTaskGetCurrentTaskHandle>
 8000aac:	4602      	mov	r2, r0
 8000aae:	6a3b      	ldr	r3, [r7, #32]
 8000ab0:	605a      	str	r2, [r3, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000ab2:	6a3b      	ldr	r3, [r7, #32]
 8000ab4:	691b      	ldr	r3, [r3, #16]
 8000ab6:	2b00      	cmp	r3, #0
 8000ab8:	d01b      	beq.n	8000af2 <xQueueGenericReceive+0x92>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8000aba:	6a3b      	ldr	r3, [r7, #32]
 8000abc:	3310      	adds	r3, #16
 8000abe:	4618      	mov	r0, r3
 8000ac0:	f000 fc34 	bl	800132c <xTaskRemoveFromEventList>
 8000ac4:	4603      	mov	r3, r0
 8000ac6:	2b01      	cmp	r3, #1
 8000ac8:	d113      	bne.n	8000af2 <xQueueGenericReceive+0x92>
						{
							queueYIELD_IF_USING_PREEMPTION();
 8000aca:	f7ff fc2f 	bl	800032c <vPortYield>
 8000ace:	e010      	b.n	8000af2 <xQueueGenericReceive+0x92>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8000ad0:	6a3b      	ldr	r3, [r7, #32]
 8000ad2:	69fa      	ldr	r2, [r7, #28]
 8000ad4:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000ad6:	6a3b      	ldr	r3, [r7, #32]
 8000ad8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000ada:	2b00      	cmp	r3, #0
 8000adc:	d009      	beq.n	8000af2 <xQueueGenericReceive+0x92>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000ade:	6a3b      	ldr	r3, [r7, #32]
 8000ae0:	3324      	adds	r3, #36	; 0x24
 8000ae2:	4618      	mov	r0, r3
 8000ae4:	f000 fc22 	bl	800132c <xTaskRemoveFromEventList>
 8000ae8:	4603      	mov	r3, r0
 8000aea:	2b00      	cmp	r3, #0
 8000aec:	d001      	beq.n	8000af2 <xQueueGenericReceive+0x92>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
 8000aee:	f7ff fc1d 	bl	800032c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 8000af2:	f7ff fc3d 	bl	8000370 <vPortExitCritical>
				return pdPASS;
 8000af6:	2301      	movs	r3, #1
 8000af8:	e064      	b.n	8000bc4 <xQueueGenericReceive+0x164>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8000afa:	687b      	ldr	r3, [r7, #4]
 8000afc:	2b00      	cmp	r3, #0
 8000afe:	d103      	bne.n	8000b08 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8000b00:	f7ff fc36 	bl	8000370 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 8000b04:	2300      	movs	r3, #0
 8000b06:	e05d      	b.n	8000bc4 <xQueueGenericReceive+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
 8000b08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000b0a:	2b00      	cmp	r3, #0
 8000b0c:	d106      	bne.n	8000b1c <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8000b0e:	f107 0314 	add.w	r3, r7, #20
 8000b12:	4618      	mov	r0, r3
 8000b14:	f000 fc60 	bl	80013d8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8000b18:	2301      	movs	r3, #1
 8000b1a:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8000b1c:	f7ff fc28 	bl	8000370 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8000b20:	f000 fa4e 	bl	8000fc0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8000b24:	f7ff fc12 	bl	800034c <vPortEnterCritical>
 8000b28:	6a3b      	ldr	r3, [r7, #32]
 8000b2a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000b2c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000b30:	d102      	bne.n	8000b38 <xQueueGenericReceive+0xd8>
 8000b32:	6a3b      	ldr	r3, [r7, #32]
 8000b34:	2200      	movs	r2, #0
 8000b36:	645a      	str	r2, [r3, #68]	; 0x44
 8000b38:	6a3b      	ldr	r3, [r7, #32]
 8000b3a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000b3c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000b40:	d102      	bne.n	8000b48 <xQueueGenericReceive+0xe8>
 8000b42:	6a3b      	ldr	r3, [r7, #32]
 8000b44:	2200      	movs	r2, #0
 8000b46:	649a      	str	r2, [r3, #72]	; 0x48
 8000b48:	f7ff fc12 	bl	8000370 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000b4c:	1d3a      	adds	r2, r7, #4
 8000b4e:	f107 0314 	add.w	r3, r7, #20
 8000b52:	4611      	mov	r1, r2
 8000b54:	4618      	mov	r0, r3
 8000b56:	f000 fc55 	bl	8001404 <xTaskCheckForTimeOut>
 8000b5a:	4603      	mov	r3, r0
 8000b5c:	2b00      	cmp	r3, #0
 8000b5e:	d12b      	bne.n	8000bb8 <xQueueGenericReceive+0x158>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8000b60:	6a38      	ldr	r0, [r7, #32]
 8000b62:	f000 f90d 	bl	8000d80 <prvIsQueueEmpty>
 8000b66:	4603      	mov	r3, r0
 8000b68:	2b00      	cmp	r3, #0
 8000b6a:	d01f      	beq.n	8000bac <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8000b6c:	6a3b      	ldr	r3, [r7, #32]
 8000b6e:	681b      	ldr	r3, [r3, #0]
 8000b70:	2b00      	cmp	r3, #0
 8000b72:	d108      	bne.n	8000b86 <xQueueGenericReceive+0x126>
					{
						taskENTER_CRITICAL();
 8000b74:	f7ff fbea 	bl	800034c <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8000b78:	6a3b      	ldr	r3, [r7, #32]
 8000b7a:	685b      	ldr	r3, [r3, #4]
 8000b7c:	4618      	mov	r0, r3
 8000b7e:	f000 fe07 	bl	8001790 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
 8000b82:	f7ff fbf5 	bl	8000370 <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8000b86:	6a3b      	ldr	r3, [r7, #32]
 8000b88:	3324      	adds	r3, #36	; 0x24
 8000b8a:	687a      	ldr	r2, [r7, #4]
 8000b8c:	4611      	mov	r1, r2
 8000b8e:	4618      	mov	r0, r3
 8000b90:	f000 fb9c 	bl	80012cc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8000b94:	6a38      	ldr	r0, [r7, #32]
 8000b96:	f000 f8a7 	bl	8000ce8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8000b9a:	f000 fa1f 	bl	8000fdc <xTaskResumeAll>
 8000b9e:	4603      	mov	r3, r0
 8000ba0:	2b00      	cmp	r3, #0
 8000ba2:	f47f af68 	bne.w	8000a76 <xQueueGenericReceive+0x16>
				{
					portYIELD_WITHIN_API();
 8000ba6:	f7ff fbc1 	bl	800032c <vPortYield>
 8000baa:	e764      	b.n	8000a76 <xQueueGenericReceive+0x16>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8000bac:	6a38      	ldr	r0, [r7, #32]
 8000bae:	f000 f89b 	bl	8000ce8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8000bb2:	f000 fa13 	bl	8000fdc <xTaskResumeAll>
 8000bb6:	e75e      	b.n	8000a76 <xQueueGenericReceive+0x16>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8000bb8:	6a38      	ldr	r0, [r7, #32]
 8000bba:	f000 f895 	bl	8000ce8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8000bbe:	f000 fa0d 	bl	8000fdc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 8000bc2:	2300      	movs	r3, #0
		}
	}
}
 8000bc4:	4618      	mov	r0, r3
 8000bc6:	3728      	adds	r7, #40	; 0x28
 8000bc8:	46bd      	mov	sp, r7
 8000bca:	bd80      	pop	{r7, pc}

08000bcc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8000bcc:	b580      	push	{r7, lr}
 8000bce:	b084      	sub	sp, #16
 8000bd0:	af00      	add	r7, sp, #0
 8000bd2:	60f8      	str	r0, [r7, #12]
 8000bd4:	60b9      	str	r1, [r7, #8]
 8000bd6:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8000bd8:	68fb      	ldr	r3, [r7, #12]
 8000bda:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000bdc:	2b00      	cmp	r3, #0
 8000bde:	d10c      	bne.n	8000bfa <prvCopyDataToQueue+0x2e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8000be0:	68fb      	ldr	r3, [r7, #12]
 8000be2:	681b      	ldr	r3, [r3, #0]
 8000be4:	2b00      	cmp	r3, #0
 8000be6:	d14f      	bne.n	8000c88 <prvCopyDataToQueue+0xbc>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8000be8:	68fb      	ldr	r3, [r7, #12]
 8000bea:	685b      	ldr	r3, [r3, #4]
 8000bec:	4618      	mov	r0, r3
 8000bee:	f000 fe2d 	bl	800184c <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8000bf2:	68fb      	ldr	r3, [r7, #12]
 8000bf4:	2200      	movs	r2, #0
 8000bf6:	605a      	str	r2, [r3, #4]
 8000bf8:	e046      	b.n	8000c88 <prvCopyDataToQueue+0xbc>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8000bfa:	687b      	ldr	r3, [r7, #4]
 8000bfc:	2b00      	cmp	r3, #0
 8000bfe:	d119      	bne.n	8000c34 <prvCopyDataToQueue+0x68>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8000c00:	68fb      	ldr	r3, [r7, #12]
 8000c02:	6898      	ldr	r0, [r3, #8]
 8000c04:	68fb      	ldr	r3, [r7, #12]
 8000c06:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000c08:	461a      	mov	r2, r3
 8000c0a:	68b9      	ldr	r1, [r7, #8]
 8000c0c:	f002 ff7c 	bl	8003b08 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8000c10:	68fb      	ldr	r3, [r7, #12]
 8000c12:	689a      	ldr	r2, [r3, #8]
 8000c14:	68fb      	ldr	r3, [r7, #12]
 8000c16:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000c18:	441a      	add	r2, r3
 8000c1a:	68fb      	ldr	r3, [r7, #12]
 8000c1c:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8000c1e:	68fb      	ldr	r3, [r7, #12]
 8000c20:	689a      	ldr	r2, [r3, #8]
 8000c22:	68fb      	ldr	r3, [r7, #12]
 8000c24:	685b      	ldr	r3, [r3, #4]
 8000c26:	429a      	cmp	r2, r3
 8000c28:	d32e      	bcc.n	8000c88 <prvCopyDataToQueue+0xbc>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8000c2a:	68fb      	ldr	r3, [r7, #12]
 8000c2c:	681a      	ldr	r2, [r3, #0]
 8000c2e:	68fb      	ldr	r3, [r7, #12]
 8000c30:	609a      	str	r2, [r3, #8]
 8000c32:	e029      	b.n	8000c88 <prvCopyDataToQueue+0xbc>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000c34:	68fb      	ldr	r3, [r7, #12]
 8000c36:	68d8      	ldr	r0, [r3, #12]
 8000c38:	68fb      	ldr	r3, [r7, #12]
 8000c3a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000c3c:	461a      	mov	r2, r3
 8000c3e:	68b9      	ldr	r1, [r7, #8]
 8000c40:	f002 ff62 	bl	8003b08 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8000c44:	68fb      	ldr	r3, [r7, #12]
 8000c46:	68da      	ldr	r2, [r3, #12]
 8000c48:	68fb      	ldr	r3, [r7, #12]
 8000c4a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000c4c:	425b      	negs	r3, r3
 8000c4e:	441a      	add	r2, r3
 8000c50:	68fb      	ldr	r3, [r7, #12]
 8000c52:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8000c54:	68fb      	ldr	r3, [r7, #12]
 8000c56:	68da      	ldr	r2, [r3, #12]
 8000c58:	68fb      	ldr	r3, [r7, #12]
 8000c5a:	681b      	ldr	r3, [r3, #0]
 8000c5c:	429a      	cmp	r2, r3
 8000c5e:	d207      	bcs.n	8000c70 <prvCopyDataToQueue+0xa4>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8000c60:	68fb      	ldr	r3, [r7, #12]
 8000c62:	685a      	ldr	r2, [r3, #4]
 8000c64:	68fb      	ldr	r3, [r7, #12]
 8000c66:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000c68:	425b      	negs	r3, r3
 8000c6a:	441a      	add	r2, r3
 8000c6c:	68fb      	ldr	r3, [r7, #12]
 8000c6e:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 8000c70:	687b      	ldr	r3, [r7, #4]
 8000c72:	2b02      	cmp	r3, #2
 8000c74:	d108      	bne.n	8000c88 <prvCopyDataToQueue+0xbc>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000c76:	68fb      	ldr	r3, [r7, #12]
 8000c78:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000c7a:	2b00      	cmp	r3, #0
 8000c7c:	d004      	beq.n	8000c88 <prvCopyDataToQueue+0xbc>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 8000c7e:	68fb      	ldr	r3, [r7, #12]
 8000c80:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000c82:	1e5a      	subs	r2, r3, #1
 8000c84:	68fb      	ldr	r3, [r7, #12]
 8000c86:	639a      	str	r2, [r3, #56]	; 0x38
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8000c88:	68fb      	ldr	r3, [r7, #12]
 8000c8a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000c8c:	1c5a      	adds	r2, r3, #1
 8000c8e:	68fb      	ldr	r3, [r7, #12]
 8000c90:	639a      	str	r2, [r3, #56]	; 0x38
}
 8000c92:	bf00      	nop
 8000c94:	3710      	adds	r7, #16
 8000c96:	46bd      	mov	sp, r7
 8000c98:	bd80      	pop	{r7, pc}
 8000c9a:	bf00      	nop

08000c9c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8000c9c:	b580      	push	{r7, lr}
 8000c9e:	b082      	sub	sp, #8
 8000ca0:	af00      	add	r7, sp, #0
 8000ca2:	6078      	str	r0, [r7, #4]
 8000ca4:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8000ca6:	687b      	ldr	r3, [r7, #4]
 8000ca8:	681b      	ldr	r3, [r3, #0]
 8000caa:	2b00      	cmp	r3, #0
 8000cac:	d018      	beq.n	8000ce0 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8000cae:	687b      	ldr	r3, [r7, #4]
 8000cb0:	68da      	ldr	r2, [r3, #12]
 8000cb2:	687b      	ldr	r3, [r7, #4]
 8000cb4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000cb6:	441a      	add	r2, r3
 8000cb8:	687b      	ldr	r3, [r7, #4]
 8000cba:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000cbc:	687b      	ldr	r3, [r7, #4]
 8000cbe:	68da      	ldr	r2, [r3, #12]
 8000cc0:	687b      	ldr	r3, [r7, #4]
 8000cc2:	685b      	ldr	r3, [r3, #4]
 8000cc4:	429a      	cmp	r2, r3
 8000cc6:	d303      	bcc.n	8000cd0 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8000cc8:	687b      	ldr	r3, [r7, #4]
 8000cca:	681a      	ldr	r2, [r3, #0]
 8000ccc:	687b      	ldr	r3, [r7, #4]
 8000cce:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8000cd0:	687b      	ldr	r3, [r7, #4]
 8000cd2:	68d9      	ldr	r1, [r3, #12]
 8000cd4:	687b      	ldr	r3, [r7, #4]
 8000cd6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000cd8:	461a      	mov	r2, r3
 8000cda:	6838      	ldr	r0, [r7, #0]
 8000cdc:	f002 ff14 	bl	8003b08 <memcpy>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8000ce0:	bf00      	nop
 8000ce2:	3708      	adds	r7, #8
 8000ce4:	46bd      	mov	sp, r7
 8000ce6:	bd80      	pop	{r7, pc}

08000ce8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8000ce8:	b580      	push	{r7, lr}
 8000cea:	b082      	sub	sp, #8
 8000cec:	af00      	add	r7, sp, #0
 8000cee:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8000cf0:	f7ff fb2c 	bl	800034c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8000cf4:	e012      	b.n	8000d1c <prvUnlockQueue+0x34>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000cf6:	687b      	ldr	r3, [r7, #4]
 8000cf8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000cfa:	2b00      	cmp	r3, #0
 8000cfc:	d013      	beq.n	8000d26 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000cfe:	687b      	ldr	r3, [r7, #4]
 8000d00:	3324      	adds	r3, #36	; 0x24
 8000d02:	4618      	mov	r0, r3
 8000d04:	f000 fb12 	bl	800132c <xTaskRemoveFromEventList>
 8000d08:	4603      	mov	r3, r0
 8000d0a:	2b00      	cmp	r3, #0
 8000d0c:	d001      	beq.n	8000d12 <prvUnlockQueue+0x2a>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 8000d0e:	f000 fbbd 	bl	800148c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8000d12:	687b      	ldr	r3, [r7, #4]
 8000d14:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000d16:	1e5a      	subs	r2, r3, #1
 8000d18:	687b      	ldr	r3, [r7, #4]
 8000d1a:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8000d1c:	687b      	ldr	r3, [r7, #4]
 8000d1e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000d20:	2b00      	cmp	r3, #0
 8000d22:	dce8      	bgt.n	8000cf6 <prvUnlockQueue+0xe>
 8000d24:	e000      	b.n	8000d28 <prvUnlockQueue+0x40>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 8000d26:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8000d28:	687b      	ldr	r3, [r7, #4]
 8000d2a:	f04f 32ff 	mov.w	r2, #4294967295
 8000d2e:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8000d30:	f7ff fb1e 	bl	8000370 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8000d34:	f7ff fb0a 	bl	800034c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8000d38:	e012      	b.n	8000d60 <prvUnlockQueue+0x78>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000d3a:	687b      	ldr	r3, [r7, #4]
 8000d3c:	691b      	ldr	r3, [r3, #16]
 8000d3e:	2b00      	cmp	r3, #0
 8000d40:	d013      	beq.n	8000d6a <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000d42:	687b      	ldr	r3, [r7, #4]
 8000d44:	3310      	adds	r3, #16
 8000d46:	4618      	mov	r0, r3
 8000d48:	f000 faf0 	bl	800132c <xTaskRemoveFromEventList>
 8000d4c:	4603      	mov	r3, r0
 8000d4e:	2b00      	cmp	r3, #0
 8000d50:	d001      	beq.n	8000d56 <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
 8000d52:	f000 fb9b 	bl	800148c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 8000d56:	687b      	ldr	r3, [r7, #4]
 8000d58:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000d5a:	1e5a      	subs	r2, r3, #1
 8000d5c:	687b      	ldr	r3, [r7, #4]
 8000d5e:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8000d60:	687b      	ldr	r3, [r7, #4]
 8000d62:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000d64:	2b00      	cmp	r3, #0
 8000d66:	dce8      	bgt.n	8000d3a <prvUnlockQueue+0x52>
 8000d68:	e000      	b.n	8000d6c <prvUnlockQueue+0x84>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
 8000d6a:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8000d6c:	687b      	ldr	r3, [r7, #4]
 8000d6e:	f04f 32ff 	mov.w	r2, #4294967295
 8000d72:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 8000d74:	f7ff fafc 	bl	8000370 <vPortExitCritical>
}
 8000d78:	bf00      	nop
 8000d7a:	3708      	adds	r7, #8
 8000d7c:	46bd      	mov	sp, r7
 8000d7e:	bd80      	pop	{r7, pc}

08000d80 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 8000d80:	b580      	push	{r7, lr}
 8000d82:	b084      	sub	sp, #16
 8000d84:	af00      	add	r7, sp, #0
 8000d86:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8000d88:	f7ff fae0 	bl	800034c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8000d8c:	687b      	ldr	r3, [r7, #4]
 8000d8e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000d90:	2b00      	cmp	r3, #0
 8000d92:	d102      	bne.n	8000d9a <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
 8000d94:	2301      	movs	r3, #1
 8000d96:	60fb      	str	r3, [r7, #12]
 8000d98:	e001      	b.n	8000d9e <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
 8000d9a:	2300      	movs	r3, #0
 8000d9c:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8000d9e:	f7ff fae7 	bl	8000370 <vPortExitCritical>

	return xReturn;
 8000da2:	68fb      	ldr	r3, [r7, #12]
}
 8000da4:	4618      	mov	r0, r3
 8000da6:	3710      	adds	r7, #16
 8000da8:	46bd      	mov	sp, r7
 8000daa:	bd80      	pop	{r7, pc}

08000dac <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 8000dac:	b580      	push	{r7, lr}
 8000dae:	b084      	sub	sp, #16
 8000db0:	af00      	add	r7, sp, #0
 8000db2:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8000db4:	f7ff faca 	bl	800034c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8000db8:	687b      	ldr	r3, [r7, #4]
 8000dba:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000dbc:	687b      	ldr	r3, [r7, #4]
 8000dbe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000dc0:	429a      	cmp	r2, r3
 8000dc2:	d102      	bne.n	8000dca <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
 8000dc4:	2301      	movs	r3, #1
 8000dc6:	60fb      	str	r3, [r7, #12]
 8000dc8:	e001      	b.n	8000dce <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
 8000dca:	2300      	movs	r3, #0
 8000dcc:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8000dce:	f7ff facf 	bl	8000370 <vPortExitCritical>

	return xReturn;
 8000dd2:	68fb      	ldr	r3, [r7, #12]
}
 8000dd4:	4618      	mov	r0, r3
 8000dd6:	3710      	adds	r7, #16
 8000dd8:	46bd      	mov	sp, r7
 8000dda:	bd80      	pop	{r7, pc}

08000ddc <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8000ddc:	b580      	push	{r7, lr}
 8000dde:	b08a      	sub	sp, #40	; 0x28
 8000de0:	af02      	add	r7, sp, #8
 8000de2:	60f8      	str	r0, [r7, #12]
 8000de4:	60b9      	str	r1, [r7, #8]
 8000de6:	603b      	str	r3, [r7, #0]
 8000de8:	4613      	mov	r3, r2
 8000dea:	80fb      	strh	r3, [r7, #6]
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 8000dec:	88fb      	ldrh	r3, [r7, #6]
 8000dee:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8000df0:	4618      	mov	r0, r3
 8000df2:	f000 fc63 	bl	80016bc <prvAllocateTCBAndStack>
 8000df6:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
 8000df8:	69bb      	ldr	r3, [r7, #24]
 8000dfa:	2b00      	cmp	r3, #0
 8000dfc:	d066      	beq.n	8000ecc <xTaskGenericCreate+0xf0>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8000dfe:	69bb      	ldr	r3, [r7, #24]
 8000e00:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000e02:	88fb      	ldrh	r3, [r7, #6]
 8000e04:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000e08:	3b01      	subs	r3, #1
 8000e0a:	009b      	lsls	r3, r3, #2
 8000e0c:	4413      	add	r3, r2
 8000e0e:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8000e10:	697b      	ldr	r3, [r7, #20]
 8000e12:	f023 0307 	bic.w	r3, r3, #7
 8000e16:	617b      	str	r3, [r7, #20]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 8000e18:	88fb      	ldrh	r3, [r7, #6]
 8000e1a:	9300      	str	r3, [sp, #0]
 8000e1c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8000e1e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8000e20:	68b9      	ldr	r1, [r7, #8]
 8000e22:	69b8      	ldr	r0, [r7, #24]
 8000e24:	f000 fb4e 	bl	80014c4 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8000e28:	683a      	ldr	r2, [r7, #0]
 8000e2a:	68f9      	ldr	r1, [r7, #12]
 8000e2c:	6978      	ldr	r0, [r7, #20]
 8000e2e:	f7ff fa0b 	bl	8000248 <pxPortInitialiseStack>
 8000e32:	4602      	mov	r2, r0
 8000e34:	69bb      	ldr	r3, [r7, #24]
 8000e36:	601a      	str	r2, [r3, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8000e38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e3a:	2b00      	cmp	r3, #0
 8000e3c:	d002      	beq.n	8000e44 <xTaskGenericCreate+0x68>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8000e3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e40:	69ba      	ldr	r2, [r7, #24]
 8000e42:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8000e44:	f7ff fa82 	bl	800034c <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8000e48:	4b2c      	ldr	r3, [pc, #176]	; (8000efc <xTaskGenericCreate+0x120>)
 8000e4a:	681b      	ldr	r3, [r3, #0]
 8000e4c:	3301      	adds	r3, #1
 8000e4e:	4a2b      	ldr	r2, [pc, #172]	; (8000efc <xTaskGenericCreate+0x120>)
 8000e50:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
 8000e52:	4b2b      	ldr	r3, [pc, #172]	; (8000f00 <xTaskGenericCreate+0x124>)
 8000e54:	681b      	ldr	r3, [r3, #0]
 8000e56:	2b00      	cmp	r3, #0
 8000e58:	d109      	bne.n	8000e6e <xTaskGenericCreate+0x92>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8000e5a:	4a29      	ldr	r2, [pc, #164]	; (8000f00 <xTaskGenericCreate+0x124>)
 8000e5c:	69bb      	ldr	r3, [r7, #24]
 8000e5e:	6013      	str	r3, [r2, #0]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8000e60:	4b26      	ldr	r3, [pc, #152]	; (8000efc <xTaskGenericCreate+0x120>)
 8000e62:	681b      	ldr	r3, [r3, #0]
 8000e64:	2b01      	cmp	r3, #1
 8000e66:	d10f      	bne.n	8000e88 <xTaskGenericCreate+0xac>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 8000e68:	f000 fb76 	bl	8001558 <prvInitialiseTaskLists>
 8000e6c:	e00c      	b.n	8000e88 <xTaskGenericCreate+0xac>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8000e6e:	4b25      	ldr	r3, [pc, #148]	; (8000f04 <xTaskGenericCreate+0x128>)
 8000e70:	681b      	ldr	r3, [r3, #0]
 8000e72:	2b00      	cmp	r3, #0
 8000e74:	d108      	bne.n	8000e88 <xTaskGenericCreate+0xac>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8000e76:	4b22      	ldr	r3, [pc, #136]	; (8000f00 <xTaskGenericCreate+0x124>)
 8000e78:	681b      	ldr	r3, [r3, #0]
 8000e7a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000e7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000e7e:	429a      	cmp	r2, r3
 8000e80:	d802      	bhi.n	8000e88 <xTaskGenericCreate+0xac>
					{
						pxCurrentTCB = pxNewTCB;
 8000e82:	4a1f      	ldr	r2, [pc, #124]	; (8000f00 <xTaskGenericCreate+0x124>)
 8000e84:	69bb      	ldr	r3, [r7, #24]
 8000e86:	6013      	str	r3, [r2, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8000e88:	4b1f      	ldr	r3, [pc, #124]	; (8000f08 <xTaskGenericCreate+0x12c>)
 8000e8a:	681b      	ldr	r3, [r3, #0]
 8000e8c:	3301      	adds	r3, #1
 8000e8e:	4a1e      	ldr	r2, [pc, #120]	; (8000f08 <xTaskGenericCreate+0x12c>)
 8000e90:	6013      	str	r3, [r2, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8000e92:	69bb      	ldr	r3, [r7, #24]
 8000e94:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000e96:	4b1d      	ldr	r3, [pc, #116]	; (8000f0c <xTaskGenericCreate+0x130>)
 8000e98:	681b      	ldr	r3, [r3, #0]
 8000e9a:	429a      	cmp	r2, r3
 8000e9c:	d903      	bls.n	8000ea6 <xTaskGenericCreate+0xca>
 8000e9e:	69bb      	ldr	r3, [r7, #24]
 8000ea0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000ea2:	4a1a      	ldr	r2, [pc, #104]	; (8000f0c <xTaskGenericCreate+0x130>)
 8000ea4:	6013      	str	r3, [r2, #0]
 8000ea6:	69bb      	ldr	r3, [r7, #24]
 8000ea8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000eaa:	4613      	mov	r3, r2
 8000eac:	009b      	lsls	r3, r3, #2
 8000eae:	4413      	add	r3, r2
 8000eb0:	009b      	lsls	r3, r3, #2
 8000eb2:	4a17      	ldr	r2, [pc, #92]	; (8000f10 <xTaskGenericCreate+0x134>)
 8000eb4:	441a      	add	r2, r3
 8000eb6:	69bb      	ldr	r3, [r7, #24]
 8000eb8:	3304      	adds	r3, #4
 8000eba:	4619      	mov	r1, r3
 8000ebc:	4610      	mov	r0, r2
 8000ebe:	f7ff fbdd 	bl	800067c <vListInsertEnd>

			xReturn = pdPASS;
 8000ec2:	2301      	movs	r3, #1
 8000ec4:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8000ec6:	f7ff fa53 	bl	8000370 <vPortExitCritical>
 8000eca:	e002      	b.n	8000ed2 <xTaskGenericCreate+0xf6>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8000ecc:	f04f 33ff 	mov.w	r3, #4294967295
 8000ed0:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
 8000ed2:	69fb      	ldr	r3, [r7, #28]
 8000ed4:	2b01      	cmp	r3, #1
 8000ed6:	d10b      	bne.n	8000ef0 <xTaskGenericCreate+0x114>
	{
		if( xSchedulerRunning != pdFALSE )
 8000ed8:	4b0a      	ldr	r3, [pc, #40]	; (8000f04 <xTaskGenericCreate+0x128>)
 8000eda:	681b      	ldr	r3, [r3, #0]
 8000edc:	2b00      	cmp	r3, #0
 8000ede:	d007      	beq.n	8000ef0 <xTaskGenericCreate+0x114>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8000ee0:	4b07      	ldr	r3, [pc, #28]	; (8000f00 <xTaskGenericCreate+0x124>)
 8000ee2:	681b      	ldr	r3, [r3, #0]
 8000ee4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000ee6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000ee8:	429a      	cmp	r2, r3
 8000eea:	d201      	bcs.n	8000ef0 <xTaskGenericCreate+0x114>
			{
				taskYIELD_IF_USING_PREEMPTION();
 8000eec:	f7ff fa1e 	bl	800032c <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
 8000ef0:	69fb      	ldr	r3, [r7, #28]
}
 8000ef2:	4618      	mov	r0, r3
 8000ef4:	3720      	adds	r7, #32
 8000ef6:	46bd      	mov	sp, r7
 8000ef8:	bd80      	pop	{r7, pc}
 8000efa:	bf00      	nop
 8000efc:	20001930 	.word	0x20001930
 8000f00:	20001858 	.word	0x20001858
 8000f04:	2000193c 	.word	0x2000193c
 8000f08:	2000194c 	.word	0x2000194c
 8000f0c:	20001938 	.word	0x20001938
 8000f10:	2000185c 	.word	0x2000185c

08000f14 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8000f14:	b580      	push	{r7, lr}
 8000f16:	b084      	sub	sp, #16
 8000f18:	af00      	add	r7, sp, #0
 8000f1a:	6078      	str	r0, [r7, #4]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
 8000f1c:	2300      	movs	r3, #0
 8000f1e:	60fb      	str	r3, [r7, #12]


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8000f20:	687b      	ldr	r3, [r7, #4]
 8000f22:	2b00      	cmp	r3, #0
 8000f24:	d012      	beq.n	8000f4c <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 8000f26:	f000 f84b 	bl	8000fc0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8000f2a:	4b0d      	ldr	r3, [pc, #52]	; (8000f60 <vTaskDelay+0x4c>)
 8000f2c:	681a      	ldr	r2, [r3, #0]
 8000f2e:	687b      	ldr	r3, [r7, #4]
 8000f30:	4413      	add	r3, r2
 8000f32:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8000f34:	4b0b      	ldr	r3, [pc, #44]	; (8000f64 <vTaskDelay+0x50>)
 8000f36:	681b      	ldr	r3, [r3, #0]
 8000f38:	3304      	adds	r3, #4
 8000f3a:	4618      	mov	r0, r3
 8000f3c:	f7ff fbfa 	bl	8000734 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8000f40:	68b8      	ldr	r0, [r7, #8]
 8000f42:	f000 fb85 	bl	8001650 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8000f46:	f000 f849 	bl	8000fdc <xTaskResumeAll>
 8000f4a:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8000f4c:	68fb      	ldr	r3, [r7, #12]
 8000f4e:	2b00      	cmp	r3, #0
 8000f50:	d101      	bne.n	8000f56 <vTaskDelay+0x42>
		{
			portYIELD_WITHIN_API();
 8000f52:	f7ff f9eb 	bl	800032c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8000f56:	bf00      	nop
 8000f58:	3710      	adds	r7, #16
 8000f5a:	46bd      	mov	sp, r7
 8000f5c:	bd80      	pop	{r7, pc}
 8000f5e:	bf00      	nop
 8000f60:	20001934 	.word	0x20001934
 8000f64:	20001858 	.word	0x20001858

08000f68 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8000f68:	b580      	push	{r7, lr}
 8000f6a:	b086      	sub	sp, #24
 8000f6c:	af04      	add	r7, sp, #16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 8000f6e:	2300      	movs	r3, #0
 8000f70:	9303      	str	r3, [sp, #12]
 8000f72:	2300      	movs	r3, #0
 8000f74:	9302      	str	r3, [sp, #8]
 8000f76:	2300      	movs	r3, #0
 8000f78:	9301      	str	r3, [sp, #4]
 8000f7a:	2300      	movs	r3, #0
 8000f7c:	9300      	str	r3, [sp, #0]
 8000f7e:	2300      	movs	r3, #0
 8000f80:	2280      	movs	r2, #128	; 0x80
 8000f82:	490b      	ldr	r1, [pc, #44]	; (8000fb0 <vTaskStartScheduler+0x48>)
 8000f84:	480b      	ldr	r0, [pc, #44]	; (8000fb4 <vTaskStartScheduler+0x4c>)
 8000f86:	f7ff ff29 	bl	8000ddc <xTaskGenericCreate>
 8000f8a:	6078      	str	r0, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8000f8c:	687b      	ldr	r3, [r7, #4]
 8000f8e:	2b01      	cmp	r3, #1
 8000f90:	d109      	bne.n	8000fa6 <vTaskStartScheduler+0x3e>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 8000f92:	f7ff f9ff 	bl	8000394 <ulPortSetInterruptMask>
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 8000f96:	4b08      	ldr	r3, [pc, #32]	; (8000fb8 <vTaskStartScheduler+0x50>)
 8000f98:	2201      	movs	r2, #1
 8000f9a:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8000f9c:	4b07      	ldr	r3, [pc, #28]	; (8000fbc <vTaskStartScheduler+0x54>)
 8000f9e:	2200      	movs	r2, #0
 8000fa0:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 8000fa2:	f7ff f9a5 	bl	80002f0 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8000fa6:	bf00      	nop
 8000fa8:	3708      	adds	r7, #8
 8000faa:	46bd      	mov	sp, r7
 8000fac:	bd80      	pop	{r7, pc}
 8000fae:	bf00      	nop
 8000fb0:	08003bb0 	.word	0x08003bb0
 8000fb4:	080014a5 	.word	0x080014a5
 8000fb8:	2000193c 	.word	0x2000193c
 8000fbc:	20001934 	.word	0x20001934

08000fc0 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 8000fc0:	b480      	push	{r7}
 8000fc2:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8000fc4:	4b04      	ldr	r3, [pc, #16]	; (8000fd8 <vTaskSuspendAll+0x18>)
 8000fc6:	681b      	ldr	r3, [r3, #0]
 8000fc8:	3301      	adds	r3, #1
 8000fca:	4a03      	ldr	r2, [pc, #12]	; (8000fd8 <vTaskSuspendAll+0x18>)
 8000fcc:	6013      	str	r3, [r2, #0]
}
 8000fce:	bf00      	nop
 8000fd0:	46bd      	mov	sp, r7
 8000fd2:	bc80      	pop	{r7}
 8000fd4:	4770      	bx	lr
 8000fd6:	bf00      	nop
 8000fd8:	20001950 	.word	0x20001950

08000fdc <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8000fdc:	b580      	push	{r7, lr}
 8000fde:	b082      	sub	sp, #8
 8000fe0:	af00      	add	r7, sp, #0
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 8000fe2:	2300      	movs	r3, #0
 8000fe4:	607b      	str	r3, [r7, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8000fe6:	f7ff f9b1 	bl	800034c <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8000fea:	4b33      	ldr	r3, [pc, #204]	; (80010b8 <xTaskResumeAll+0xdc>)
 8000fec:	681b      	ldr	r3, [r3, #0]
 8000fee:	3b01      	subs	r3, #1
 8000ff0:	4a31      	ldr	r2, [pc, #196]	; (80010b8 <xTaskResumeAll+0xdc>)
 8000ff2:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000ff4:	4b30      	ldr	r3, [pc, #192]	; (80010b8 <xTaskResumeAll+0xdc>)
 8000ff6:	681b      	ldr	r3, [r3, #0]
 8000ff8:	2b00      	cmp	r3, #0
 8000ffa:	d156      	bne.n	80010aa <xTaskResumeAll+0xce>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8000ffc:	4b2f      	ldr	r3, [pc, #188]	; (80010bc <xTaskResumeAll+0xe0>)
 8000ffe:	681b      	ldr	r3, [r3, #0]
 8001000:	2b00      	cmp	r3, #0
 8001002:	d052      	beq.n	80010aa <xTaskResumeAll+0xce>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001004:	e02f      	b.n	8001066 <xTaskResumeAll+0x8a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8001006:	4b2e      	ldr	r3, [pc, #184]	; (80010c0 <xTaskResumeAll+0xe4>)
 8001008:	68db      	ldr	r3, [r3, #12]
 800100a:	68db      	ldr	r3, [r3, #12]
 800100c:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800100e:	683b      	ldr	r3, [r7, #0]
 8001010:	3318      	adds	r3, #24
 8001012:	4618      	mov	r0, r3
 8001014:	f7ff fb8e 	bl	8000734 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8001018:	683b      	ldr	r3, [r7, #0]
 800101a:	3304      	adds	r3, #4
 800101c:	4618      	mov	r0, r3
 800101e:	f7ff fb89 	bl	8000734 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8001022:	683b      	ldr	r3, [r7, #0]
 8001024:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001026:	4b27      	ldr	r3, [pc, #156]	; (80010c4 <xTaskResumeAll+0xe8>)
 8001028:	681b      	ldr	r3, [r3, #0]
 800102a:	429a      	cmp	r2, r3
 800102c:	d903      	bls.n	8001036 <xTaskResumeAll+0x5a>
 800102e:	683b      	ldr	r3, [r7, #0]
 8001030:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001032:	4a24      	ldr	r2, [pc, #144]	; (80010c4 <xTaskResumeAll+0xe8>)
 8001034:	6013      	str	r3, [r2, #0]
 8001036:	683b      	ldr	r3, [r7, #0]
 8001038:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800103a:	4613      	mov	r3, r2
 800103c:	009b      	lsls	r3, r3, #2
 800103e:	4413      	add	r3, r2
 8001040:	009b      	lsls	r3, r3, #2
 8001042:	4a21      	ldr	r2, [pc, #132]	; (80010c8 <xTaskResumeAll+0xec>)
 8001044:	441a      	add	r2, r3
 8001046:	683b      	ldr	r3, [r7, #0]
 8001048:	3304      	adds	r3, #4
 800104a:	4619      	mov	r1, r3
 800104c:	4610      	mov	r0, r2
 800104e:	f7ff fb15 	bl	800067c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001052:	683b      	ldr	r3, [r7, #0]
 8001054:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001056:	4b1d      	ldr	r3, [pc, #116]	; (80010cc <xTaskResumeAll+0xf0>)
 8001058:	681b      	ldr	r3, [r3, #0]
 800105a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800105c:	429a      	cmp	r2, r3
 800105e:	d302      	bcc.n	8001066 <xTaskResumeAll+0x8a>
					{
						xYieldPending = pdTRUE;
 8001060:	4b1b      	ldr	r3, [pc, #108]	; (80010d0 <xTaskResumeAll+0xf4>)
 8001062:	2201      	movs	r2, #1
 8001064:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001066:	4b16      	ldr	r3, [pc, #88]	; (80010c0 <xTaskResumeAll+0xe4>)
 8001068:	681b      	ldr	r3, [r3, #0]
 800106a:	2b00      	cmp	r3, #0
 800106c:	d1cb      	bne.n	8001006 <xTaskResumeAll+0x2a>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 800106e:	4b19      	ldr	r3, [pc, #100]	; (80010d4 <xTaskResumeAll+0xf8>)
 8001070:	681b      	ldr	r3, [r3, #0]
 8001072:	2b00      	cmp	r3, #0
 8001074:	d011      	beq.n	800109a <xTaskResumeAll+0xbe>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8001076:	e00c      	b.n	8001092 <xTaskResumeAll+0xb6>
					{
						if( xTaskIncrementTick() != pdFALSE )
 8001078:	f000 f82e 	bl	80010d8 <xTaskIncrementTick>
 800107c:	4603      	mov	r3, r0
 800107e:	2b00      	cmp	r3, #0
 8001080:	d002      	beq.n	8001088 <xTaskResumeAll+0xac>
						{
							xYieldPending = pdTRUE;
 8001082:	4b13      	ldr	r3, [pc, #76]	; (80010d0 <xTaskResumeAll+0xf4>)
 8001084:	2201      	movs	r2, #1
 8001086:	601a      	str	r2, [r3, #0]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 8001088:	4b12      	ldr	r3, [pc, #72]	; (80010d4 <xTaskResumeAll+0xf8>)
 800108a:	681b      	ldr	r3, [r3, #0]
 800108c:	3b01      	subs	r3, #1
 800108e:	4a11      	ldr	r2, [pc, #68]	; (80010d4 <xTaskResumeAll+0xf8>)
 8001090:	6013      	str	r3, [r2, #0]
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8001092:	4b10      	ldr	r3, [pc, #64]	; (80010d4 <xTaskResumeAll+0xf8>)
 8001094:	681b      	ldr	r3, [r3, #0]
 8001096:	2b00      	cmp	r3, #0
 8001098:	d1ee      	bne.n	8001078 <xTaskResumeAll+0x9c>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 800109a:	4b0d      	ldr	r3, [pc, #52]	; (80010d0 <xTaskResumeAll+0xf4>)
 800109c:	681b      	ldr	r3, [r3, #0]
 800109e:	2b01      	cmp	r3, #1
 80010a0:	d103      	bne.n	80010aa <xTaskResumeAll+0xce>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 80010a2:	2301      	movs	r3, #1
 80010a4:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 80010a6:	f7ff f941 	bl	800032c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 80010aa:	f7ff f961 	bl	8000370 <vPortExitCritical>

	return xAlreadyYielded;
 80010ae:	687b      	ldr	r3, [r7, #4]
}
 80010b0:	4618      	mov	r0, r3
 80010b2:	3708      	adds	r7, #8
 80010b4:	46bd      	mov	sp, r7
 80010b6:	bd80      	pop	{r7, pc}
 80010b8:	20001950 	.word	0x20001950
 80010bc:	20001930 	.word	0x20001930
 80010c0:	200018f0 	.word	0x200018f0
 80010c4:	20001938 	.word	0x20001938
 80010c8:	2000185c 	.word	0x2000185c
 80010cc:	20001858 	.word	0x20001858
 80010d0:	20001944 	.word	0x20001944
 80010d4:	20001940 	.word	0x20001940

080010d8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 80010d8:	b580      	push	{r7, lr}
 80010da:	b086      	sub	sp, #24
 80010dc:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 80010de:	2300      	movs	r3, #0
 80010e0:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80010e2:	4b49      	ldr	r3, [pc, #292]	; (8001208 <xTaskIncrementTick+0x130>)
 80010e4:	681b      	ldr	r3, [r3, #0]
 80010e6:	2b00      	cmp	r3, #0
 80010e8:	d17e      	bne.n	80011e8 <xTaskIncrementTick+0x110>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 80010ea:	4b48      	ldr	r3, [pc, #288]	; (800120c <xTaskIncrementTick+0x134>)
 80010ec:	681b      	ldr	r3, [r3, #0]
 80010ee:	3301      	adds	r3, #1
 80010f0:	4a46      	ldr	r2, [pc, #280]	; (800120c <xTaskIncrementTick+0x134>)
 80010f2:	6013      	str	r3, [r2, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 80010f4:	4b45      	ldr	r3, [pc, #276]	; (800120c <xTaskIncrementTick+0x134>)
 80010f6:	681b      	ldr	r3, [r3, #0]
 80010f8:	613b      	str	r3, [r7, #16]

			if( xConstTickCount == ( TickType_t ) 0U )
 80010fa:	693b      	ldr	r3, [r7, #16]
 80010fc:	2b00      	cmp	r3, #0
 80010fe:	d110      	bne.n	8001122 <xTaskIncrementTick+0x4a>
			{
				taskSWITCH_DELAYED_LISTS();
 8001100:	4b43      	ldr	r3, [pc, #268]	; (8001210 <xTaskIncrementTick+0x138>)
 8001102:	681b      	ldr	r3, [r3, #0]
 8001104:	60fb      	str	r3, [r7, #12]
 8001106:	4b43      	ldr	r3, [pc, #268]	; (8001214 <xTaskIncrementTick+0x13c>)
 8001108:	681b      	ldr	r3, [r3, #0]
 800110a:	4a41      	ldr	r2, [pc, #260]	; (8001210 <xTaskIncrementTick+0x138>)
 800110c:	6013      	str	r3, [r2, #0]
 800110e:	4a41      	ldr	r2, [pc, #260]	; (8001214 <xTaskIncrementTick+0x13c>)
 8001110:	68fb      	ldr	r3, [r7, #12]
 8001112:	6013      	str	r3, [r2, #0]
 8001114:	4b40      	ldr	r3, [pc, #256]	; (8001218 <xTaskIncrementTick+0x140>)
 8001116:	681b      	ldr	r3, [r3, #0]
 8001118:	3301      	adds	r3, #1
 800111a:	4a3f      	ldr	r2, [pc, #252]	; (8001218 <xTaskIncrementTick+0x140>)
 800111c:	6013      	str	r3, [r2, #0]
 800111e:	f000 fb05 	bl	800172c <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 8001122:	4b3e      	ldr	r3, [pc, #248]	; (800121c <xTaskIncrementTick+0x144>)
 8001124:	681b      	ldr	r3, [r3, #0]
 8001126:	693a      	ldr	r2, [r7, #16]
 8001128:	429a      	cmp	r2, r3
 800112a:	d34e      	bcc.n	80011ca <xTaskIncrementTick+0xf2>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800112c:	4b38      	ldr	r3, [pc, #224]	; (8001210 <xTaskIncrementTick+0x138>)
 800112e:	681b      	ldr	r3, [r3, #0]
 8001130:	681b      	ldr	r3, [r3, #0]
 8001132:	2b00      	cmp	r3, #0
 8001134:	d101      	bne.n	800113a <xTaskIncrementTick+0x62>
 8001136:	2301      	movs	r3, #1
 8001138:	e000      	b.n	800113c <xTaskIncrementTick+0x64>
 800113a:	2300      	movs	r3, #0
 800113c:	2b00      	cmp	r3, #0
 800113e:	d004      	beq.n	800114a <xTaskIncrementTick+0x72>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 8001140:	4b36      	ldr	r3, [pc, #216]	; (800121c <xTaskIncrementTick+0x144>)
 8001142:	f04f 32ff 	mov.w	r2, #4294967295
 8001146:	601a      	str	r2, [r3, #0]
						break;
 8001148:	e03f      	b.n	80011ca <xTaskIncrementTick+0xf2>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800114a:	4b31      	ldr	r3, [pc, #196]	; (8001210 <xTaskIncrementTick+0x138>)
 800114c:	681b      	ldr	r3, [r3, #0]
 800114e:	68db      	ldr	r3, [r3, #12]
 8001150:	68db      	ldr	r3, [r3, #12]
 8001152:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8001154:	68bb      	ldr	r3, [r7, #8]
 8001156:	685b      	ldr	r3, [r3, #4]
 8001158:	607b      	str	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
 800115a:	693a      	ldr	r2, [r7, #16]
 800115c:	687b      	ldr	r3, [r7, #4]
 800115e:	429a      	cmp	r2, r3
 8001160:	d203      	bcs.n	800116a <xTaskIncrementTick+0x92>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 8001162:	4a2e      	ldr	r2, [pc, #184]	; (800121c <xTaskIncrementTick+0x144>)
 8001164:	687b      	ldr	r3, [r7, #4]
 8001166:	6013      	str	r3, [r2, #0]
							break;
 8001168:	e02f      	b.n	80011ca <xTaskIncrementTick+0xf2>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800116a:	68bb      	ldr	r3, [r7, #8]
 800116c:	3304      	adds	r3, #4
 800116e:	4618      	mov	r0, r3
 8001170:	f7ff fae0 	bl	8000734 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001174:	68bb      	ldr	r3, [r7, #8]
 8001176:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001178:	2b00      	cmp	r3, #0
 800117a:	d004      	beq.n	8001186 <xTaskIncrementTick+0xae>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800117c:	68bb      	ldr	r3, [r7, #8]
 800117e:	3318      	adds	r3, #24
 8001180:	4618      	mov	r0, r3
 8001182:	f7ff fad7 	bl	8000734 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8001186:	68bb      	ldr	r3, [r7, #8]
 8001188:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800118a:	4b25      	ldr	r3, [pc, #148]	; (8001220 <xTaskIncrementTick+0x148>)
 800118c:	681b      	ldr	r3, [r3, #0]
 800118e:	429a      	cmp	r2, r3
 8001190:	d903      	bls.n	800119a <xTaskIncrementTick+0xc2>
 8001192:	68bb      	ldr	r3, [r7, #8]
 8001194:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001196:	4a22      	ldr	r2, [pc, #136]	; (8001220 <xTaskIncrementTick+0x148>)
 8001198:	6013      	str	r3, [r2, #0]
 800119a:	68bb      	ldr	r3, [r7, #8]
 800119c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800119e:	4613      	mov	r3, r2
 80011a0:	009b      	lsls	r3, r3, #2
 80011a2:	4413      	add	r3, r2
 80011a4:	009b      	lsls	r3, r3, #2
 80011a6:	4a1f      	ldr	r2, [pc, #124]	; (8001224 <xTaskIncrementTick+0x14c>)
 80011a8:	441a      	add	r2, r3
 80011aa:	68bb      	ldr	r3, [r7, #8]
 80011ac:	3304      	adds	r3, #4
 80011ae:	4619      	mov	r1, r3
 80011b0:	4610      	mov	r0, r2
 80011b2:	f7ff fa63 	bl	800067c <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80011b6:	68bb      	ldr	r3, [r7, #8]
 80011b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80011ba:	4b1b      	ldr	r3, [pc, #108]	; (8001228 <xTaskIncrementTick+0x150>)
 80011bc:	681b      	ldr	r3, [r3, #0]
 80011be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80011c0:	429a      	cmp	r2, r3
 80011c2:	d3b3      	bcc.n	800112c <xTaskIncrementTick+0x54>
							{
								xSwitchRequired = pdTRUE;
 80011c4:	2301      	movs	r3, #1
 80011c6:	617b      	str	r3, [r7, #20]
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
 80011c8:	e7b0      	b.n	800112c <xTaskIncrementTick+0x54>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80011ca:	4b17      	ldr	r3, [pc, #92]	; (8001228 <xTaskIncrementTick+0x150>)
 80011cc:	681b      	ldr	r3, [r3, #0]
 80011ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80011d0:	4914      	ldr	r1, [pc, #80]	; (8001224 <xTaskIncrementTick+0x14c>)
 80011d2:	4613      	mov	r3, r2
 80011d4:	009b      	lsls	r3, r3, #2
 80011d6:	4413      	add	r3, r2
 80011d8:	009b      	lsls	r3, r3, #2
 80011da:	440b      	add	r3, r1
 80011dc:	681b      	ldr	r3, [r3, #0]
 80011de:	2b01      	cmp	r3, #1
 80011e0:	d907      	bls.n	80011f2 <xTaskIncrementTick+0x11a>
			{
				xSwitchRequired = pdTRUE;
 80011e2:	2301      	movs	r3, #1
 80011e4:	617b      	str	r3, [r7, #20]
 80011e6:	e004      	b.n	80011f2 <xTaskIncrementTick+0x11a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 80011e8:	4b10      	ldr	r3, [pc, #64]	; (800122c <xTaskIncrementTick+0x154>)
 80011ea:	681b      	ldr	r3, [r3, #0]
 80011ec:	3301      	adds	r3, #1
 80011ee:	4a0f      	ldr	r2, [pc, #60]	; (800122c <xTaskIncrementTick+0x154>)
 80011f0:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 80011f2:	4b0f      	ldr	r3, [pc, #60]	; (8001230 <xTaskIncrementTick+0x158>)
 80011f4:	681b      	ldr	r3, [r3, #0]
 80011f6:	2b00      	cmp	r3, #0
 80011f8:	d001      	beq.n	80011fe <xTaskIncrementTick+0x126>
		{
			xSwitchRequired = pdTRUE;
 80011fa:	2301      	movs	r3, #1
 80011fc:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 80011fe:	697b      	ldr	r3, [r7, #20]
}
 8001200:	4618      	mov	r0, r3
 8001202:	3718      	adds	r7, #24
 8001204:	46bd      	mov	sp, r7
 8001206:	bd80      	pop	{r7, pc}
 8001208:	20001950 	.word	0x20001950
 800120c:	20001934 	.word	0x20001934
 8001210:	200018e8 	.word	0x200018e8
 8001214:	200018ec 	.word	0x200018ec
 8001218:	20001948 	.word	0x20001948
 800121c:	20000008 	.word	0x20000008
 8001220:	20001938 	.word	0x20001938
 8001224:	2000185c 	.word	0x2000185c
 8001228:	20001858 	.word	0x20001858
 800122c:	20001940 	.word	0x20001940
 8001230:	20001944 	.word	0x20001944

08001234 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8001234:	b480      	push	{r7}
 8001236:	b083      	sub	sp, #12
 8001238:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800123a:	4b1f      	ldr	r3, [pc, #124]	; (80012b8 <vTaskSwitchContext+0x84>)
 800123c:	681b      	ldr	r3, [r3, #0]
 800123e:	2b00      	cmp	r3, #0
 8001240:	d003      	beq.n	800124a <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8001242:	4b1e      	ldr	r3, [pc, #120]	; (80012bc <vTaskSwitchContext+0x88>)
 8001244:	2201      	movs	r2, #1
 8001246:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 8001248:	e031      	b.n	80012ae <vTaskSwitchContext+0x7a>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 800124a:	4b1c      	ldr	r3, [pc, #112]	; (80012bc <vTaskSwitchContext+0x88>)
 800124c:	2200      	movs	r2, #0
 800124e:	601a      	str	r2, [r3, #0]
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
 8001250:	e004      	b.n	800125c <vTaskSwitchContext+0x28>
 8001252:	4b1b      	ldr	r3, [pc, #108]	; (80012c0 <vTaskSwitchContext+0x8c>)
 8001254:	681b      	ldr	r3, [r3, #0]
 8001256:	3b01      	subs	r3, #1
 8001258:	4a19      	ldr	r2, [pc, #100]	; (80012c0 <vTaskSwitchContext+0x8c>)
 800125a:	6013      	str	r3, [r2, #0]
 800125c:	4b18      	ldr	r3, [pc, #96]	; (80012c0 <vTaskSwitchContext+0x8c>)
 800125e:	681a      	ldr	r2, [r3, #0]
 8001260:	4918      	ldr	r1, [pc, #96]	; (80012c4 <vTaskSwitchContext+0x90>)
 8001262:	4613      	mov	r3, r2
 8001264:	009b      	lsls	r3, r3, #2
 8001266:	4413      	add	r3, r2
 8001268:	009b      	lsls	r3, r3, #2
 800126a:	440b      	add	r3, r1
 800126c:	681b      	ldr	r3, [r3, #0]
 800126e:	2b00      	cmp	r3, #0
 8001270:	d0ef      	beq.n	8001252 <vTaskSwitchContext+0x1e>
 8001272:	4b13      	ldr	r3, [pc, #76]	; (80012c0 <vTaskSwitchContext+0x8c>)
 8001274:	681a      	ldr	r2, [r3, #0]
 8001276:	4613      	mov	r3, r2
 8001278:	009b      	lsls	r3, r3, #2
 800127a:	4413      	add	r3, r2
 800127c:	009b      	lsls	r3, r3, #2
 800127e:	4a11      	ldr	r2, [pc, #68]	; (80012c4 <vTaskSwitchContext+0x90>)
 8001280:	4413      	add	r3, r2
 8001282:	607b      	str	r3, [r7, #4]
 8001284:	687b      	ldr	r3, [r7, #4]
 8001286:	685b      	ldr	r3, [r3, #4]
 8001288:	685a      	ldr	r2, [r3, #4]
 800128a:	687b      	ldr	r3, [r7, #4]
 800128c:	605a      	str	r2, [r3, #4]
 800128e:	687b      	ldr	r3, [r7, #4]
 8001290:	685a      	ldr	r2, [r3, #4]
 8001292:	687b      	ldr	r3, [r7, #4]
 8001294:	3308      	adds	r3, #8
 8001296:	429a      	cmp	r2, r3
 8001298:	d104      	bne.n	80012a4 <vTaskSwitchContext+0x70>
 800129a:	687b      	ldr	r3, [r7, #4]
 800129c:	685b      	ldr	r3, [r3, #4]
 800129e:	685a      	ldr	r2, [r3, #4]
 80012a0:	687b      	ldr	r3, [r7, #4]
 80012a2:	605a      	str	r2, [r3, #4]
 80012a4:	687b      	ldr	r3, [r7, #4]
 80012a6:	685b      	ldr	r3, [r3, #4]
 80012a8:	68db      	ldr	r3, [r3, #12]
 80012aa:	4a07      	ldr	r2, [pc, #28]	; (80012c8 <vTaskSwitchContext+0x94>)
 80012ac:	6013      	str	r3, [r2, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 80012ae:	bf00      	nop
 80012b0:	370c      	adds	r7, #12
 80012b2:	46bd      	mov	sp, r7
 80012b4:	bc80      	pop	{r7}
 80012b6:	4770      	bx	lr
 80012b8:	20001950 	.word	0x20001950
 80012bc:	20001944 	.word	0x20001944
 80012c0:	20001938 	.word	0x20001938
 80012c4:	2000185c 	.word	0x2000185c
 80012c8:	20001858 	.word	0x20001858

080012cc <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 80012cc:	b580      	push	{r7, lr}
 80012ce:	b084      	sub	sp, #16
 80012d0:	af00      	add	r7, sp, #0
 80012d2:	6078      	str	r0, [r7, #4]
 80012d4:	6039      	str	r1, [r7, #0]

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80012d6:	4b12      	ldr	r3, [pc, #72]	; (8001320 <vTaskPlaceOnEventList+0x54>)
 80012d8:	681b      	ldr	r3, [r3, #0]
 80012da:	3318      	adds	r3, #24
 80012dc:	4619      	mov	r1, r3
 80012de:	6878      	ldr	r0, [r7, #4]
 80012e0:	f7ff f9f0 	bl	80006c4 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80012e4:	4b0e      	ldr	r3, [pc, #56]	; (8001320 <vTaskPlaceOnEventList+0x54>)
 80012e6:	681b      	ldr	r3, [r3, #0]
 80012e8:	3304      	adds	r3, #4
 80012ea:	4618      	mov	r0, r3
 80012ec:	f7ff fa22 	bl	8000734 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 80012f0:	683b      	ldr	r3, [r7, #0]
 80012f2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80012f6:	d107      	bne.n	8001308 <vTaskPlaceOnEventList+0x3c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80012f8:	4b09      	ldr	r3, [pc, #36]	; (8001320 <vTaskPlaceOnEventList+0x54>)
 80012fa:	681b      	ldr	r3, [r3, #0]
 80012fc:	3304      	adds	r3, #4
 80012fe:	4619      	mov	r1, r3
 8001300:	4808      	ldr	r0, [pc, #32]	; (8001324 <vTaskPlaceOnEventList+0x58>)
 8001302:	f7ff f9bb 	bl	800067c <vListInsertEnd>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8001306:	e007      	b.n	8001318 <vTaskPlaceOnEventList+0x4c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
 8001308:	4b07      	ldr	r3, [pc, #28]	; (8001328 <vTaskPlaceOnEventList+0x5c>)
 800130a:	681a      	ldr	r2, [r3, #0]
 800130c:	683b      	ldr	r3, [r7, #0]
 800130e:	4413      	add	r3, r2
 8001310:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8001312:	68f8      	ldr	r0, [r7, #12]
 8001314:	f000 f99c 	bl	8001650 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8001318:	bf00      	nop
 800131a:	3710      	adds	r7, #16
 800131c:	46bd      	mov	sp, r7
 800131e:	bd80      	pop	{r7, pc}
 8001320:	20001858 	.word	0x20001858
 8001324:	2000191c 	.word	0x2000191c
 8001328:	20001934 	.word	0x20001934

0800132c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 800132c:	b580      	push	{r7, lr}
 800132e:	b084      	sub	sp, #16
 8001330:	af00      	add	r7, sp, #0
 8001332:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8001334:	687b      	ldr	r3, [r7, #4]
 8001336:	68db      	ldr	r3, [r3, #12]
 8001338:	68db      	ldr	r3, [r3, #12]
 800133a:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800133c:	68bb      	ldr	r3, [r7, #8]
 800133e:	3318      	adds	r3, #24
 8001340:	4618      	mov	r0, r3
 8001342:	f7ff f9f7 	bl	8000734 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001346:	4b1e      	ldr	r3, [pc, #120]	; (80013c0 <xTaskRemoveFromEventList+0x94>)
 8001348:	681b      	ldr	r3, [r3, #0]
 800134a:	2b00      	cmp	r3, #0
 800134c:	d11d      	bne.n	800138a <xTaskRemoveFromEventList+0x5e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 800134e:	68bb      	ldr	r3, [r7, #8]
 8001350:	3304      	adds	r3, #4
 8001352:	4618      	mov	r0, r3
 8001354:	f7ff f9ee 	bl	8000734 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8001358:	68bb      	ldr	r3, [r7, #8]
 800135a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800135c:	4b19      	ldr	r3, [pc, #100]	; (80013c4 <xTaskRemoveFromEventList+0x98>)
 800135e:	681b      	ldr	r3, [r3, #0]
 8001360:	429a      	cmp	r2, r3
 8001362:	d903      	bls.n	800136c <xTaskRemoveFromEventList+0x40>
 8001364:	68bb      	ldr	r3, [r7, #8]
 8001366:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001368:	4a16      	ldr	r2, [pc, #88]	; (80013c4 <xTaskRemoveFromEventList+0x98>)
 800136a:	6013      	str	r3, [r2, #0]
 800136c:	68bb      	ldr	r3, [r7, #8]
 800136e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001370:	4613      	mov	r3, r2
 8001372:	009b      	lsls	r3, r3, #2
 8001374:	4413      	add	r3, r2
 8001376:	009b      	lsls	r3, r3, #2
 8001378:	4a13      	ldr	r2, [pc, #76]	; (80013c8 <xTaskRemoveFromEventList+0x9c>)
 800137a:	441a      	add	r2, r3
 800137c:	68bb      	ldr	r3, [r7, #8]
 800137e:	3304      	adds	r3, #4
 8001380:	4619      	mov	r1, r3
 8001382:	4610      	mov	r0, r2
 8001384:	f7ff f97a 	bl	800067c <vListInsertEnd>
 8001388:	e005      	b.n	8001396 <xTaskRemoveFromEventList+0x6a>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800138a:	68bb      	ldr	r3, [r7, #8]
 800138c:	3318      	adds	r3, #24
 800138e:	4619      	mov	r1, r3
 8001390:	480e      	ldr	r0, [pc, #56]	; (80013cc <xTaskRemoveFromEventList+0xa0>)
 8001392:	f7ff f973 	bl	800067c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8001396:	68bb      	ldr	r3, [r7, #8]
 8001398:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800139a:	4b0d      	ldr	r3, [pc, #52]	; (80013d0 <xTaskRemoveFromEventList+0xa4>)
 800139c:	681b      	ldr	r3, [r3, #0]
 800139e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80013a0:	429a      	cmp	r2, r3
 80013a2:	d905      	bls.n	80013b0 <xTaskRemoveFromEventList+0x84>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 80013a4:	2301      	movs	r3, #1
 80013a6:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 80013a8:	4b0a      	ldr	r3, [pc, #40]	; (80013d4 <xTaskRemoveFromEventList+0xa8>)
 80013aa:	2201      	movs	r2, #1
 80013ac:	601a      	str	r2, [r3, #0]
 80013ae:	e001      	b.n	80013b4 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		xReturn = pdFALSE;
 80013b0:	2300      	movs	r3, #0
 80013b2:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
 80013b4:	68fb      	ldr	r3, [r7, #12]
}
 80013b6:	4618      	mov	r0, r3
 80013b8:	3710      	adds	r7, #16
 80013ba:	46bd      	mov	sp, r7
 80013bc:	bd80      	pop	{r7, pc}
 80013be:	bf00      	nop
 80013c0:	20001950 	.word	0x20001950
 80013c4:	20001938 	.word	0x20001938
 80013c8:	2000185c 	.word	0x2000185c
 80013cc:	200018f0 	.word	0x200018f0
 80013d0:	20001858 	.word	0x20001858
 80013d4:	20001944 	.word	0x20001944

080013d8 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 80013d8:	b480      	push	{r7}
 80013da:	b083      	sub	sp, #12
 80013dc:	af00      	add	r7, sp, #0
 80013de:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80013e0:	4b06      	ldr	r3, [pc, #24]	; (80013fc <vTaskSetTimeOutState+0x24>)
 80013e2:	681a      	ldr	r2, [r3, #0]
 80013e4:	687b      	ldr	r3, [r7, #4]
 80013e6:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80013e8:	4b05      	ldr	r3, [pc, #20]	; (8001400 <vTaskSetTimeOutState+0x28>)
 80013ea:	681a      	ldr	r2, [r3, #0]
 80013ec:	687b      	ldr	r3, [r7, #4]
 80013ee:	605a      	str	r2, [r3, #4]
}
 80013f0:	bf00      	nop
 80013f2:	370c      	adds	r7, #12
 80013f4:	46bd      	mov	sp, r7
 80013f6:	bc80      	pop	{r7}
 80013f8:	4770      	bx	lr
 80013fa:	bf00      	nop
 80013fc:	20001948 	.word	0x20001948
 8001400:	20001934 	.word	0x20001934

08001404 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 8001404:	b580      	push	{r7, lr}
 8001406:	b084      	sub	sp, #16
 8001408:	af00      	add	r7, sp, #0
 800140a:	6078      	str	r0, [r7, #4]
 800140c:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 800140e:	f7fe ff9d 	bl	800034c <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 8001412:	4b1c      	ldr	r3, [pc, #112]	; (8001484 <xTaskCheckForTimeOut+0x80>)
 8001414:	681b      	ldr	r3, [r3, #0]
 8001416:	60bb      	str	r3, [r7, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8001418:	683b      	ldr	r3, [r7, #0]
 800141a:	681b      	ldr	r3, [r3, #0]
 800141c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001420:	d102      	bne.n	8001428 <xTaskCheckForTimeOut+0x24>
			{
				xReturn = pdFALSE;
 8001422:	2300      	movs	r3, #0
 8001424:	60fb      	str	r3, [r7, #12]
 8001426:	e026      	b.n	8001476 <xTaskCheckForTimeOut+0x72>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8001428:	687b      	ldr	r3, [r7, #4]
 800142a:	681a      	ldr	r2, [r3, #0]
 800142c:	4b16      	ldr	r3, [pc, #88]	; (8001488 <xTaskCheckForTimeOut+0x84>)
 800142e:	681b      	ldr	r3, [r3, #0]
 8001430:	429a      	cmp	r2, r3
 8001432:	d007      	beq.n	8001444 <xTaskCheckForTimeOut+0x40>
 8001434:	687b      	ldr	r3, [r7, #4]
 8001436:	685a      	ldr	r2, [r3, #4]
 8001438:	68bb      	ldr	r3, [r7, #8]
 800143a:	429a      	cmp	r2, r3
 800143c:	d802      	bhi.n	8001444 <xTaskCheckForTimeOut+0x40>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 800143e:	2301      	movs	r3, #1
 8001440:	60fb      	str	r3, [r7, #12]
 8001442:	e018      	b.n	8001476 <xTaskCheckForTimeOut+0x72>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 8001444:	687b      	ldr	r3, [r7, #4]
 8001446:	685b      	ldr	r3, [r3, #4]
 8001448:	68ba      	ldr	r2, [r7, #8]
 800144a:	1ad2      	subs	r2, r2, r3
 800144c:	683b      	ldr	r3, [r7, #0]
 800144e:	681b      	ldr	r3, [r3, #0]
 8001450:	429a      	cmp	r2, r3
 8001452:	d20e      	bcs.n	8001472 <xTaskCheckForTimeOut+0x6e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 8001454:	683b      	ldr	r3, [r7, #0]
 8001456:	681a      	ldr	r2, [r3, #0]
 8001458:	687b      	ldr	r3, [r7, #4]
 800145a:	6859      	ldr	r1, [r3, #4]
 800145c:	68bb      	ldr	r3, [r7, #8]
 800145e:	1acb      	subs	r3, r1, r3
 8001460:	441a      	add	r2, r3
 8001462:	683b      	ldr	r3, [r7, #0]
 8001464:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8001466:	6878      	ldr	r0, [r7, #4]
 8001468:	f7ff ffb6 	bl	80013d8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800146c:	2300      	movs	r3, #0
 800146e:	60fb      	str	r3, [r7, #12]
 8001470:	e001      	b.n	8001476 <xTaskCheckForTimeOut+0x72>
		}
		else
		{
			xReturn = pdTRUE;
 8001472:	2301      	movs	r3, #1
 8001474:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8001476:	f7fe ff7b 	bl	8000370 <vPortExitCritical>

	return xReturn;
 800147a:	68fb      	ldr	r3, [r7, #12]
}
 800147c:	4618      	mov	r0, r3
 800147e:	3710      	adds	r7, #16
 8001480:	46bd      	mov	sp, r7
 8001482:	bd80      	pop	{r7, pc}
 8001484:	20001934 	.word	0x20001934
 8001488:	20001948 	.word	0x20001948

0800148c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 800148c:	b480      	push	{r7}
 800148e:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
 8001490:	4b03      	ldr	r3, [pc, #12]	; (80014a0 <vTaskMissedYield+0x14>)
 8001492:	2201      	movs	r2, #1
 8001494:	601a      	str	r2, [r3, #0]
}
 8001496:	bf00      	nop
 8001498:	46bd      	mov	sp, r7
 800149a:	bc80      	pop	{r7}
 800149c:	4770      	bx	lr
 800149e:	bf00      	nop
 80014a0:	20001944 	.word	0x20001944

080014a4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 80014a4:	b580      	push	{r7, lr}
 80014a6:	b082      	sub	sp, #8
 80014a8:	af00      	add	r7, sp, #0
 80014aa:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 80014ac:	f000 f894 	bl	80015d8 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80014b0:	4b03      	ldr	r3, [pc, #12]	; (80014c0 <prvIdleTask+0x1c>)
 80014b2:	681b      	ldr	r3, [r3, #0]
 80014b4:	2b01      	cmp	r3, #1
 80014b6:	d9f9      	bls.n	80014ac <prvIdleTask+0x8>
			{
				taskYIELD();
 80014b8:	f7fe ff38 	bl	800032c <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 80014bc:	e7f6      	b.n	80014ac <prvIdleTask+0x8>
 80014be:	bf00      	nop
 80014c0:	2000185c 	.word	0x2000185c

080014c4 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 80014c4:	b580      	push	{r7, lr}
 80014c6:	b086      	sub	sp, #24
 80014c8:	af00      	add	r7, sp, #0
 80014ca:	60f8      	str	r0, [r7, #12]
 80014cc:	60b9      	str	r1, [r7, #8]
 80014ce:	607a      	str	r2, [r7, #4]
 80014d0:	603b      	str	r3, [r7, #0]
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80014d2:	2300      	movs	r3, #0
 80014d4:	617b      	str	r3, [r7, #20]
 80014d6:	e012      	b.n	80014fe <prvInitialiseTCBVariables+0x3a>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80014d8:	68ba      	ldr	r2, [r7, #8]
 80014da:	697b      	ldr	r3, [r7, #20]
 80014dc:	4413      	add	r3, r2
 80014de:	7819      	ldrb	r1, [r3, #0]
 80014e0:	68fa      	ldr	r2, [r7, #12]
 80014e2:	697b      	ldr	r3, [r7, #20]
 80014e4:	4413      	add	r3, r2
 80014e6:	3334      	adds	r3, #52	; 0x34
 80014e8:	460a      	mov	r2, r1
 80014ea:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80014ec:	68ba      	ldr	r2, [r7, #8]
 80014ee:	697b      	ldr	r3, [r7, #20]
 80014f0:	4413      	add	r3, r2
 80014f2:	781b      	ldrb	r3, [r3, #0]
 80014f4:	2b00      	cmp	r3, #0
 80014f6:	d006      	beq.n	8001506 <prvInitialiseTCBVariables+0x42>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80014f8:	697b      	ldr	r3, [r7, #20]
 80014fa:	3301      	adds	r3, #1
 80014fc:	617b      	str	r3, [r7, #20]
 80014fe:	697b      	ldr	r3, [r7, #20]
 8001500:	2b0f      	cmp	r3, #15
 8001502:	d9e9      	bls.n	80014d8 <prvInitialiseTCBVariables+0x14>
 8001504:	e000      	b.n	8001508 <prvInitialiseTCBVariables+0x44>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
 8001506:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8001508:	68fb      	ldr	r3, [r7, #12]
 800150a:	2200      	movs	r2, #0
 800150c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8001510:	687b      	ldr	r3, [r7, #4]
 8001512:	2b04      	cmp	r3, #4
 8001514:	d901      	bls.n	800151a <prvInitialiseTCBVariables+0x56>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8001516:	2304      	movs	r3, #4
 8001518:	607b      	str	r3, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 800151a:	68fb      	ldr	r3, [r7, #12]
 800151c:	687a      	ldr	r2, [r7, #4]
 800151e:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8001520:	68fb      	ldr	r3, [r7, #12]
 8001522:	687a      	ldr	r2, [r7, #4]
 8001524:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8001526:	68fb      	ldr	r3, [r7, #12]
 8001528:	3304      	adds	r3, #4
 800152a:	4618      	mov	r0, r3
 800152c:	f7ff f89a 	bl	8000664 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8001530:	68fb      	ldr	r3, [r7, #12]
 8001532:	3318      	adds	r3, #24
 8001534:	4618      	mov	r0, r3
 8001536:	f7ff f895 	bl	8000664 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 800153a:	68fb      	ldr	r3, [r7, #12]
 800153c:	68fa      	ldr	r2, [r7, #12]
 800153e:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001540:	687b      	ldr	r3, [r7, #4]
 8001542:	f1c3 0205 	rsb	r2, r3, #5
 8001546:	68fb      	ldr	r3, [r7, #12]
 8001548:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 800154a:	68fb      	ldr	r3, [r7, #12]
 800154c:	68fa      	ldr	r2, [r7, #12]
 800154e:	625a      	str	r2, [r3, #36]	; 0x24
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
 8001550:	bf00      	nop
 8001552:	3718      	adds	r7, #24
 8001554:	46bd      	mov	sp, r7
 8001556:	bd80      	pop	{r7, pc}

08001558 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 8001558:	b580      	push	{r7, lr}
 800155a:	b082      	sub	sp, #8
 800155c:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800155e:	2300      	movs	r3, #0
 8001560:	607b      	str	r3, [r7, #4]
 8001562:	e00c      	b.n	800157e <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8001564:	687a      	ldr	r2, [r7, #4]
 8001566:	4613      	mov	r3, r2
 8001568:	009b      	lsls	r3, r3, #2
 800156a:	4413      	add	r3, r2
 800156c:	009b      	lsls	r3, r3, #2
 800156e:	4a12      	ldr	r2, [pc, #72]	; (80015b8 <prvInitialiseTaskLists+0x60>)
 8001570:	4413      	add	r3, r2
 8001572:	4618      	mov	r0, r3
 8001574:	f7ff f856 	bl	8000624 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8001578:	687b      	ldr	r3, [r7, #4]
 800157a:	3301      	adds	r3, #1
 800157c:	607b      	str	r3, [r7, #4]
 800157e:	687b      	ldr	r3, [r7, #4]
 8001580:	2b04      	cmp	r3, #4
 8001582:	d9ef      	bls.n	8001564 <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8001584:	480d      	ldr	r0, [pc, #52]	; (80015bc <prvInitialiseTaskLists+0x64>)
 8001586:	f7ff f84d 	bl	8000624 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800158a:	480d      	ldr	r0, [pc, #52]	; (80015c0 <prvInitialiseTaskLists+0x68>)
 800158c:	f7ff f84a 	bl	8000624 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8001590:	480c      	ldr	r0, [pc, #48]	; (80015c4 <prvInitialiseTaskLists+0x6c>)
 8001592:	f7ff f847 	bl	8000624 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8001596:	480c      	ldr	r0, [pc, #48]	; (80015c8 <prvInitialiseTaskLists+0x70>)
 8001598:	f7ff f844 	bl	8000624 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 800159c:	480b      	ldr	r0, [pc, #44]	; (80015cc <prvInitialiseTaskLists+0x74>)
 800159e:	f7ff f841 	bl	8000624 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80015a2:	4b0b      	ldr	r3, [pc, #44]	; (80015d0 <prvInitialiseTaskLists+0x78>)
 80015a4:	4a05      	ldr	r2, [pc, #20]	; (80015bc <prvInitialiseTaskLists+0x64>)
 80015a6:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80015a8:	4b0a      	ldr	r3, [pc, #40]	; (80015d4 <prvInitialiseTaskLists+0x7c>)
 80015aa:	4a05      	ldr	r2, [pc, #20]	; (80015c0 <prvInitialiseTaskLists+0x68>)
 80015ac:	601a      	str	r2, [r3, #0]
}
 80015ae:	bf00      	nop
 80015b0:	3708      	adds	r7, #8
 80015b2:	46bd      	mov	sp, r7
 80015b4:	bd80      	pop	{r7, pc}
 80015b6:	bf00      	nop
 80015b8:	2000185c 	.word	0x2000185c
 80015bc:	200018c0 	.word	0x200018c0
 80015c0:	200018d4 	.word	0x200018d4
 80015c4:	200018f0 	.word	0x200018f0
 80015c8:	20001904 	.word	0x20001904
 80015cc:	2000191c 	.word	0x2000191c
 80015d0:	200018e8 	.word	0x200018e8
 80015d4:	200018ec 	.word	0x200018ec

080015d8 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 80015d8:	b580      	push	{r7, lr}
 80015da:	b082      	sub	sp, #8
 80015dc:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 80015de:	e028      	b.n	8001632 <prvCheckTasksWaitingTermination+0x5a>
		{
			vTaskSuspendAll();
 80015e0:	f7ff fcee 	bl	8000fc0 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80015e4:	4b17      	ldr	r3, [pc, #92]	; (8001644 <prvCheckTasksWaitingTermination+0x6c>)
 80015e6:	681b      	ldr	r3, [r3, #0]
 80015e8:	2b00      	cmp	r3, #0
 80015ea:	bf0c      	ite	eq
 80015ec:	2301      	moveq	r3, #1
 80015ee:	2300      	movne	r3, #0
 80015f0:	b2db      	uxtb	r3, r3
 80015f2:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
 80015f4:	f7ff fcf2 	bl	8000fdc <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 80015f8:	687b      	ldr	r3, [r7, #4]
 80015fa:	2b00      	cmp	r3, #0
 80015fc:	d119      	bne.n	8001632 <prvCheckTasksWaitingTermination+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 80015fe:	f7fe fea5 	bl	800034c <vPortEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8001602:	4b10      	ldr	r3, [pc, #64]	; (8001644 <prvCheckTasksWaitingTermination+0x6c>)
 8001604:	68db      	ldr	r3, [r3, #12]
 8001606:	68db      	ldr	r3, [r3, #12]
 8001608:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800160a:	683b      	ldr	r3, [r7, #0]
 800160c:	3304      	adds	r3, #4
 800160e:	4618      	mov	r0, r3
 8001610:	f7ff f890 	bl	8000734 <uxListRemove>
					--uxCurrentNumberOfTasks;
 8001614:	4b0c      	ldr	r3, [pc, #48]	; (8001648 <prvCheckTasksWaitingTermination+0x70>)
 8001616:	681b      	ldr	r3, [r3, #0]
 8001618:	3b01      	subs	r3, #1
 800161a:	4a0b      	ldr	r2, [pc, #44]	; (8001648 <prvCheckTasksWaitingTermination+0x70>)
 800161c:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
 800161e:	4b0b      	ldr	r3, [pc, #44]	; (800164c <prvCheckTasksWaitingTermination+0x74>)
 8001620:	681b      	ldr	r3, [r3, #0]
 8001622:	3b01      	subs	r3, #1
 8001624:	4a09      	ldr	r2, [pc, #36]	; (800164c <prvCheckTasksWaitingTermination+0x74>)
 8001626:	6013      	str	r3, [r2, #0]
				}
				taskEXIT_CRITICAL();
 8001628:	f7fe fea2 	bl	8000370 <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 800162c:	6838      	ldr	r0, [r7, #0]
 800162e:	f000 f86d 	bl	800170c <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 8001632:	4b06      	ldr	r3, [pc, #24]	; (800164c <prvCheckTasksWaitingTermination+0x74>)
 8001634:	681b      	ldr	r3, [r3, #0]
 8001636:	2b00      	cmp	r3, #0
 8001638:	d1d2      	bne.n	80015e0 <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
 800163a:	bf00      	nop
 800163c:	3708      	adds	r7, #8
 800163e:	46bd      	mov	sp, r7
 8001640:	bd80      	pop	{r7, pc}
 8001642:	bf00      	nop
 8001644:	20001904 	.word	0x20001904
 8001648:	20001930 	.word	0x20001930
 800164c:	20001918 	.word	0x20001918

08001650 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 8001650:	b580      	push	{r7, lr}
 8001652:	b082      	sub	sp, #8
 8001654:	af00      	add	r7, sp, #0
 8001656:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8001658:	4b13      	ldr	r3, [pc, #76]	; (80016a8 <prvAddCurrentTaskToDelayedList+0x58>)
 800165a:	681b      	ldr	r3, [r3, #0]
 800165c:	687a      	ldr	r2, [r7, #4]
 800165e:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
 8001660:	4b12      	ldr	r3, [pc, #72]	; (80016ac <prvAddCurrentTaskToDelayedList+0x5c>)
 8001662:	681b      	ldr	r3, [r3, #0]
 8001664:	687a      	ldr	r2, [r7, #4]
 8001666:	429a      	cmp	r2, r3
 8001668:	d209      	bcs.n	800167e <prvAddCurrentTaskToDelayedList+0x2e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800166a:	4b11      	ldr	r3, [pc, #68]	; (80016b0 <prvAddCurrentTaskToDelayedList+0x60>)
 800166c:	681a      	ldr	r2, [r3, #0]
 800166e:	4b0e      	ldr	r3, [pc, #56]	; (80016a8 <prvAddCurrentTaskToDelayedList+0x58>)
 8001670:	681b      	ldr	r3, [r3, #0]
 8001672:	3304      	adds	r3, #4
 8001674:	4619      	mov	r1, r3
 8001676:	4610      	mov	r0, r2
 8001678:	f7ff f824 	bl	80006c4 <vListInsert>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 800167c:	e010      	b.n	80016a0 <prvAddCurrentTaskToDelayedList+0x50>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800167e:	4b0d      	ldr	r3, [pc, #52]	; (80016b4 <prvAddCurrentTaskToDelayedList+0x64>)
 8001680:	681a      	ldr	r2, [r3, #0]
 8001682:	4b09      	ldr	r3, [pc, #36]	; (80016a8 <prvAddCurrentTaskToDelayedList+0x58>)
 8001684:	681b      	ldr	r3, [r3, #0]
 8001686:	3304      	adds	r3, #4
 8001688:	4619      	mov	r1, r3
 800168a:	4610      	mov	r0, r2
 800168c:	f7ff f81a 	bl	80006c4 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8001690:	4b09      	ldr	r3, [pc, #36]	; (80016b8 <prvAddCurrentTaskToDelayedList+0x68>)
 8001692:	681b      	ldr	r3, [r3, #0]
 8001694:	687a      	ldr	r2, [r7, #4]
 8001696:	429a      	cmp	r2, r3
 8001698:	d202      	bcs.n	80016a0 <prvAddCurrentTaskToDelayedList+0x50>
		{
			xNextTaskUnblockTime = xTimeToWake;
 800169a:	4a07      	ldr	r2, [pc, #28]	; (80016b8 <prvAddCurrentTaskToDelayedList+0x68>)
 800169c:	687b      	ldr	r3, [r7, #4]
 800169e:	6013      	str	r3, [r2, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 80016a0:	bf00      	nop
 80016a2:	3708      	adds	r7, #8
 80016a4:	46bd      	mov	sp, r7
 80016a6:	bd80      	pop	{r7, pc}
 80016a8:	20001858 	.word	0x20001858
 80016ac:	20001934 	.word	0x20001934
 80016b0:	200018ec 	.word	0x200018ec
 80016b4:	200018e8 	.word	0x200018e8
 80016b8:	20000008 	.word	0x20000008

080016bc <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
 80016bc:	b580      	push	{r7, lr}
 80016be:	b084      	sub	sp, #16
 80016c0:	af00      	add	r7, sp, #0
 80016c2:	4603      	mov	r3, r0
 80016c4:	6039      	str	r1, [r7, #0]
 80016c6:	80fb      	strh	r3, [r7, #6]
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 80016c8:	2048      	movs	r0, #72	; 0x48
 80016ca:	f7fe febb 	bl	8000444 <pvPortMalloc>
 80016ce:	60f8      	str	r0, [r7, #12]

	if( pxNewTCB != NULL )
 80016d0:	68fb      	ldr	r3, [r7, #12]
 80016d2:	2b00      	cmp	r3, #0
 80016d4:	d015      	beq.n	8001702 <prvAllocateTCBAndStack+0x46>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80016d6:	683b      	ldr	r3, [r7, #0]
 80016d8:	2b00      	cmp	r3, #0
 80016da:	d106      	bne.n	80016ea <prvAllocateTCBAndStack+0x2e>
 80016dc:	88fb      	ldrh	r3, [r7, #6]
 80016de:	009b      	lsls	r3, r3, #2
 80016e0:	4618      	mov	r0, r3
 80016e2:	f7fe feaf 	bl	8000444 <pvPortMalloc>
 80016e6:	4603      	mov	r3, r0
 80016e8:	e000      	b.n	80016ec <prvAllocateTCBAndStack+0x30>
 80016ea:	683b      	ldr	r3, [r7, #0]
 80016ec:	68fa      	ldr	r2, [r7, #12]
 80016ee:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 80016f0:	68fb      	ldr	r3, [r7, #12]
 80016f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80016f4:	2b00      	cmp	r3, #0
 80016f6:	d104      	bne.n	8001702 <prvAllocateTCBAndStack+0x46>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 80016f8:	68f8      	ldr	r0, [r7, #12]
 80016fa:	f7fe ff31 	bl	8000560 <vPortFree>
			pxNewTCB = NULL;
 80016fe:	2300      	movs	r3, #0
 8001700:	60fb      	str	r3, [r7, #12]
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
 8001702:	68fb      	ldr	r3, [r7, #12]
}
 8001704:	4618      	mov	r0, r3
 8001706:	3710      	adds	r7, #16
 8001708:	46bd      	mov	sp, r7
 800170a:	bd80      	pop	{r7, pc}

0800170c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 800170c:	b580      	push	{r7, lr}
 800170e:	b082      	sub	sp, #8
 8001710:	af00      	add	r7, sp, #0
 8001712:	6078      	str	r0, [r7, #4]
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
 8001714:	687b      	ldr	r3, [r7, #4]
 8001716:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001718:	4618      	mov	r0, r3
 800171a:	f7fe ff21 	bl	8000560 <vPortFree>
		vPortFree( pxTCB );
 800171e:	6878      	ldr	r0, [r7, #4]
 8001720:	f7fe ff1e 	bl	8000560 <vPortFree>
	}
 8001724:	bf00      	nop
 8001726:	3708      	adds	r7, #8
 8001728:	46bd      	mov	sp, r7
 800172a:	bd80      	pop	{r7, pc}

0800172c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 800172c:	b480      	push	{r7}
 800172e:	b083      	sub	sp, #12
 8001730:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001732:	4b0e      	ldr	r3, [pc, #56]	; (800176c <prvResetNextTaskUnblockTime+0x40>)
 8001734:	681b      	ldr	r3, [r3, #0]
 8001736:	681b      	ldr	r3, [r3, #0]
 8001738:	2b00      	cmp	r3, #0
 800173a:	d101      	bne.n	8001740 <prvResetNextTaskUnblockTime+0x14>
 800173c:	2301      	movs	r3, #1
 800173e:	e000      	b.n	8001742 <prvResetNextTaskUnblockTime+0x16>
 8001740:	2300      	movs	r3, #0
 8001742:	2b00      	cmp	r3, #0
 8001744:	d004      	beq.n	8001750 <prvResetNextTaskUnblockTime+0x24>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8001746:	4b0a      	ldr	r3, [pc, #40]	; (8001770 <prvResetNextTaskUnblockTime+0x44>)
 8001748:	f04f 32ff 	mov.w	r2, #4294967295
 800174c:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
	}
}
 800174e:	e008      	b.n	8001762 <prvResetNextTaskUnblockTime+0x36>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001750:	4b06      	ldr	r3, [pc, #24]	; (800176c <prvResetNextTaskUnblockTime+0x40>)
 8001752:	681b      	ldr	r3, [r3, #0]
 8001754:	68db      	ldr	r3, [r3, #12]
 8001756:	68db      	ldr	r3, [r3, #12]
 8001758:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 800175a:	687b      	ldr	r3, [r7, #4]
 800175c:	685b      	ldr	r3, [r3, #4]
 800175e:	4a04      	ldr	r2, [pc, #16]	; (8001770 <prvResetNextTaskUnblockTime+0x44>)
 8001760:	6013      	str	r3, [r2, #0]
	}
}
 8001762:	bf00      	nop
 8001764:	370c      	adds	r7, #12
 8001766:	46bd      	mov	sp, r7
 8001768:	bc80      	pop	{r7}
 800176a:	4770      	bx	lr
 800176c:	200018e8 	.word	0x200018e8
 8001770:	20000008 	.word	0x20000008

08001774 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 8001774:	b480      	push	{r7}
 8001776:	b083      	sub	sp, #12
 8001778:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 800177a:	4b04      	ldr	r3, [pc, #16]	; (800178c <xTaskGetCurrentTaskHandle+0x18>)
 800177c:	681b      	ldr	r3, [r3, #0]
 800177e:	607b      	str	r3, [r7, #4]

		return xReturn;
 8001780:	687b      	ldr	r3, [r7, #4]
	}
 8001782:	4618      	mov	r0, r3
 8001784:	370c      	adds	r7, #12
 8001786:	46bd      	mov	sp, r7
 8001788:	bc80      	pop	{r7}
 800178a:	4770      	bx	lr
 800178c:	20001858 	.word	0x20001858

08001790 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 8001790:	b580      	push	{r7, lr}
 8001792:	b084      	sub	sp, #16
 8001794:	af00      	add	r7, sp, #0
 8001796:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 8001798:	687b      	ldr	r3, [r7, #4]
 800179a:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 800179c:	687b      	ldr	r3, [r7, #4]
 800179e:	2b00      	cmp	r3, #0
 80017a0:	d04a      	beq.n	8001838 <vTaskPriorityInherit+0xa8>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 80017a2:	68fb      	ldr	r3, [r7, #12]
 80017a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80017a6:	4b26      	ldr	r3, [pc, #152]	; (8001840 <vTaskPriorityInherit+0xb0>)
 80017a8:	681b      	ldr	r3, [r3, #0]
 80017aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80017ac:	429a      	cmp	r2, r3
 80017ae:	d243      	bcs.n	8001838 <vTaskPriorityInherit+0xa8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80017b0:	68fb      	ldr	r3, [r7, #12]
 80017b2:	699b      	ldr	r3, [r3, #24]
 80017b4:	2b00      	cmp	r3, #0
 80017b6:	db06      	blt.n	80017c6 <vTaskPriorityInherit+0x36>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80017b8:	4b21      	ldr	r3, [pc, #132]	; (8001840 <vTaskPriorityInherit+0xb0>)
 80017ba:	681b      	ldr	r3, [r3, #0]
 80017bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80017be:	f1c3 0205 	rsb	r2, r3, #5
 80017c2:	68fb      	ldr	r3, [r7, #12]
 80017c4:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80017c6:	68fb      	ldr	r3, [r7, #12]
 80017c8:	6959      	ldr	r1, [r3, #20]
 80017ca:	68fb      	ldr	r3, [r7, #12]
 80017cc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80017ce:	4613      	mov	r3, r2
 80017d0:	009b      	lsls	r3, r3, #2
 80017d2:	4413      	add	r3, r2
 80017d4:	009b      	lsls	r3, r3, #2
 80017d6:	4a1b      	ldr	r2, [pc, #108]	; (8001844 <vTaskPriorityInherit+0xb4>)
 80017d8:	4413      	add	r3, r2
 80017da:	4299      	cmp	r1, r3
 80017dc:	d101      	bne.n	80017e2 <vTaskPriorityInherit+0x52>
 80017de:	2301      	movs	r3, #1
 80017e0:	e000      	b.n	80017e4 <vTaskPriorityInherit+0x54>
 80017e2:	2300      	movs	r3, #0
 80017e4:	2b00      	cmp	r3, #0
 80017e6:	d022      	beq.n	800182e <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80017e8:	68fb      	ldr	r3, [r7, #12]
 80017ea:	3304      	adds	r3, #4
 80017ec:	4618      	mov	r0, r3
 80017ee:	f7fe ffa1 	bl	8000734 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80017f2:	4b13      	ldr	r3, [pc, #76]	; (8001840 <vTaskPriorityInherit+0xb0>)
 80017f4:	681b      	ldr	r3, [r3, #0]
 80017f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80017f8:	68fb      	ldr	r3, [r7, #12]
 80017fa:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80017fc:	68fb      	ldr	r3, [r7, #12]
 80017fe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001800:	4b11      	ldr	r3, [pc, #68]	; (8001848 <vTaskPriorityInherit+0xb8>)
 8001802:	681b      	ldr	r3, [r3, #0]
 8001804:	429a      	cmp	r2, r3
 8001806:	d903      	bls.n	8001810 <vTaskPriorityInherit+0x80>
 8001808:	68fb      	ldr	r3, [r7, #12]
 800180a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800180c:	4a0e      	ldr	r2, [pc, #56]	; (8001848 <vTaskPriorityInherit+0xb8>)
 800180e:	6013      	str	r3, [r2, #0]
 8001810:	68fb      	ldr	r3, [r7, #12]
 8001812:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001814:	4613      	mov	r3, r2
 8001816:	009b      	lsls	r3, r3, #2
 8001818:	4413      	add	r3, r2
 800181a:	009b      	lsls	r3, r3, #2
 800181c:	4a09      	ldr	r2, [pc, #36]	; (8001844 <vTaskPriorityInherit+0xb4>)
 800181e:	441a      	add	r2, r3
 8001820:	68fb      	ldr	r3, [r7, #12]
 8001822:	3304      	adds	r3, #4
 8001824:	4619      	mov	r1, r3
 8001826:	4610      	mov	r0, r2
 8001828:	f7fe ff28 	bl	800067c <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 800182c:	e004      	b.n	8001838 <vTaskPriorityInherit+0xa8>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800182e:	4b04      	ldr	r3, [pc, #16]	; (8001840 <vTaskPriorityInherit+0xb0>)
 8001830:	681b      	ldr	r3, [r3, #0]
 8001832:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001834:	68fb      	ldr	r3, [r7, #12]
 8001836:	62da      	str	r2, [r3, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8001838:	bf00      	nop
 800183a:	3710      	adds	r7, #16
 800183c:	46bd      	mov	sp, r7
 800183e:	bd80      	pop	{r7, pc}
 8001840:	20001858 	.word	0x20001858
 8001844:	2000185c 	.word	0x2000185c
 8001848:	20001938 	.word	0x20001938

0800184c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 800184c:	b580      	push	{r7, lr}
 800184e:	b084      	sub	sp, #16
 8001850:	af00      	add	r7, sp, #0
 8001852:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 8001854:	687b      	ldr	r3, [r7, #4]
 8001856:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
 8001858:	687b      	ldr	r3, [r7, #4]
 800185a:	2b00      	cmp	r3, #0
 800185c:	d030      	beq.n	80018c0 <vTaskPriorityDisinherit+0x74>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800185e:	68fb      	ldr	r3, [r7, #12]
 8001860:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001862:	68fb      	ldr	r3, [r7, #12]
 8001864:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001866:	429a      	cmp	r2, r3
 8001868:	d02a      	beq.n	80018c0 <vTaskPriorityDisinherit+0x74>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 800186a:	68fb      	ldr	r3, [r7, #12]
 800186c:	3304      	adds	r3, #4
 800186e:	4618      	mov	r0, r3
 8001870:	f7fe ff60 	bl	8000734 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8001874:	68fb      	ldr	r3, [r7, #12]
 8001876:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001878:	68fb      	ldr	r3, [r7, #12]
 800187a:	62da      	str	r2, [r3, #44]	; 0x2c

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800187c:	68fb      	ldr	r3, [r7, #12]
 800187e:	699b      	ldr	r3, [r3, #24]
 8001880:	2b00      	cmp	r3, #0
 8001882:	db05      	blt.n	8001890 <vTaskPriorityDisinherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001884:	68fb      	ldr	r3, [r7, #12]
 8001886:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001888:	f1c3 0205 	rsb	r2, r3, #5
 800188c:	68fb      	ldr	r3, [r7, #12]
 800188e:	619a      	str	r2, [r3, #24]
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddTaskToReadyList( pxTCB );
 8001890:	68fb      	ldr	r3, [r7, #12]
 8001892:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001894:	4b0c      	ldr	r3, [pc, #48]	; (80018c8 <vTaskPriorityDisinherit+0x7c>)
 8001896:	681b      	ldr	r3, [r3, #0]
 8001898:	429a      	cmp	r2, r3
 800189a:	d903      	bls.n	80018a4 <vTaskPriorityDisinherit+0x58>
 800189c:	68fb      	ldr	r3, [r7, #12]
 800189e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80018a0:	4a09      	ldr	r2, [pc, #36]	; (80018c8 <vTaskPriorityDisinherit+0x7c>)
 80018a2:	6013      	str	r3, [r2, #0]
 80018a4:	68fb      	ldr	r3, [r7, #12]
 80018a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80018a8:	4613      	mov	r3, r2
 80018aa:	009b      	lsls	r3, r3, #2
 80018ac:	4413      	add	r3, r2
 80018ae:	009b      	lsls	r3, r3, #2
 80018b0:	4a06      	ldr	r2, [pc, #24]	; (80018cc <vTaskPriorityDisinherit+0x80>)
 80018b2:	441a      	add	r2, r3
 80018b4:	68fb      	ldr	r3, [r7, #12]
 80018b6:	3304      	adds	r3, #4
 80018b8:	4619      	mov	r1, r3
 80018ba:	4610      	mov	r0, r2
 80018bc:	f7fe fede 	bl	800067c <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80018c0:	bf00      	nop
 80018c2:	3710      	adds	r7, #16
 80018c4:	46bd      	mov	sp, r7
 80018c6:	bd80      	pop	{r7, pc}
 80018c8:	20001938 	.word	0x20001938
 80018cc:	2000185c 	.word	0x2000185c

080018d0 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80018d0:	b480      	push	{r7}
 80018d2:	b089      	sub	sp, #36	; 0x24
 80018d4:	af00      	add	r7, sp, #0
 80018d6:	6078      	str	r0, [r7, #4]
 80018d8:	6039      	str	r1, [r7, #0]
  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
 80018da:	2300      	movs	r3, #0
 80018dc:	61fb      	str	r3, [r7, #28]
 80018de:	2300      	movs	r3, #0
 80018e0:	613b      	str	r3, [r7, #16]
 80018e2:	2300      	movs	r3, #0
 80018e4:	61bb      	str	r3, [r7, #24]
 80018e6:	2300      	movs	r3, #0
 80018e8:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg = 0x00, pinmask = 0x00;
 80018ea:	2300      	movs	r3, #0
 80018ec:	617b      	str	r3, [r7, #20]
 80018ee:	2300      	movs	r3, #0
 80018f0:	60bb      	str	r3, [r7, #8]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 80018f2:	683b      	ldr	r3, [r7, #0]
 80018f4:	78db      	ldrb	r3, [r3, #3]
 80018f6:	f003 030f 	and.w	r3, r3, #15
 80018fa:	61fb      	str	r3, [r7, #28]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 80018fc:	683b      	ldr	r3, [r7, #0]
 80018fe:	78db      	ldrb	r3, [r3, #3]
 8001900:	f003 0310 	and.w	r3, r3, #16
 8001904:	2b00      	cmp	r3, #0
 8001906:	d005      	beq.n	8001914 <GPIO_Init+0x44>
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8001908:	683b      	ldr	r3, [r7, #0]
 800190a:	789b      	ldrb	r3, [r3, #2]
 800190c:	461a      	mov	r2, r3
 800190e:	69fb      	ldr	r3, [r7, #28]
 8001910:	4313      	orrs	r3, r2
 8001912:	61fb      	str	r3, [r7, #28]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8001914:	683b      	ldr	r3, [r7, #0]
 8001916:	881b      	ldrh	r3, [r3, #0]
 8001918:	b2db      	uxtb	r3, r3
 800191a:	2b00      	cmp	r3, #0
 800191c:	d044      	beq.n	80019a8 <GPIO_Init+0xd8>
  {
    tmpreg = GPIOx->CRL;
 800191e:	687b      	ldr	r3, [r7, #4]
 8001920:	681b      	ldr	r3, [r3, #0]
 8001922:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001924:	2300      	movs	r3, #0
 8001926:	61bb      	str	r3, [r7, #24]
 8001928:	e038      	b.n	800199c <GPIO_Init+0xcc>
    {
      pos = ((uint32_t)0x01) << pinpos;
 800192a:	2201      	movs	r2, #1
 800192c:	69bb      	ldr	r3, [r7, #24]
 800192e:	fa02 f303 	lsl.w	r3, r2, r3
 8001932:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001934:	683b      	ldr	r3, [r7, #0]
 8001936:	881b      	ldrh	r3, [r3, #0]
 8001938:	461a      	mov	r2, r3
 800193a:	68fb      	ldr	r3, [r7, #12]
 800193c:	4013      	ands	r3, r2
 800193e:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
 8001940:	693a      	ldr	r2, [r7, #16]
 8001942:	68fb      	ldr	r3, [r7, #12]
 8001944:	429a      	cmp	r2, r3
 8001946:	d126      	bne.n	8001996 <GPIO_Init+0xc6>
      {
        pos = pinpos << 2;
 8001948:	69bb      	ldr	r3, [r7, #24]
 800194a:	009b      	lsls	r3, r3, #2
 800194c:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 800194e:	220f      	movs	r2, #15
 8001950:	68fb      	ldr	r3, [r7, #12]
 8001952:	fa02 f303 	lsl.w	r3, r2, r3
 8001956:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
 8001958:	68bb      	ldr	r3, [r7, #8]
 800195a:	43db      	mvns	r3, r3
 800195c:	697a      	ldr	r2, [r7, #20]
 800195e:	4013      	ands	r3, r2
 8001960:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001962:	69fa      	ldr	r2, [r7, #28]
 8001964:	68fb      	ldr	r3, [r7, #12]
 8001966:	fa02 f303 	lsl.w	r3, r2, r3
 800196a:	697a      	ldr	r2, [r7, #20]
 800196c:	4313      	orrs	r3, r2
 800196e:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8001970:	683b      	ldr	r3, [r7, #0]
 8001972:	78db      	ldrb	r3, [r3, #3]
 8001974:	2b28      	cmp	r3, #40	; 0x28
 8001976:	d105      	bne.n	8001984 <GPIO_Init+0xb4>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8001978:	2201      	movs	r2, #1
 800197a:	69bb      	ldr	r3, [r7, #24]
 800197c:	409a      	lsls	r2, r3
 800197e:	687b      	ldr	r3, [r7, #4]
 8001980:	615a      	str	r2, [r3, #20]
 8001982:	e008      	b.n	8001996 <GPIO_Init+0xc6>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8001984:	683b      	ldr	r3, [r7, #0]
 8001986:	78db      	ldrb	r3, [r3, #3]
 8001988:	2b48      	cmp	r3, #72	; 0x48
 800198a:	d104      	bne.n	8001996 <GPIO_Init+0xc6>
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 800198c:	2201      	movs	r2, #1
 800198e:	69bb      	ldr	r3, [r7, #24]
 8001990:	409a      	lsls	r2, r3
 8001992:	687b      	ldr	r3, [r7, #4]
 8001994:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001996:	69bb      	ldr	r3, [r7, #24]
 8001998:	3301      	adds	r3, #1
 800199a:	61bb      	str	r3, [r7, #24]
 800199c:	69bb      	ldr	r3, [r7, #24]
 800199e:	2b07      	cmp	r3, #7
 80019a0:	d9c3      	bls.n	800192a <GPIO_Init+0x5a>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 80019a2:	687b      	ldr	r3, [r7, #4]
 80019a4:	697a      	ldr	r2, [r7, #20]
 80019a6:	601a      	str	r2, [r3, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 80019a8:	683b      	ldr	r3, [r7, #0]
 80019aa:	881b      	ldrh	r3, [r3, #0]
 80019ac:	2bff      	cmp	r3, #255	; 0xff
 80019ae:	d946      	bls.n	8001a3e <GPIO_Init+0x16e>
  {
    tmpreg = GPIOx->CRH;
 80019b0:	687b      	ldr	r3, [r7, #4]
 80019b2:	685b      	ldr	r3, [r3, #4]
 80019b4:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80019b6:	2300      	movs	r3, #0
 80019b8:	61bb      	str	r3, [r7, #24]
 80019ba:	e03a      	b.n	8001a32 <GPIO_Init+0x162>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80019bc:	69bb      	ldr	r3, [r7, #24]
 80019be:	3308      	adds	r3, #8
 80019c0:	2201      	movs	r2, #1
 80019c2:	fa02 f303 	lsl.w	r3, r2, r3
 80019c6:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 80019c8:	683b      	ldr	r3, [r7, #0]
 80019ca:	881b      	ldrh	r3, [r3, #0]
 80019cc:	461a      	mov	r2, r3
 80019ce:	68fb      	ldr	r3, [r7, #12]
 80019d0:	4013      	ands	r3, r2
 80019d2:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
 80019d4:	693a      	ldr	r2, [r7, #16]
 80019d6:	68fb      	ldr	r3, [r7, #12]
 80019d8:	429a      	cmp	r2, r3
 80019da:	d127      	bne.n	8001a2c <GPIO_Init+0x15c>
      {
        pos = pinpos << 2;
 80019dc:	69bb      	ldr	r3, [r7, #24]
 80019de:	009b      	lsls	r3, r3, #2
 80019e0:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 80019e2:	220f      	movs	r2, #15
 80019e4:	68fb      	ldr	r3, [r7, #12]
 80019e6:	fa02 f303 	lsl.w	r3, r2, r3
 80019ea:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
 80019ec:	68bb      	ldr	r3, [r7, #8]
 80019ee:	43db      	mvns	r3, r3
 80019f0:	697a      	ldr	r2, [r7, #20]
 80019f2:	4013      	ands	r3, r2
 80019f4:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80019f6:	69fa      	ldr	r2, [r7, #28]
 80019f8:	68fb      	ldr	r3, [r7, #12]
 80019fa:	fa02 f303 	lsl.w	r3, r2, r3
 80019fe:	697a      	ldr	r2, [r7, #20]
 8001a00:	4313      	orrs	r3, r2
 8001a02:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8001a04:	683b      	ldr	r3, [r7, #0]
 8001a06:	78db      	ldrb	r3, [r3, #3]
 8001a08:	2b28      	cmp	r3, #40	; 0x28
 8001a0a:	d105      	bne.n	8001a18 <GPIO_Init+0x148>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001a0c:	69bb      	ldr	r3, [r7, #24]
 8001a0e:	3308      	adds	r3, #8
 8001a10:	2201      	movs	r2, #1
 8001a12:	409a      	lsls	r2, r3
 8001a14:	687b      	ldr	r3, [r7, #4]
 8001a16:	615a      	str	r2, [r3, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8001a18:	683b      	ldr	r3, [r7, #0]
 8001a1a:	78db      	ldrb	r3, [r3, #3]
 8001a1c:	2b48      	cmp	r3, #72	; 0x48
 8001a1e:	d105      	bne.n	8001a2c <GPIO_Init+0x15c>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001a20:	69bb      	ldr	r3, [r7, #24]
 8001a22:	3308      	adds	r3, #8
 8001a24:	2201      	movs	r2, #1
 8001a26:	409a      	lsls	r2, r3
 8001a28:	687b      	ldr	r3, [r7, #4]
 8001a2a:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001a2c:	69bb      	ldr	r3, [r7, #24]
 8001a2e:	3301      	adds	r3, #1
 8001a30:	61bb      	str	r3, [r7, #24]
 8001a32:	69bb      	ldr	r3, [r7, #24]
 8001a34:	2b07      	cmp	r3, #7
 8001a36:	d9c1      	bls.n	80019bc <GPIO_Init+0xec>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8001a38:	687b      	ldr	r3, [r7, #4]
 8001a3a:	697a      	ldr	r2, [r7, #20]
 8001a3c:	605a      	str	r2, [r3, #4]
  }
}
 8001a3e:	bf00      	nop
 8001a40:	3724      	adds	r7, #36	; 0x24
 8001a42:	46bd      	mov	sp, r7
 8001a44:	bc80      	pop	{r7}
 8001a46:	4770      	bx	lr

08001a48 <GPIO_WriteBit>:
  *     @arg Bit_RESET: to clear the port pin
  *     @arg Bit_SET: to set the port pin
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 8001a48:	b480      	push	{r7}
 8001a4a:	b083      	sub	sp, #12
 8001a4c:	af00      	add	r7, sp, #0
 8001a4e:	6078      	str	r0, [r7, #4]
 8001a50:	460b      	mov	r3, r1
 8001a52:	807b      	strh	r3, [r7, #2]
 8001a54:	4613      	mov	r3, r2
 8001a56:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 8001a58:	787b      	ldrb	r3, [r7, #1]
 8001a5a:	2b00      	cmp	r3, #0
 8001a5c:	d003      	beq.n	8001a66 <GPIO_WriteBit+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8001a5e:	887a      	ldrh	r2, [r7, #2]
 8001a60:	687b      	ldr	r3, [r7, #4]
 8001a62:	611a      	str	r2, [r3, #16]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
  }
}
 8001a64:	e002      	b.n	8001a6c <GPIO_WriteBit+0x24>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 8001a66:	887a      	ldrh	r2, [r7, #2]
 8001a68:	687b      	ldr	r3, [r7, #4]
 8001a6a:	615a      	str	r2, [r3, #20]
  }
}
 8001a6c:	bf00      	nop
 8001a6e:	370c      	adds	r7, #12
 8001a70:	46bd      	mov	sp, r7
 8001a72:	bc80      	pop	{r7}
 8001a74:	4770      	bx	lr
 8001a76:	bf00      	nop

08001a78 <RCC_GetClocksFreq>:
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8001a78:	b480      	push	{r7}
 8001a7a:	b087      	sub	sp, #28
 8001a7c:	af00      	add	r7, sp, #0
 8001a7e:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
 8001a80:	2300      	movs	r3, #0
 8001a82:	617b      	str	r3, [r7, #20]
 8001a84:	2300      	movs	r3, #0
 8001a86:	613b      	str	r3, [r7, #16]
 8001a88:	2300      	movs	r3, #0
 8001a8a:	60fb      	str	r3, [r7, #12]
 8001a8c:	2300      	movs	r3, #0
 8001a8e:	60bb      	str	r3, [r7, #8]
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8001a90:	4b4c      	ldr	r3, [pc, #304]	; (8001bc4 <RCC_GetClocksFreq+0x14c>)
 8001a92:	685b      	ldr	r3, [r3, #4]
 8001a94:	f003 030c 	and.w	r3, r3, #12
 8001a98:	617b      	str	r3, [r7, #20]
  
  switch (tmp)
 8001a9a:	697b      	ldr	r3, [r7, #20]
 8001a9c:	2b04      	cmp	r3, #4
 8001a9e:	d007      	beq.n	8001ab0 <RCC_GetClocksFreq+0x38>
 8001aa0:	2b08      	cmp	r3, #8
 8001aa2:	d009      	beq.n	8001ab8 <RCC_GetClocksFreq+0x40>
 8001aa4:	2b00      	cmp	r3, #0
 8001aa6:	d133      	bne.n	8001b10 <RCC_GetClocksFreq+0x98>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8001aa8:	687b      	ldr	r3, [r7, #4]
 8001aaa:	4a47      	ldr	r2, [pc, #284]	; (8001bc8 <RCC_GetClocksFreq+0x150>)
 8001aac:	601a      	str	r2, [r3, #0]
      break;
 8001aae:	e033      	b.n	8001b18 <RCC_GetClocksFreq+0xa0>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8001ab0:	687b      	ldr	r3, [r7, #4]
 8001ab2:	4a45      	ldr	r2, [pc, #276]	; (8001bc8 <RCC_GetClocksFreq+0x150>)
 8001ab4:	601a      	str	r2, [r3, #0]
      break;
 8001ab6:	e02f      	b.n	8001b18 <RCC_GetClocksFreq+0xa0>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 8001ab8:	4b42      	ldr	r3, [pc, #264]	; (8001bc4 <RCC_GetClocksFreq+0x14c>)
 8001aba:	685b      	ldr	r3, [r3, #4]
 8001abc:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8001ac0:	613b      	str	r3, [r7, #16]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8001ac2:	4b40      	ldr	r3, [pc, #256]	; (8001bc4 <RCC_GetClocksFreq+0x14c>)
 8001ac4:	685b      	ldr	r3, [r3, #4]
 8001ac6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001aca:	60fb      	str	r3, [r7, #12]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8001acc:	693b      	ldr	r3, [r7, #16]
 8001ace:	0c9b      	lsrs	r3, r3, #18
 8001ad0:	3302      	adds	r3, #2
 8001ad2:	613b      	str	r3, [r7, #16]
      
      if (pllsource == 0x00)
 8001ad4:	68fb      	ldr	r3, [r7, #12]
 8001ad6:	2b00      	cmp	r3, #0
 8001ad8:	d106      	bne.n	8001ae8 <RCC_GetClocksFreq+0x70>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
 8001ada:	693b      	ldr	r3, [r7, #16]
 8001adc:	4a3b      	ldr	r2, [pc, #236]	; (8001bcc <RCC_GetClocksFreq+0x154>)
 8001ade:	fb02 f203 	mul.w	r2, r2, r3
 8001ae2:	687b      	ldr	r3, [r7, #4]
 8001ae4:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 8001ae6:	e017      	b.n	8001b18 <RCC_GetClocksFreq+0xa0>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 8001ae8:	4b36      	ldr	r3, [pc, #216]	; (8001bc4 <RCC_GetClocksFreq+0x14c>)
 8001aea:	685b      	ldr	r3, [r3, #4]
 8001aec:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001af0:	2b00      	cmp	r3, #0
 8001af2:	d006      	beq.n	8001b02 <RCC_GetClocksFreq+0x8a>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
 8001af4:	693b      	ldr	r3, [r7, #16]
 8001af6:	4a35      	ldr	r2, [pc, #212]	; (8001bcc <RCC_GetClocksFreq+0x154>)
 8001af8:	fb02 f203 	mul.w	r2, r2, r3
 8001afc:	687b      	ldr	r3, [r7, #4]
 8001afe:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 8001b00:	e00a      	b.n	8001b18 <RCC_GetClocksFreq+0xa0>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 8001b02:	693b      	ldr	r3, [r7, #16]
 8001b04:	4a30      	ldr	r2, [pc, #192]	; (8001bc8 <RCC_GetClocksFreq+0x150>)
 8001b06:	fb02 f203 	mul.w	r2, r2, r3
 8001b0a:	687b      	ldr	r3, [r7, #4]
 8001b0c:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 8001b0e:	e003      	b.n	8001b18 <RCC_GetClocksFreq+0xa0>

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8001b10:	687b      	ldr	r3, [r7, #4]
 8001b12:	4a2d      	ldr	r2, [pc, #180]	; (8001bc8 <RCC_GetClocksFreq+0x150>)
 8001b14:	601a      	str	r2, [r3, #0]
      break;
 8001b16:	bf00      	nop
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8001b18:	4b2a      	ldr	r3, [pc, #168]	; (8001bc4 <RCC_GetClocksFreq+0x14c>)
 8001b1a:	685b      	ldr	r3, [r3, #4]
 8001b1c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001b20:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 4;
 8001b22:	697b      	ldr	r3, [r7, #20]
 8001b24:	091b      	lsrs	r3, r3, #4
 8001b26:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 8001b28:	4a29      	ldr	r2, [pc, #164]	; (8001bd0 <RCC_GetClocksFreq+0x158>)
 8001b2a:	697b      	ldr	r3, [r7, #20]
 8001b2c:	4413      	add	r3, r2
 8001b2e:	781b      	ldrb	r3, [r3, #0]
 8001b30:	b2db      	uxtb	r3, r3
 8001b32:	60bb      	str	r3, [r7, #8]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8001b34:	687b      	ldr	r3, [r7, #4]
 8001b36:	681a      	ldr	r2, [r3, #0]
 8001b38:	68bb      	ldr	r3, [r7, #8]
 8001b3a:	40da      	lsrs	r2, r3
 8001b3c:	687b      	ldr	r3, [r7, #4]
 8001b3e:	605a      	str	r2, [r3, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8001b40:	4b20      	ldr	r3, [pc, #128]	; (8001bc4 <RCC_GetClocksFreq+0x14c>)
 8001b42:	685b      	ldr	r3, [r3, #4]
 8001b44:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001b48:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 8;
 8001b4a:	697b      	ldr	r3, [r7, #20]
 8001b4c:	0a1b      	lsrs	r3, r3, #8
 8001b4e:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 8001b50:	4a1f      	ldr	r2, [pc, #124]	; (8001bd0 <RCC_GetClocksFreq+0x158>)
 8001b52:	697b      	ldr	r3, [r7, #20]
 8001b54:	4413      	add	r3, r2
 8001b56:	781b      	ldrb	r3, [r3, #0]
 8001b58:	b2db      	uxtb	r3, r3
 8001b5a:	60bb      	str	r3, [r7, #8]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8001b5c:	687b      	ldr	r3, [r7, #4]
 8001b5e:	685a      	ldr	r2, [r3, #4]
 8001b60:	68bb      	ldr	r3, [r7, #8]
 8001b62:	40da      	lsrs	r2, r3
 8001b64:	687b      	ldr	r3, [r7, #4]
 8001b66:	609a      	str	r2, [r3, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8001b68:	4b16      	ldr	r3, [pc, #88]	; (8001bc4 <RCC_GetClocksFreq+0x14c>)
 8001b6a:	685b      	ldr	r3, [r3, #4]
 8001b6c:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 8001b70:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 11;
 8001b72:	697b      	ldr	r3, [r7, #20]
 8001b74:	0adb      	lsrs	r3, r3, #11
 8001b76:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 8001b78:	4a15      	ldr	r2, [pc, #84]	; (8001bd0 <RCC_GetClocksFreq+0x158>)
 8001b7a:	697b      	ldr	r3, [r7, #20]
 8001b7c:	4413      	add	r3, r2
 8001b7e:	781b      	ldrb	r3, [r3, #0]
 8001b80:	b2db      	uxtb	r3, r3
 8001b82:	60bb      	str	r3, [r7, #8]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8001b84:	687b      	ldr	r3, [r7, #4]
 8001b86:	685a      	ldr	r2, [r3, #4]
 8001b88:	68bb      	ldr	r3, [r7, #8]
 8001b8a:	40da      	lsrs	r2, r3
 8001b8c:	687b      	ldr	r3, [r7, #4]
 8001b8e:	60da      	str	r2, [r3, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8001b90:	4b0c      	ldr	r3, [pc, #48]	; (8001bc4 <RCC_GetClocksFreq+0x14c>)
 8001b92:	685b      	ldr	r3, [r3, #4]
 8001b94:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8001b98:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 14;
 8001b9a:	697b      	ldr	r3, [r7, #20]
 8001b9c:	0b9b      	lsrs	r3, r3, #14
 8001b9e:	617b      	str	r3, [r7, #20]
  presc = ADCPrescTable[tmp];
 8001ba0:	4a0c      	ldr	r2, [pc, #48]	; (8001bd4 <RCC_GetClocksFreq+0x15c>)
 8001ba2:	697b      	ldr	r3, [r7, #20]
 8001ba4:	4413      	add	r3, r2
 8001ba6:	781b      	ldrb	r3, [r3, #0]
 8001ba8:	b2db      	uxtb	r3, r3
 8001baa:	60bb      	str	r3, [r7, #8]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8001bac:	687b      	ldr	r3, [r7, #4]
 8001bae:	68da      	ldr	r2, [r3, #12]
 8001bb0:	68bb      	ldr	r3, [r7, #8]
 8001bb2:	fbb2 f2f3 	udiv	r2, r2, r3
 8001bb6:	687b      	ldr	r3, [r7, #4]
 8001bb8:	611a      	str	r2, [r3, #16]
}
 8001bba:	bf00      	nop
 8001bbc:	371c      	adds	r7, #28
 8001bbe:	46bd      	mov	sp, r7
 8001bc0:	bc80      	pop	{r7}
 8001bc2:	4770      	bx	lr
 8001bc4:	40021000 	.word	0x40021000
 8001bc8:	007a1200 	.word	0x007a1200
 8001bcc:	003d0900 	.word	0x003d0900
 8001bd0:	2000000c 	.word	0x2000000c
 8001bd4:	2000001c 	.word	0x2000001c

08001bd8 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8001bd8:	b480      	push	{r7}
 8001bda:	b083      	sub	sp, #12
 8001bdc:	af00      	add	r7, sp, #0
 8001bde:	6078      	str	r0, [r7, #4]
 8001be0:	460b      	mov	r3, r1
 8001be2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001be4:	78fb      	ldrb	r3, [r7, #3]
 8001be6:	2b00      	cmp	r3, #0
 8001be8:	d006      	beq.n	8001bf8 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8001bea:	4909      	ldr	r1, [pc, #36]	; (8001c10 <RCC_APB2PeriphClockCmd+0x38>)
 8001bec:	4b08      	ldr	r3, [pc, #32]	; (8001c10 <RCC_APB2PeriphClockCmd+0x38>)
 8001bee:	699a      	ldr	r2, [r3, #24]
 8001bf0:	687b      	ldr	r3, [r7, #4]
 8001bf2:	4313      	orrs	r3, r2
 8001bf4:	618b      	str	r3, [r1, #24]
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 8001bf6:	e006      	b.n	8001c06 <RCC_APB2PeriphClockCmd+0x2e>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8001bf8:	4905      	ldr	r1, [pc, #20]	; (8001c10 <RCC_APB2PeriphClockCmd+0x38>)
 8001bfa:	4b05      	ldr	r3, [pc, #20]	; (8001c10 <RCC_APB2PeriphClockCmd+0x38>)
 8001bfc:	699a      	ldr	r2, [r3, #24]
 8001bfe:	687b      	ldr	r3, [r7, #4]
 8001c00:	43db      	mvns	r3, r3
 8001c02:	4013      	ands	r3, r2
 8001c04:	618b      	str	r3, [r1, #24]
  }
}
 8001c06:	bf00      	nop
 8001c08:	370c      	adds	r7, #12
 8001c0a:	46bd      	mov	sp, r7
 8001c0c:	bc80      	pop	{r7}
 8001c0e:	4770      	bx	lr
 8001c10:	40021000 	.word	0x40021000

08001c14 <USART_Init>:
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8001c14:	b580      	push	{r7, lr}
 8001c16:	b08c      	sub	sp, #48	; 0x30
 8001c18:	af00      	add	r7, sp, #0
 8001c1a:	6078      	str	r0, [r7, #4]
 8001c1c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 8001c1e:	2300      	movs	r3, #0
 8001c20:	62fb      	str	r3, [r7, #44]	; 0x2c
 8001c22:	2300      	movs	r3, #0
 8001c24:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t integerdivider = 0x00;
 8001c26:	2300      	movs	r3, #0
 8001c28:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t fractionaldivider = 0x00;
 8001c2a:	2300      	movs	r3, #0
 8001c2c:	623b      	str	r3, [r7, #32]
  uint32_t usartxbase = 0;
 8001c2e:	2300      	movs	r3, #0
 8001c30:	61fb      	str	r3, [r7, #28]
  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }

  usartxbase = (uint32_t)USARTx;
 8001c32:	687b      	ldr	r3, [r7, #4]
 8001c34:	61fb      	str	r3, [r7, #28]

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8001c36:	687b      	ldr	r3, [r7, #4]
 8001c38:	8a1b      	ldrh	r3, [r3, #16]
 8001c3a:	b29b      	uxth	r3, r3
 8001c3c:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 8001c3e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001c40:	f64c 73ff 	movw	r3, #53247	; 0xcfff
 8001c44:	4013      	ands	r3, r2
 8001c46:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8001c48:	683b      	ldr	r3, [r7, #0]
 8001c4a:	88db      	ldrh	r3, [r3, #6]
 8001c4c:	461a      	mov	r2, r3
 8001c4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c50:	4313      	orrs	r3, r2
 8001c52:	62fb      	str	r3, [r7, #44]	; 0x2c
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8001c54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c56:	b29a      	uxth	r2, r3
 8001c58:	687b      	ldr	r3, [r7, #4]
 8001c5a:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8001c5c:	687b      	ldr	r3, [r7, #4]
 8001c5e:	899b      	ldrh	r3, [r3, #12]
 8001c60:	b29b      	uxth	r3, r3
 8001c62:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8001c64:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001c66:	f64e 13f3 	movw	r3, #59891	; 0xe9f3
 8001c6a:	4013      	ands	r3, r2
 8001c6c:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8001c6e:	683b      	ldr	r3, [r7, #0]
 8001c70:	889a      	ldrh	r2, [r3, #4]
 8001c72:	683b      	ldr	r3, [r7, #0]
 8001c74:	891b      	ldrh	r3, [r3, #8]
 8001c76:	4313      	orrs	r3, r2
 8001c78:	b29a      	uxth	r2, r3
            USART_InitStruct->USART_Mode;
 8001c7a:	683b      	ldr	r3, [r7, #0]
 8001c7c:	895b      	ldrh	r3, [r3, #10]
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8001c7e:	4313      	orrs	r3, r2
 8001c80:	b29b      	uxth	r3, r3
 8001c82:	461a      	mov	r2, r3
 8001c84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c86:	4313      	orrs	r3, r2
 8001c88:	62fb      	str	r3, [r7, #44]	; 0x2c
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8001c8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c8c:	b29a      	uxth	r2, r3
 8001c8e:	687b      	ldr	r3, [r7, #4]
 8001c90:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8001c92:	687b      	ldr	r3, [r7, #4]
 8001c94:	8a9b      	ldrh	r3, [r3, #20]
 8001c96:	b29b      	uxth	r3, r3
 8001c98:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 8001c9a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001c9c:	f64f 43ff 	movw	r3, #64767	; 0xfcff
 8001ca0:	4013      	ands	r3, r2
 8001ca2:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8001ca4:	683b      	ldr	r3, [r7, #0]
 8001ca6:	899b      	ldrh	r3, [r3, #12]
 8001ca8:	461a      	mov	r2, r3
 8001caa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001cac:	4313      	orrs	r3, r2
 8001cae:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8001cb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001cb2:	b29a      	uxth	r2, r3
 8001cb4:	687b      	ldr	r3, [r7, #4]
 8001cb6:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8001cb8:	f107 0308 	add.w	r3, r7, #8
 8001cbc:	4618      	mov	r0, r3
 8001cbe:	f7ff fedb 	bl	8001a78 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
 8001cc2:	69fb      	ldr	r3, [r7, #28]
 8001cc4:	4a2e      	ldr	r2, [pc, #184]	; (8001d80 <USART_Init+0x16c>)
 8001cc6:	4293      	cmp	r3, r2
 8001cc8:	d102      	bne.n	8001cd0 <USART_Init+0xbc>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8001cca:	697b      	ldr	r3, [r7, #20]
 8001ccc:	62bb      	str	r3, [r7, #40]	; 0x28
 8001cce:	e001      	b.n	8001cd4 <USART_Init+0xc0>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8001cd0:	693b      	ldr	r3, [r7, #16]
 8001cd2:	62bb      	str	r3, [r7, #40]	; 0x28
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8001cd4:	687b      	ldr	r3, [r7, #4]
 8001cd6:	899b      	ldrh	r3, [r3, #12]
 8001cd8:	b29b      	uxth	r3, r3
 8001cda:	b21b      	sxth	r3, r3
 8001cdc:	2b00      	cmp	r3, #0
 8001cde:	da0c      	bge.n	8001cfa <USART_Init+0xe6>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8001ce0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001ce2:	4613      	mov	r3, r2
 8001ce4:	009b      	lsls	r3, r3, #2
 8001ce6:	4413      	add	r3, r2
 8001ce8:	009a      	lsls	r2, r3, #2
 8001cea:	441a      	add	r2, r3
 8001cec:	683b      	ldr	r3, [r7, #0]
 8001cee:	681b      	ldr	r3, [r3, #0]
 8001cf0:	005b      	lsls	r3, r3, #1
 8001cf2:	fbb2 f3f3 	udiv	r3, r2, r3
 8001cf6:	627b      	str	r3, [r7, #36]	; 0x24
 8001cf8:	e00b      	b.n	8001d12 <USART_Init+0xfe>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8001cfa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8001cfc:	4613      	mov	r3, r2
 8001cfe:	009b      	lsls	r3, r3, #2
 8001d00:	4413      	add	r3, r2
 8001d02:	009a      	lsls	r2, r3, #2
 8001d04:	441a      	add	r2, r3
 8001d06:	683b      	ldr	r3, [r7, #0]
 8001d08:	681b      	ldr	r3, [r3, #0]
 8001d0a:	009b      	lsls	r3, r3, #2
 8001d0c:	fbb2 f3f3 	udiv	r3, r2, r3
 8001d10:	627b      	str	r3, [r7, #36]	; 0x24
  }
  tmpreg = (integerdivider / 100) << 4;
 8001d12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001d14:	4a1b      	ldr	r2, [pc, #108]	; (8001d84 <USART_Init+0x170>)
 8001d16:	fba2 2303 	umull	r2, r3, r2, r3
 8001d1a:	095b      	lsrs	r3, r3, #5
 8001d1c:	011b      	lsls	r3, r3, #4
 8001d1e:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8001d20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001d22:	091b      	lsrs	r3, r3, #4
 8001d24:	2264      	movs	r2, #100	; 0x64
 8001d26:	fb02 f303 	mul.w	r3, r2, r3
 8001d2a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001d2c:	1ad3      	subs	r3, r2, r3
 8001d2e:	623b      	str	r3, [r7, #32]

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8001d30:	687b      	ldr	r3, [r7, #4]
 8001d32:	899b      	ldrh	r3, [r3, #12]
 8001d34:	b29b      	uxth	r3, r3
 8001d36:	b21b      	sxth	r3, r3
 8001d38:	2b00      	cmp	r3, #0
 8001d3a:	da0c      	bge.n	8001d56 <USART_Init+0x142>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8001d3c:	6a3b      	ldr	r3, [r7, #32]
 8001d3e:	00db      	lsls	r3, r3, #3
 8001d40:	3332      	adds	r3, #50	; 0x32
 8001d42:	4a10      	ldr	r2, [pc, #64]	; (8001d84 <USART_Init+0x170>)
 8001d44:	fba2 2303 	umull	r2, r3, r2, r3
 8001d48:	095b      	lsrs	r3, r3, #5
 8001d4a:	f003 0307 	and.w	r3, r3, #7
 8001d4e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001d50:	4313      	orrs	r3, r2
 8001d52:	62fb      	str	r3, [r7, #44]	; 0x2c
 8001d54:	e00b      	b.n	8001d6e <USART_Init+0x15a>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8001d56:	6a3b      	ldr	r3, [r7, #32]
 8001d58:	011b      	lsls	r3, r3, #4
 8001d5a:	3332      	adds	r3, #50	; 0x32
 8001d5c:	4a09      	ldr	r2, [pc, #36]	; (8001d84 <USART_Init+0x170>)
 8001d5e:	fba2 2303 	umull	r2, r3, r2, r3
 8001d62:	095b      	lsrs	r3, r3, #5
 8001d64:	f003 030f 	and.w	r3, r3, #15
 8001d68:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001d6a:	4313      	orrs	r3, r2
 8001d6c:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 8001d6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001d70:	b29a      	uxth	r2, r3
 8001d72:	687b      	ldr	r3, [r7, #4]
 8001d74:	811a      	strh	r2, [r3, #8]
}
 8001d76:	bf00      	nop
 8001d78:	3730      	adds	r7, #48	; 0x30
 8001d7a:	46bd      	mov	sp, r7
 8001d7c:	bd80      	pop	{r7, pc}
 8001d7e:	bf00      	nop
 8001d80:	40013800 	.word	0x40013800
 8001d84:	51eb851f 	.word	0x51eb851f

08001d88 <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8001d88:	b480      	push	{r7}
 8001d8a:	b083      	sub	sp, #12
 8001d8c:	af00      	add	r7, sp, #0
 8001d8e:	6078      	str	r0, [r7, #4]
 8001d90:	460b      	mov	r3, r1
 8001d92:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8001d94:	78fb      	ldrb	r3, [r7, #3]
 8001d96:	2b00      	cmp	r3, #0
 8001d98:	d008      	beq.n	8001dac <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8001d9a:	687b      	ldr	r3, [r7, #4]
 8001d9c:	899b      	ldrh	r3, [r3, #12]
 8001d9e:	b29b      	uxth	r3, r3
 8001da0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001da4:	b29a      	uxth	r2, r3
 8001da6:	687b      	ldr	r3, [r7, #4]
 8001da8:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
  }
}
 8001daa:	e007      	b.n	8001dbc <USART_Cmd+0x34>
    USARTx->CR1 |= CR1_UE_Set;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 8001dac:	687b      	ldr	r3, [r7, #4]
 8001dae:	899b      	ldrh	r3, [r3, #12]
 8001db0:	b29b      	uxth	r3, r3
 8001db2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001db6:	b29a      	uxth	r2, r3
 8001db8:	687b      	ldr	r3, [r7, #4]
 8001dba:	819a      	strh	r2, [r3, #12]
  }
}
 8001dbc:	bf00      	nop
 8001dbe:	370c      	adds	r7, #12
 8001dc0:	46bd      	mov	sp, r7
 8001dc2:	bc80      	pop	{r7}
 8001dc4:	4770      	bx	lr
 8001dc6:	bf00      	nop

08001dc8 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8001dc8:	b480      	push	{r7}
 8001dca:	b087      	sub	sp, #28
 8001dcc:	af00      	add	r7, sp, #0
 8001dce:	6078      	str	r0, [r7, #4]
 8001dd0:	460b      	mov	r3, r1
 8001dd2:	807b      	strh	r3, [r7, #2]
 8001dd4:	4613      	mov	r3, r2
 8001dd6:	707b      	strb	r3, [r7, #1]
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 8001dd8:	2300      	movs	r3, #0
 8001dda:	613b      	str	r3, [r7, #16]
 8001ddc:	2300      	movs	r3, #0
 8001dde:	60fb      	str	r3, [r7, #12]
 8001de0:	2300      	movs	r3, #0
 8001de2:	60bb      	str	r3, [r7, #8]
  uint32_t usartxbase = 0x00;
 8001de4:	2300      	movs	r3, #0
 8001de6:	617b      	str	r3, [r7, #20]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  usartxbase = (uint32_t)USARTx;
 8001de8:	687b      	ldr	r3, [r7, #4]
 8001dea:	617b      	str	r3, [r7, #20]

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8001dec:	887b      	ldrh	r3, [r7, #2]
 8001dee:	b2db      	uxtb	r3, r3
 8001df0:	095b      	lsrs	r3, r3, #5
 8001df2:	b2db      	uxtb	r3, r3
 8001df4:	613b      	str	r3, [r7, #16]

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
 8001df6:	887b      	ldrh	r3, [r7, #2]
 8001df8:	f003 031f 	and.w	r3, r3, #31
 8001dfc:	60fb      	str	r3, [r7, #12]
  itmask = (((uint32_t)0x01) << itpos);
 8001dfe:	2201      	movs	r2, #1
 8001e00:	68fb      	ldr	r3, [r7, #12]
 8001e02:	fa02 f303 	lsl.w	r3, r2, r3
 8001e06:	60bb      	str	r3, [r7, #8]
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8001e08:	693b      	ldr	r3, [r7, #16]
 8001e0a:	2b01      	cmp	r3, #1
 8001e0c:	d103      	bne.n	8001e16 <USART_ITConfig+0x4e>
  {
    usartxbase += 0x0C;
 8001e0e:	697b      	ldr	r3, [r7, #20]
 8001e10:	330c      	adds	r3, #12
 8001e12:	617b      	str	r3, [r7, #20]
 8001e14:	e009      	b.n	8001e2a <USART_ITConfig+0x62>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8001e16:	693b      	ldr	r3, [r7, #16]
 8001e18:	2b02      	cmp	r3, #2
 8001e1a:	d103      	bne.n	8001e24 <USART_ITConfig+0x5c>
  {
    usartxbase += 0x10;
 8001e1c:	697b      	ldr	r3, [r7, #20]
 8001e1e:	3310      	adds	r3, #16
 8001e20:	617b      	str	r3, [r7, #20]
 8001e22:	e002      	b.n	8001e2a <USART_ITConfig+0x62>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8001e24:	697b      	ldr	r3, [r7, #20]
 8001e26:	3314      	adds	r3, #20
 8001e28:	617b      	str	r3, [r7, #20]
  }
  if (NewState != DISABLE)
 8001e2a:	787b      	ldrb	r3, [r7, #1]
 8001e2c:	2b00      	cmp	r3, #0
 8001e2e:	d006      	beq.n	8001e3e <USART_ITConfig+0x76>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8001e30:	697b      	ldr	r3, [r7, #20]
 8001e32:	697a      	ldr	r2, [r7, #20]
 8001e34:	6811      	ldr	r1, [r2, #0]
 8001e36:	68ba      	ldr	r2, [r7, #8]
 8001e38:	430a      	orrs	r2, r1
 8001e3a:	601a      	str	r2, [r3, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 8001e3c:	e006      	b.n	8001e4c <USART_ITConfig+0x84>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8001e3e:	697b      	ldr	r3, [r7, #20]
 8001e40:	697a      	ldr	r2, [r7, #20]
 8001e42:	6811      	ldr	r1, [r2, #0]
 8001e44:	68ba      	ldr	r2, [r7, #8]
 8001e46:	43d2      	mvns	r2, r2
 8001e48:	400a      	ands	r2, r1
 8001e4a:	601a      	str	r2, [r3, #0]
  }
}
 8001e4c:	bf00      	nop
 8001e4e:	371c      	adds	r7, #28
 8001e50:	46bd      	mov	sp, r7
 8001e52:	bc80      	pop	{r7}
 8001e54:	4770      	bx	lr
 8001e56:	bf00      	nop

08001e58 <USART_SendData>:
  *   USART1, USART2, USART3, UART4 or UART5.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8001e58:	b480      	push	{r7}
 8001e5a:	b083      	sub	sp, #12
 8001e5c:	af00      	add	r7, sp, #0
 8001e5e:	6078      	str	r0, [r7, #4]
 8001e60:	460b      	mov	r3, r1
 8001e62:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8001e64:	887b      	ldrh	r3, [r7, #2]
 8001e66:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001e6a:	b29a      	uxth	r2, r3
 8001e6c:	687b      	ldr	r3, [r7, #4]
 8001e6e:	809a      	strh	r2, [r3, #4]
}
 8001e70:	bf00      	nop
 8001e72:	370c      	adds	r7, #12
 8001e74:	46bd      	mov	sp, r7
 8001e76:	bc80      	pop	{r7}
 8001e78:	4770      	bx	lr
 8001e7a:	bf00      	nop

08001e7c <USART_ReceiveData>:
  *   This parameter can be one of the following values:
  *   USART1, USART2, USART3, UART4 or UART5.
  * @retval The received data.
  */
uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
{
 8001e7c:	b480      	push	{r7}
 8001e7e:	b083      	sub	sp, #12
 8001e80:	af00      	add	r7, sp, #0
 8001e82:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8001e84:	687b      	ldr	r3, [r7, #4]
 8001e86:	889b      	ldrh	r3, [r3, #4]
 8001e88:	b29b      	uxth	r3, r3
 8001e8a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001e8e:	b29b      	uxth	r3, r3
}
 8001e90:	4618      	mov	r0, r3
 8001e92:	370c      	adds	r7, #12
 8001e94:	46bd      	mov	sp, r7
 8001e96:	bc80      	pop	{r7}
 8001e98:	4770      	bx	lr
 8001e9a:	bf00      	nop

08001e9c <USART_GetITStatus>:
  *     @arg USART_IT_FE:   Framing Error interrupt
  *     @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8001e9c:	b480      	push	{r7}
 8001e9e:	b087      	sub	sp, #28
 8001ea0:	af00      	add	r7, sp, #0
 8001ea2:	6078      	str	r0, [r7, #4]
 8001ea4:	460b      	mov	r3, r1
 8001ea6:	807b      	strh	r3, [r7, #2]
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 8001ea8:	2300      	movs	r3, #0
 8001eaa:	60fb      	str	r3, [r7, #12]
 8001eac:	2300      	movs	r3, #0
 8001eae:	617b      	str	r3, [r7, #20]
 8001eb0:	2300      	movs	r3, #0
 8001eb2:	60bb      	str	r3, [r7, #8]
  ITStatus bitstatus = RESET;
 8001eb4:	2300      	movs	r3, #0
 8001eb6:	74fb      	strb	r3, [r7, #19]
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8001eb8:	887b      	ldrh	r3, [r7, #2]
 8001eba:	b2db      	uxtb	r3, r3
 8001ebc:	095b      	lsrs	r3, r3, #5
 8001ebe:	b2db      	uxtb	r3, r3
 8001ec0:	60bb      	str	r3, [r7, #8]
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
 8001ec2:	887b      	ldrh	r3, [r7, #2]
 8001ec4:	f003 031f 	and.w	r3, r3, #31
 8001ec8:	617b      	str	r3, [r7, #20]
  itmask = (uint32_t)0x01 << itmask;
 8001eca:	2201      	movs	r2, #1
 8001ecc:	697b      	ldr	r3, [r7, #20]
 8001ece:	fa02 f303 	lsl.w	r3, r2, r3
 8001ed2:	617b      	str	r3, [r7, #20]
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8001ed4:	68bb      	ldr	r3, [r7, #8]
 8001ed6:	2b01      	cmp	r3, #1
 8001ed8:	d107      	bne.n	8001eea <USART_GetITStatus+0x4e>
  {
    itmask &= USARTx->CR1;
 8001eda:	687b      	ldr	r3, [r7, #4]
 8001edc:	899b      	ldrh	r3, [r3, #12]
 8001ede:	b29b      	uxth	r3, r3
 8001ee0:	461a      	mov	r2, r3
 8001ee2:	697b      	ldr	r3, [r7, #20]
 8001ee4:	4013      	ands	r3, r2
 8001ee6:	617b      	str	r3, [r7, #20]
 8001ee8:	e011      	b.n	8001f0e <USART_GetITStatus+0x72>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8001eea:	68bb      	ldr	r3, [r7, #8]
 8001eec:	2b02      	cmp	r3, #2
 8001eee:	d107      	bne.n	8001f00 <USART_GetITStatus+0x64>
  {
    itmask &= USARTx->CR2;
 8001ef0:	687b      	ldr	r3, [r7, #4]
 8001ef2:	8a1b      	ldrh	r3, [r3, #16]
 8001ef4:	b29b      	uxth	r3, r3
 8001ef6:	461a      	mov	r2, r3
 8001ef8:	697b      	ldr	r3, [r7, #20]
 8001efa:	4013      	ands	r3, r2
 8001efc:	617b      	str	r3, [r7, #20]
 8001efe:	e006      	b.n	8001f0e <USART_GetITStatus+0x72>
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8001f00:	687b      	ldr	r3, [r7, #4]
 8001f02:	8a9b      	ldrh	r3, [r3, #20]
 8001f04:	b29b      	uxth	r3, r3
 8001f06:	461a      	mov	r2, r3
 8001f08:	697b      	ldr	r3, [r7, #20]
 8001f0a:	4013      	ands	r3, r2
 8001f0c:	617b      	str	r3, [r7, #20]
  }
  
  bitpos = USART_IT >> 0x08;
 8001f0e:	887b      	ldrh	r3, [r7, #2]
 8001f10:	0a1b      	lsrs	r3, r3, #8
 8001f12:	b29b      	uxth	r3, r3
 8001f14:	60fb      	str	r3, [r7, #12]
  bitpos = (uint32_t)0x01 << bitpos;
 8001f16:	2201      	movs	r2, #1
 8001f18:	68fb      	ldr	r3, [r7, #12]
 8001f1a:	fa02 f303 	lsl.w	r3, r2, r3
 8001f1e:	60fb      	str	r3, [r7, #12]
  bitpos &= USARTx->SR;
 8001f20:	687b      	ldr	r3, [r7, #4]
 8001f22:	881b      	ldrh	r3, [r3, #0]
 8001f24:	b29b      	uxth	r3, r3
 8001f26:	461a      	mov	r2, r3
 8001f28:	68fb      	ldr	r3, [r7, #12]
 8001f2a:	4013      	ands	r3, r2
 8001f2c:	60fb      	str	r3, [r7, #12]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8001f2e:	697b      	ldr	r3, [r7, #20]
 8001f30:	2b00      	cmp	r3, #0
 8001f32:	d005      	beq.n	8001f40 <USART_GetITStatus+0xa4>
 8001f34:	68fb      	ldr	r3, [r7, #12]
 8001f36:	2b00      	cmp	r3, #0
 8001f38:	d002      	beq.n	8001f40 <USART_GetITStatus+0xa4>
  {
    bitstatus = SET;
 8001f3a:	2301      	movs	r3, #1
 8001f3c:	74fb      	strb	r3, [r7, #19]
 8001f3e:	e001      	b.n	8001f44 <USART_GetITStatus+0xa8>
  }
  else
  {
    bitstatus = RESET;
 8001f40:	2300      	movs	r3, #0
 8001f42:	74fb      	strb	r3, [r7, #19]
  }
  
  return bitstatus;  
 8001f44:	7cfb      	ldrb	r3, [r7, #19]
}
 8001f46:	4618      	mov	r0, r3
 8001f48:	371c      	adds	r7, #28
 8001f4a:	46bd      	mov	sp, r7
 8001f4c:	bc80      	pop	{r7}
 8001f4e:	4770      	bx	lr

08001f50 <USART_ClearITPendingBit>:
  *   - TXE pending bit is cleared only by a write to the USART_DR register 
  *     (USART_SendData()).
  * @retval None
  */
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8001f50:	b480      	push	{r7}
 8001f52:	b085      	sub	sp, #20
 8001f54:	af00      	add	r7, sp, #0
 8001f56:	6078      	str	r0, [r7, #4]
 8001f58:	460b      	mov	r3, r1
 8001f5a:	807b      	strh	r3, [r7, #2]
  uint16_t bitpos = 0x00, itmask = 0x00;
 8001f5c:	2300      	movs	r3, #0
 8001f5e:	81fb      	strh	r3, [r7, #14]
 8001f60:	2300      	movs	r3, #0
 8001f62:	81bb      	strh	r3, [r7, #12]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  bitpos = USART_IT >> 0x08;
 8001f64:	887b      	ldrh	r3, [r7, #2]
 8001f66:	0a1b      	lsrs	r3, r3, #8
 8001f68:	81fb      	strh	r3, [r7, #14]
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 8001f6a:	89fb      	ldrh	r3, [r7, #14]
 8001f6c:	2201      	movs	r2, #1
 8001f6e:	fa02 f303 	lsl.w	r3, r2, r3
 8001f72:	81bb      	strh	r3, [r7, #12]
  USARTx->SR = (uint16_t)~itmask;
 8001f74:	89bb      	ldrh	r3, [r7, #12]
 8001f76:	43db      	mvns	r3, r3
 8001f78:	b29a      	uxth	r2, r3
 8001f7a:	687b      	ldr	r3, [r7, #4]
 8001f7c:	801a      	strh	r2, [r3, #0]
}
 8001f7e:	bf00      	nop
 8001f80:	3714      	adds	r7, #20
 8001f82:	46bd      	mov	sp, r7
 8001f84:	bc80      	pop	{r7}
 8001f86:	4770      	bx	lr

08001f88 <hist_erase_older>:
#endif

//*****************************************************************************
// remove older message from ring buffer
static void hist_erase_older (ring_history_t * pThis)
{
 8001f88:	b480      	push	{r7}
 8001f8a:	b085      	sub	sp, #20
 8001f8c:	af00      	add	r7, sp, #0
 8001f8e:	6078      	str	r0, [r7, #4]
	int new_pos = pThis->begin + pThis->ring_buf [pThis->begin] + 1;
 8001f90:	687b      	ldr	r3, [r7, #4]
 8001f92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001f94:	687a      	ldr	r2, [r7, #4]
 8001f96:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001f98:	6879      	ldr	r1, [r7, #4]
 8001f9a:	5c8a      	ldrb	r2, [r1, r2]
 8001f9c:	4413      	add	r3, r2
 8001f9e:	3301      	adds	r3, #1
 8001fa0:	60fb      	str	r3, [r7, #12]
	if (new_pos >= _RING_HISTORY_LEN)
 8001fa2:	68fb      	ldr	r3, [r7, #12]
 8001fa4:	2b3f      	cmp	r3, #63	; 0x3f
 8001fa6:	dd02      	ble.n	8001fae <hist_erase_older+0x26>
		new_pos = new_pos - _RING_HISTORY_LEN;
 8001fa8:	68fb      	ldr	r3, [r7, #12]
 8001faa:	3b40      	subs	r3, #64	; 0x40
 8001fac:	60fb      	str	r3, [r7, #12]
	
	pThis->begin = new_pos;
 8001fae:	687b      	ldr	r3, [r7, #4]
 8001fb0:	68fa      	ldr	r2, [r7, #12]
 8001fb2:	641a      	str	r2, [r3, #64]	; 0x40
}
 8001fb4:	bf00      	nop
 8001fb6:	3714      	adds	r7, #20
 8001fb8:	46bd      	mov	sp, r7
 8001fba:	bc80      	pop	{r7}
 8001fbc:	4770      	bx	lr
 8001fbe:	bf00      	nop

08001fc0 <hist_is_space_for_new>:

//*****************************************************************************
// check space for new line, remove older while not space
static int hist_is_space_for_new (ring_history_t * pThis, int len)
{
 8001fc0:	b480      	push	{r7}
 8001fc2:	b083      	sub	sp, #12
 8001fc4:	af00      	add	r7, sp, #0
 8001fc6:	6078      	str	r0, [r7, #4]
 8001fc8:	6039      	str	r1, [r7, #0]
	if (pThis->ring_buf [pThis->begin] == 0)
 8001fca:	687b      	ldr	r3, [r7, #4]
 8001fcc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001fce:	687a      	ldr	r2, [r7, #4]
 8001fd0:	5cd3      	ldrb	r3, [r2, r3]
 8001fd2:	2b00      	cmp	r3, #0
 8001fd4:	d101      	bne.n	8001fda <hist_is_space_for_new+0x1a>
		return true;
 8001fd6:	2301      	movs	r3, #1
 8001fd8:	e01e      	b.n	8002018 <hist_is_space_for_new+0x58>
	if (pThis->end >= pThis->begin) {
 8001fda:	687b      	ldr	r3, [r7, #4]
 8001fdc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001fde:	687b      	ldr	r3, [r7, #4]
 8001fe0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001fe2:	429a      	cmp	r2, r3
 8001fe4:	db0c      	blt.n	8002000 <hist_is_space_for_new+0x40>
		if (_RING_HISTORY_LEN - pThis->end + pThis->begin - 1 > len)
 8001fe6:	687b      	ldr	r3, [r7, #4]
 8001fe8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001fea:	f1c3 0240 	rsb	r2, r3, #64	; 0x40
 8001fee:	687b      	ldr	r3, [r7, #4]
 8001ff0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ff2:	4413      	add	r3, r2
 8001ff4:	1e5a      	subs	r2, r3, #1
 8001ff6:	683b      	ldr	r3, [r7, #0]
 8001ff8:	429a      	cmp	r2, r3
 8001ffa:	dd0c      	ble.n	8002016 <hist_is_space_for_new+0x56>
			return true;
 8001ffc:	2301      	movs	r3, #1
 8001ffe:	e00b      	b.n	8002018 <hist_is_space_for_new+0x58>
	}	else {
		if (pThis->begin - pThis->end - 1> len)
 8002000:	687b      	ldr	r3, [r7, #4]
 8002002:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002004:	687b      	ldr	r3, [r7, #4]
 8002006:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002008:	1ad3      	subs	r3, r2, r3
 800200a:	1e5a      	subs	r2, r3, #1
 800200c:	683b      	ldr	r3, [r7, #0]
 800200e:	429a      	cmp	r2, r3
 8002010:	dd01      	ble.n	8002016 <hist_is_space_for_new+0x56>
			return true;
 8002012:	2301      	movs	r3, #1
 8002014:	e000      	b.n	8002018 <hist_is_space_for_new+0x58>
	}
	return false;
 8002016:	2300      	movs	r3, #0
}
 8002018:	4618      	mov	r0, r3
 800201a:	370c      	adds	r7, #12
 800201c:	46bd      	mov	sp, r7
 800201e:	bc80      	pop	{r7}
 8002020:	4770      	bx	lr
 8002022:	bf00      	nop

08002024 <hist_save_line>:

//*****************************************************************************
// put line to ring buffer
static void hist_save_line (ring_history_t * pThis, char * line, int len)
{
 8002024:	b580      	push	{r7, lr}
 8002026:	b086      	sub	sp, #24
 8002028:	af00      	add	r7, sp, #0
 800202a:	60f8      	str	r0, [r7, #12]
 800202c:	60b9      	str	r1, [r7, #8]
 800202e:	607a      	str	r2, [r7, #4]
	if (len > _RING_HISTORY_LEN - 2)
 8002030:	687b      	ldr	r3, [r7, #4]
 8002032:	2b3e      	cmp	r3, #62	; 0x3e
 8002034:	dc61      	bgt.n	80020fa <hist_save_line+0xd6>
		return;
	while (!hist_is_space_for_new (pThis, len)) {
 8002036:	e002      	b.n	800203e <hist_save_line+0x1a>
		hist_erase_older (pThis);
 8002038:	68f8      	ldr	r0, [r7, #12]
 800203a:	f7ff ffa5 	bl	8001f88 <hist_erase_older>
// put line to ring buffer
static void hist_save_line (ring_history_t * pThis, char * line, int len)
{
	if (len > _RING_HISTORY_LEN - 2)
		return;
	while (!hist_is_space_for_new (pThis, len)) {
 800203e:	6879      	ldr	r1, [r7, #4]
 8002040:	68f8      	ldr	r0, [r7, #12]
 8002042:	f7ff ffbd 	bl	8001fc0 <hist_is_space_for_new>
 8002046:	4603      	mov	r3, r0
 8002048:	2b00      	cmp	r3, #0
 800204a:	d0f5      	beq.n	8002038 <hist_save_line+0x14>
		hist_erase_older (pThis);
	}
	// if it's first line
	if (pThis->ring_buf [pThis->begin] == 0) 
 800204c:	68fb      	ldr	r3, [r7, #12]
 800204e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002050:	68fa      	ldr	r2, [r7, #12]
 8002052:	5cd3      	ldrb	r3, [r2, r3]
 8002054:	2b00      	cmp	r3, #0
 8002056:	d105      	bne.n	8002064 <hist_save_line+0x40>
		pThis->ring_buf [pThis->begin] = len;
 8002058:	68fb      	ldr	r3, [r7, #12]
 800205a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800205c:	687a      	ldr	r2, [r7, #4]
 800205e:	b2d1      	uxtb	r1, r2
 8002060:	68fa      	ldr	r2, [r7, #12]
 8002062:	54d1      	strb	r1, [r2, r3]
	
	// store line
	if (len < _RING_HISTORY_LEN-pThis->end-1)
 8002064:	68fb      	ldr	r3, [r7, #12]
 8002066:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002068:	f1c3 023f 	rsb	r2, r3, #63	; 0x3f
 800206c:	687b      	ldr	r3, [r7, #4]
 800206e:	429a      	cmp	r2, r3
 8002070:	dd0a      	ble.n	8002088 <hist_save_line+0x64>
		memcpy (pThis->ring_buf + pThis->end + 1, line, len);
 8002072:	68fa      	ldr	r2, [r7, #12]
 8002074:	68fb      	ldr	r3, [r7, #12]
 8002076:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002078:	3301      	adds	r3, #1
 800207a:	4413      	add	r3, r2
 800207c:	687a      	ldr	r2, [r7, #4]
 800207e:	68b9      	ldr	r1, [r7, #8]
 8002080:	4618      	mov	r0, r3
 8002082:	f001 fd41 	bl	8003b08 <memcpy>
 8002086:	e018      	b.n	80020ba <hist_save_line+0x96>
	else {
		int part_len = _RING_HISTORY_LEN-pThis->end-1;
 8002088:	68fb      	ldr	r3, [r7, #12]
 800208a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800208c:	f1c3 033f 	rsb	r3, r3, #63	; 0x3f
 8002090:	617b      	str	r3, [r7, #20]
		memcpy (pThis->ring_buf + pThis->end + 1, line, part_len);
 8002092:	68fa      	ldr	r2, [r7, #12]
 8002094:	68fb      	ldr	r3, [r7, #12]
 8002096:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002098:	3301      	adds	r3, #1
 800209a:	4413      	add	r3, r2
 800209c:	697a      	ldr	r2, [r7, #20]
 800209e:	68b9      	ldr	r1, [r7, #8]
 80020a0:	4618      	mov	r0, r3
 80020a2:	f001 fd31 	bl	8003b08 <memcpy>
		memcpy (pThis->ring_buf, line + part_len, len - part_len);
 80020a6:	68f8      	ldr	r0, [r7, #12]
 80020a8:	697b      	ldr	r3, [r7, #20]
 80020aa:	68ba      	ldr	r2, [r7, #8]
 80020ac:	18d1      	adds	r1, r2, r3
 80020ae:	687a      	ldr	r2, [r7, #4]
 80020b0:	697b      	ldr	r3, [r7, #20]
 80020b2:	1ad3      	subs	r3, r2, r3
 80020b4:	461a      	mov	r2, r3
 80020b6:	f001 fd27 	bl	8003b08 <memcpy>
	}
	pThis->ring_buf [pThis->end] = len;
 80020ba:	68fb      	ldr	r3, [r7, #12]
 80020bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80020be:	687a      	ldr	r2, [r7, #4]
 80020c0:	b2d1      	uxtb	r1, r2
 80020c2:	68fa      	ldr	r2, [r7, #12]
 80020c4:	54d1      	strb	r1, [r2, r3]
	pThis->end = pThis->end + len + 1;
 80020c6:	68fb      	ldr	r3, [r7, #12]
 80020c8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80020ca:	687b      	ldr	r3, [r7, #4]
 80020cc:	4413      	add	r3, r2
 80020ce:	1c5a      	adds	r2, r3, #1
 80020d0:	68fb      	ldr	r3, [r7, #12]
 80020d2:	645a      	str	r2, [r3, #68]	; 0x44
	if (pThis->end >= _RING_HISTORY_LEN)
 80020d4:	68fb      	ldr	r3, [r7, #12]
 80020d6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80020d8:	2b3f      	cmp	r3, #63	; 0x3f
 80020da:	dd05      	ble.n	80020e8 <hist_save_line+0xc4>
		pThis->end -= _RING_HISTORY_LEN;
 80020dc:	68fb      	ldr	r3, [r7, #12]
 80020de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80020e0:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 80020e4:	68fb      	ldr	r3, [r7, #12]
 80020e6:	645a      	str	r2, [r3, #68]	; 0x44
	pThis->ring_buf [pThis->end] = 0;
 80020e8:	68fb      	ldr	r3, [r7, #12]
 80020ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80020ec:	68fa      	ldr	r2, [r7, #12]
 80020ee:	2100      	movs	r1, #0
 80020f0:	54d1      	strb	r1, [r2, r3]
	pThis->cur = 0;
 80020f2:	68fb      	ldr	r3, [r7, #12]
 80020f4:	2200      	movs	r2, #0
 80020f6:	649a      	str	r2, [r3, #72]	; 0x48
 80020f8:	e000      	b.n	80020fc <hist_save_line+0xd8>
//*****************************************************************************
// put line to ring buffer
static void hist_save_line (ring_history_t * pThis, char * line, int len)
{
	if (len > _RING_HISTORY_LEN - 2)
		return;
 80020fa:	bf00      	nop
	pThis->ring_buf [pThis->end] = 0;
	pThis->cur = 0;
#ifdef _HISTORY_DEBUG
	print_hist (pThis);
#endif
}
 80020fc:	3718      	adds	r7, #24
 80020fe:	46bd      	mov	sp, r7
 8002100:	bd80      	pop	{r7, pc}
 8002102:	bf00      	nop

08002104 <hist_restore_line>:

//*****************************************************************************
// copy saved line to 'line' and return size of line
static int hist_restore_line (ring_history_t * pThis, char * line, int dir)
{
 8002104:	b580      	push	{r7, lr}
 8002106:	b08c      	sub	sp, #48	; 0x30
 8002108:	af00      	add	r7, sp, #0
 800210a:	60f8      	str	r0, [r7, #12]
 800210c:	60b9      	str	r1, [r7, #8]
 800210e:	607a      	str	r2, [r7, #4]
	int cnt = 0;
 8002110:	2300      	movs	r3, #0
 8002112:	62fb      	str	r3, [r7, #44]	; 0x2c
	// count history record	
	int header = pThis->begin;
 8002114:	68fb      	ldr	r3, [r7, #12]
 8002116:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002118:	62bb      	str	r3, [r7, #40]	; 0x28
	while (pThis->ring_buf [header] != 0) {
 800211a:	e010      	b.n	800213e <hist_restore_line+0x3a>
		header += pThis->ring_buf [header] + 1;
 800211c:	68fa      	ldr	r2, [r7, #12]
 800211e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002120:	4413      	add	r3, r2
 8002122:	781b      	ldrb	r3, [r3, #0]
 8002124:	3301      	adds	r3, #1
 8002126:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002128:	4413      	add	r3, r2
 800212a:	62bb      	str	r3, [r7, #40]	; 0x28
		if (header >= _RING_HISTORY_LEN)
 800212c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800212e:	2b3f      	cmp	r3, #63	; 0x3f
 8002130:	dd02      	ble.n	8002138 <hist_restore_line+0x34>
			header -= _RING_HISTORY_LEN; 
 8002132:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002134:	3b40      	subs	r3, #64	; 0x40
 8002136:	62bb      	str	r3, [r7, #40]	; 0x28
		cnt++;
 8002138:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800213a:	3301      	adds	r3, #1
 800213c:	62fb      	str	r3, [r7, #44]	; 0x2c
static int hist_restore_line (ring_history_t * pThis, char * line, int dir)
{
	int cnt = 0;
	// count history record	
	int header = pThis->begin;
	while (pThis->ring_buf [header] != 0) {
 800213e:	68fa      	ldr	r2, [r7, #12]
 8002140:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002142:	4413      	add	r3, r2
 8002144:	781b      	ldrb	r3, [r3, #0]
 8002146:	2b00      	cmp	r3, #0
 8002148:	d1e8      	bne.n	800211c <hist_restore_line+0x18>
		if (header >= _RING_HISTORY_LEN)
			header -= _RING_HISTORY_LEN; 
		cnt++;
	}

	if (dir == _HIST_UP) {
 800214a:	687b      	ldr	r3, [r7, #4]
 800214c:	2b00      	cmp	r3, #0
 800214e:	d176      	bne.n	800223e <hist_restore_line+0x13a>
		if (cnt >= pThis->cur) {
 8002150:	68fb      	ldr	r3, [r7, #12]
 8002152:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8002154:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002156:	429a      	cmp	r2, r3
 8002158:	f300 80d6 	bgt.w	8002308 <hist_restore_line+0x204>
			int header = pThis->begin;
 800215c:	68fb      	ldr	r3, [r7, #12]
 800215e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002160:	627b      	str	r3, [r7, #36]	; 0x24
			int j = 0;
 8002162:	2300      	movs	r3, #0
 8002164:	623b      	str	r3, [r7, #32]
			// found record for 'pThis->cur' index
			while ((pThis->ring_buf [header] != 0) && (cnt - j -1 != pThis->cur)) {
 8002166:	e010      	b.n	800218a <hist_restore_line+0x86>
				header += pThis->ring_buf [header] + 1;
 8002168:	68fa      	ldr	r2, [r7, #12]
 800216a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800216c:	4413      	add	r3, r2
 800216e:	781b      	ldrb	r3, [r3, #0]
 8002170:	3301      	adds	r3, #1
 8002172:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002174:	4413      	add	r3, r2
 8002176:	627b      	str	r3, [r7, #36]	; 0x24
				if (header >= _RING_HISTORY_LEN)
 8002178:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800217a:	2b3f      	cmp	r3, #63	; 0x3f
 800217c:	dd02      	ble.n	8002184 <hist_restore_line+0x80>
					header -= _RING_HISTORY_LEN;
 800217e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002180:	3b40      	subs	r3, #64	; 0x40
 8002182:	627b      	str	r3, [r7, #36]	; 0x24
				j++;
 8002184:	6a3b      	ldr	r3, [r7, #32]
 8002186:	3301      	adds	r3, #1
 8002188:	623b      	str	r3, [r7, #32]
	if (dir == _HIST_UP) {
		if (cnt >= pThis->cur) {
			int header = pThis->begin;
			int j = 0;
			// found record for 'pThis->cur' index
			while ((pThis->ring_buf [header] != 0) && (cnt - j -1 != pThis->cur)) {
 800218a:	68fa      	ldr	r2, [r7, #12]
 800218c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800218e:	4413      	add	r3, r2
 8002190:	781b      	ldrb	r3, [r3, #0]
 8002192:	2b00      	cmp	r3, #0
 8002194:	d007      	beq.n	80021a6 <hist_restore_line+0xa2>
 8002196:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002198:	6a3b      	ldr	r3, [r7, #32]
 800219a:	1ad3      	subs	r3, r2, r3
 800219c:	1e5a      	subs	r2, r3, #1
 800219e:	68fb      	ldr	r3, [r7, #12]
 80021a0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80021a2:	429a      	cmp	r2, r3
 80021a4:	d1e0      	bne.n	8002168 <hist_restore_line+0x64>
				header += pThis->ring_buf [header] + 1;
				if (header >= _RING_HISTORY_LEN)
					header -= _RING_HISTORY_LEN;
				j++;
			}
			if (pThis->ring_buf[header]) {
 80021a6:	68fa      	ldr	r2, [r7, #12]
 80021a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021aa:	4413      	add	r3, r2
 80021ac:	781b      	ldrb	r3, [r3, #0]
 80021ae:	2b00      	cmp	r3, #0
 80021b0:	f000 80aa 	beq.w	8002308 <hist_restore_line+0x204>
					pThis->cur++;
 80021b4:	68fb      	ldr	r3, [r7, #12]
 80021b6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80021b8:	1c5a      	adds	r2, r3, #1
 80021ba:	68fb      	ldr	r3, [r7, #12]
 80021bc:	649a      	str	r2, [r3, #72]	; 0x48
				// obtain saved line
				if (pThis->ring_buf [header] + header < _RING_HISTORY_LEN) {
 80021be:	68fa      	ldr	r2, [r7, #12]
 80021c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021c2:	4413      	add	r3, r2
 80021c4:	781b      	ldrb	r3, [r3, #0]
 80021c6:	461a      	mov	r2, r3
 80021c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021ca:	4413      	add	r3, r2
 80021cc:	2b3f      	cmp	r3, #63	; 0x3f
 80021ce:	dc11      	bgt.n	80021f4 <hist_restore_line+0xf0>
					memset (line, 0, _COMMAND_LINE_LEN);
 80021d0:	2265      	movs	r2, #101	; 0x65
 80021d2:	2100      	movs	r1, #0
 80021d4:	68b8      	ldr	r0, [r7, #8]
 80021d6:	f001 fcbd 	bl	8003b54 <memset>
					memcpy (line, pThis->ring_buf + header + 1, pThis->ring_buf[header]);
 80021da:	68fa      	ldr	r2, [r7, #12]
 80021dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021de:	3301      	adds	r3, #1
 80021e0:	18d1      	adds	r1, r2, r3
 80021e2:	68fa      	ldr	r2, [r7, #12]
 80021e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021e6:	4413      	add	r3, r2
 80021e8:	781b      	ldrb	r3, [r3, #0]
 80021ea:	461a      	mov	r2, r3
 80021ec:	68b8      	ldr	r0, [r7, #8]
 80021ee:	f001 fc8b 	bl	8003b08 <memcpy>
 80021f2:	e01f      	b.n	8002234 <hist_restore_line+0x130>
				} else {
					int part0 = _RING_HISTORY_LEN - header - 1;
 80021f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021f6:	f1c3 033f 	rsb	r3, r3, #63	; 0x3f
 80021fa:	617b      	str	r3, [r7, #20]
					memset (line, 0, _COMMAND_LINE_LEN);
 80021fc:	2265      	movs	r2, #101	; 0x65
 80021fe:	2100      	movs	r1, #0
 8002200:	68b8      	ldr	r0, [r7, #8]
 8002202:	f001 fca7 	bl	8003b54 <memset>
					memcpy (line, pThis->ring_buf + header + 1, part0);
 8002206:	68fa      	ldr	r2, [r7, #12]
 8002208:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800220a:	3301      	adds	r3, #1
 800220c:	4413      	add	r3, r2
 800220e:	697a      	ldr	r2, [r7, #20]
 8002210:	4619      	mov	r1, r3
 8002212:	68b8      	ldr	r0, [r7, #8]
 8002214:	f001 fc78 	bl	8003b08 <memcpy>
					memcpy (line + part0, pThis->ring_buf, pThis->ring_buf[header] - part0);
 8002218:	697b      	ldr	r3, [r7, #20]
 800221a:	68ba      	ldr	r2, [r7, #8]
 800221c:	18d0      	adds	r0, r2, r3
 800221e:	68f9      	ldr	r1, [r7, #12]
 8002220:	68fa      	ldr	r2, [r7, #12]
 8002222:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002224:	4413      	add	r3, r2
 8002226:	781b      	ldrb	r3, [r3, #0]
 8002228:	461a      	mov	r2, r3
 800222a:	697b      	ldr	r3, [r7, #20]
 800222c:	1ad3      	subs	r3, r2, r3
 800222e:	461a      	mov	r2, r3
 8002230:	f001 fc6a 	bl	8003b08 <memcpy>
				}
				return pThis->ring_buf[header];
 8002234:	68fa      	ldr	r2, [r7, #12]
 8002236:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002238:	4413      	add	r3, r2
 800223a:	781b      	ldrb	r3, [r3, #0]
 800223c:	e066      	b.n	800230c <hist_restore_line+0x208>
			}
		}
	} else {
		if (pThis->cur > 0) {
 800223e:	68fb      	ldr	r3, [r7, #12]
 8002240:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002242:	2b00      	cmp	r3, #0
 8002244:	dd5e      	ble.n	8002304 <hist_restore_line+0x200>
				pThis->cur--;
 8002246:	68fb      	ldr	r3, [r7, #12]
 8002248:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800224a:	1e5a      	subs	r2, r3, #1
 800224c:	68fb      	ldr	r3, [r7, #12]
 800224e:	649a      	str	r2, [r3, #72]	; 0x48
			int header = pThis->begin;
 8002250:	68fb      	ldr	r3, [r7, #12]
 8002252:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002254:	61fb      	str	r3, [r7, #28]
			int j = 0;
 8002256:	2300      	movs	r3, #0
 8002258:	61bb      	str	r3, [r7, #24]

			while ((pThis->ring_buf [header] != 0) && (cnt - j != pThis->cur)) {
 800225a:	e010      	b.n	800227e <hist_restore_line+0x17a>
				header += pThis->ring_buf [header] + 1;
 800225c:	68fa      	ldr	r2, [r7, #12]
 800225e:	69fb      	ldr	r3, [r7, #28]
 8002260:	4413      	add	r3, r2
 8002262:	781b      	ldrb	r3, [r3, #0]
 8002264:	3301      	adds	r3, #1
 8002266:	69fa      	ldr	r2, [r7, #28]
 8002268:	4413      	add	r3, r2
 800226a:	61fb      	str	r3, [r7, #28]
				if (header >= _RING_HISTORY_LEN)
 800226c:	69fb      	ldr	r3, [r7, #28]
 800226e:	2b3f      	cmp	r3, #63	; 0x3f
 8002270:	dd02      	ble.n	8002278 <hist_restore_line+0x174>
					header -= _RING_HISTORY_LEN;
 8002272:	69fb      	ldr	r3, [r7, #28]
 8002274:	3b40      	subs	r3, #64	; 0x40
 8002276:	61fb      	str	r3, [r7, #28]
				j++;
 8002278:	69bb      	ldr	r3, [r7, #24]
 800227a:	3301      	adds	r3, #1
 800227c:	61bb      	str	r3, [r7, #24]
		if (pThis->cur > 0) {
				pThis->cur--;
			int header = pThis->begin;
			int j = 0;

			while ((pThis->ring_buf [header] != 0) && (cnt - j != pThis->cur)) {
 800227e:	68fa      	ldr	r2, [r7, #12]
 8002280:	69fb      	ldr	r3, [r7, #28]
 8002282:	4413      	add	r3, r2
 8002284:	781b      	ldrb	r3, [r3, #0]
 8002286:	2b00      	cmp	r3, #0
 8002288:	d006      	beq.n	8002298 <hist_restore_line+0x194>
 800228a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800228c:	69bb      	ldr	r3, [r7, #24]
 800228e:	1ad2      	subs	r2, r2, r3
 8002290:	68fb      	ldr	r3, [r7, #12]
 8002292:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002294:	429a      	cmp	r2, r3
 8002296:	d1e1      	bne.n	800225c <hist_restore_line+0x158>
				header += pThis->ring_buf [header] + 1;
				if (header >= _RING_HISTORY_LEN)
					header -= _RING_HISTORY_LEN;
				j++;
			}
			if (pThis->ring_buf [header] + header < _RING_HISTORY_LEN) {
 8002298:	68fa      	ldr	r2, [r7, #12]
 800229a:	69fb      	ldr	r3, [r7, #28]
 800229c:	4413      	add	r3, r2
 800229e:	781b      	ldrb	r3, [r3, #0]
 80022a0:	461a      	mov	r2, r3
 80022a2:	69fb      	ldr	r3, [r7, #28]
 80022a4:	4413      	add	r3, r2
 80022a6:	2b3f      	cmp	r3, #63	; 0x3f
 80022a8:	dc0c      	bgt.n	80022c4 <hist_restore_line+0x1c0>
				memcpy (line, pThis->ring_buf + header + 1, pThis->ring_buf[header]);
 80022aa:	68fa      	ldr	r2, [r7, #12]
 80022ac:	69fb      	ldr	r3, [r7, #28]
 80022ae:	3301      	adds	r3, #1
 80022b0:	18d1      	adds	r1, r2, r3
 80022b2:	68fa      	ldr	r2, [r7, #12]
 80022b4:	69fb      	ldr	r3, [r7, #28]
 80022b6:	4413      	add	r3, r2
 80022b8:	781b      	ldrb	r3, [r3, #0]
 80022ba:	461a      	mov	r2, r3
 80022bc:	68b8      	ldr	r0, [r7, #8]
 80022be:	f001 fc23 	bl	8003b08 <memcpy>
 80022c2:	e01a      	b.n	80022fa <hist_restore_line+0x1f6>
			} else {
				int part0 = _RING_HISTORY_LEN - header - 1;
 80022c4:	69fb      	ldr	r3, [r7, #28]
 80022c6:	f1c3 033f 	rsb	r3, r3, #63	; 0x3f
 80022ca:	613b      	str	r3, [r7, #16]
				memcpy (line, pThis->ring_buf + header + 1, part0);
 80022cc:	68fa      	ldr	r2, [r7, #12]
 80022ce:	69fb      	ldr	r3, [r7, #28]
 80022d0:	3301      	adds	r3, #1
 80022d2:	4413      	add	r3, r2
 80022d4:	693a      	ldr	r2, [r7, #16]
 80022d6:	4619      	mov	r1, r3
 80022d8:	68b8      	ldr	r0, [r7, #8]
 80022da:	f001 fc15 	bl	8003b08 <memcpy>
				memcpy (line + part0, pThis->ring_buf, pThis->ring_buf[header] - part0);
 80022de:	693b      	ldr	r3, [r7, #16]
 80022e0:	68ba      	ldr	r2, [r7, #8]
 80022e2:	18d0      	adds	r0, r2, r3
 80022e4:	68f9      	ldr	r1, [r7, #12]
 80022e6:	68fa      	ldr	r2, [r7, #12]
 80022e8:	69fb      	ldr	r3, [r7, #28]
 80022ea:	4413      	add	r3, r2
 80022ec:	781b      	ldrb	r3, [r3, #0]
 80022ee:	461a      	mov	r2, r3
 80022f0:	693b      	ldr	r3, [r7, #16]
 80022f2:	1ad3      	subs	r3, r2, r3
 80022f4:	461a      	mov	r2, r3
 80022f6:	f001 fc07 	bl	8003b08 <memcpy>
			}
			return pThis->ring_buf[header];
 80022fa:	68fa      	ldr	r2, [r7, #12]
 80022fc:	69fb      	ldr	r3, [r7, #28]
 80022fe:	4413      	add	r3, r2
 8002300:	781b      	ldrb	r3, [r3, #0]
 8002302:	e003      	b.n	800230c <hist_restore_line+0x208>
		} else {
			/* empty line */
			return 0;
 8002304:	2300      	movs	r3, #0
 8002306:	e001      	b.n	800230c <hist_restore_line+0x208>
		}
	}
	return -1;
 8002308:	f04f 33ff 	mov.w	r3, #4294967295
}
 800230c:	4618      	mov	r0, r3
 800230e:	3730      	adds	r7, #48	; 0x30
 8002310:	46bd      	mov	sp, r7
 8002312:	bd80      	pop	{r7, pc}

08002314 <split>:


//*****************************************************************************
// split cmdline to tkn array and return nmb of token
static int split (microrl_t * pThis, int limit, char const ** tkn_arr)
{
 8002314:	b480      	push	{r7}
 8002316:	b087      	sub	sp, #28
 8002318:	af00      	add	r7, sp, #0
 800231a:	60f8      	str	r0, [r7, #12]
 800231c:	60b9      	str	r1, [r7, #8]
 800231e:	607a      	str	r2, [r7, #4]
	int i = 0;
 8002320:	2300      	movs	r3, #0
 8002322:	617b      	str	r3, [r7, #20]
	int ind = 0;
 8002324:	2300      	movs	r3, #0
 8002326:	613b      	str	r3, [r7, #16]
	while (1) {
		// go to the first whitespace (zerro for us)
		while ((pThis->cmdline [ind] == '\0') && (ind < limit)) {
 8002328:	e002      	b.n	8002330 <split+0x1c>
			ind++;
 800232a:	693b      	ldr	r3, [r7, #16]
 800232c:	3301      	adds	r3, #1
 800232e:	613b      	str	r3, [r7, #16]
{
	int i = 0;
	int ind = 0;
	while (1) {
		// go to the first whitespace (zerro for us)
		while ((pThis->cmdline [ind] == '\0') && (ind < limit)) {
 8002330:	68fa      	ldr	r2, [r7, #12]
 8002332:	693b      	ldr	r3, [r7, #16]
 8002334:	4413      	add	r3, r2
 8002336:	3354      	adds	r3, #84	; 0x54
 8002338:	781b      	ldrb	r3, [r3, #0]
 800233a:	2b00      	cmp	r3, #0
 800233c:	d103      	bne.n	8002346 <split+0x32>
 800233e:	693a      	ldr	r2, [r7, #16]
 8002340:	68bb      	ldr	r3, [r7, #8]
 8002342:	429a      	cmp	r2, r3
 8002344:	dbf1      	blt.n	800232a <split+0x16>
			ind++;
		}
		if (!(ind < limit)) return i;
 8002346:	693a      	ldr	r2, [r7, #16]
 8002348:	68bb      	ldr	r3, [r7, #8]
 800234a:	429a      	cmp	r2, r3
 800234c:	db01      	blt.n	8002352 <split+0x3e>
 800234e:	697b      	ldr	r3, [r7, #20]
 8002350:	e024      	b.n	800239c <split+0x88>
		tkn_arr[i++] = pThis->cmdline + ind;
 8002352:	697b      	ldr	r3, [r7, #20]
 8002354:	1c5a      	adds	r2, r3, #1
 8002356:	617a      	str	r2, [r7, #20]
 8002358:	009b      	lsls	r3, r3, #2
 800235a:	687a      	ldr	r2, [r7, #4]
 800235c:	4413      	add	r3, r2
 800235e:	68fa      	ldr	r2, [r7, #12]
 8002360:	f102 0154 	add.w	r1, r2, #84	; 0x54
 8002364:	693a      	ldr	r2, [r7, #16]
 8002366:	440a      	add	r2, r1
 8002368:	601a      	str	r2, [r3, #0]
		if (i >= _COMMAND_TOKEN_NMB) {
 800236a:	697b      	ldr	r3, [r7, #20]
 800236c:	2b07      	cmp	r3, #7
 800236e:	dd05      	ble.n	800237c <split+0x68>
			return -1;
 8002370:	f04f 33ff 	mov.w	r3, #4294967295
 8002374:	e012      	b.n	800239c <split+0x88>
		}
		// go to the first NOT whitespace (not zerro for us)
		while ((pThis->cmdline [ind] != '\0') && (ind < limit)) {
			ind++;
 8002376:	693b      	ldr	r3, [r7, #16]
 8002378:	3301      	adds	r3, #1
 800237a:	613b      	str	r3, [r7, #16]
		tkn_arr[i++] = pThis->cmdline + ind;
		if (i >= _COMMAND_TOKEN_NMB) {
			return -1;
		}
		// go to the first NOT whitespace (not zerro for us)
		while ((pThis->cmdline [ind] != '\0') && (ind < limit)) {
 800237c:	68fa      	ldr	r2, [r7, #12]
 800237e:	693b      	ldr	r3, [r7, #16]
 8002380:	4413      	add	r3, r2
 8002382:	3354      	adds	r3, #84	; 0x54
 8002384:	781b      	ldrb	r3, [r3, #0]
 8002386:	2b00      	cmp	r3, #0
 8002388:	d003      	beq.n	8002392 <split+0x7e>
 800238a:	693a      	ldr	r2, [r7, #16]
 800238c:	68bb      	ldr	r3, [r7, #8]
 800238e:	429a      	cmp	r2, r3
 8002390:	dbf1      	blt.n	8002376 <split+0x62>
			ind++;
		}
		if (!(ind < limit)) return i;
 8002392:	693a      	ldr	r2, [r7, #16]
 8002394:	68bb      	ldr	r3, [r7, #8]
 8002396:	429a      	cmp	r2, r3
 8002398:	dbc6      	blt.n	8002328 <split+0x14>
 800239a:	697b      	ldr	r3, [r7, #20]
	}
	return i;
}
 800239c:	4618      	mov	r0, r3
 800239e:	371c      	adds	r7, #28
 80023a0:	46bd      	mov	sp, r7
 80023a2:	bc80      	pop	{r7}
 80023a4:	4770      	bx	lr
 80023a6:	bf00      	nop

080023a8 <print_prompt>:


//*****************************************************************************
inline static void print_prompt (microrl_t * pThis)
{
 80023a8:	b580      	push	{r7, lr}
 80023aa:	b082      	sub	sp, #8
 80023ac:	af00      	add	r7, sp, #0
 80023ae:	6078      	str	r0, [r7, #4]
	pThis->print (pThis->prompt_str);
 80023b0:	687b      	ldr	r3, [r7, #4]
 80023b2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80023b6:	687a      	ldr	r2, [r7, #4]
 80023b8:	6d12      	ldr	r2, [r2, #80]	; 0x50
 80023ba:	4610      	mov	r0, r2
 80023bc:	4798      	blx	r3
}
 80023be:	bf00      	nop
 80023c0:	3708      	adds	r7, #8
 80023c2:	46bd      	mov	sp, r7
 80023c4:	bd80      	pop	{r7, pc}
 80023c6:	bf00      	nop

080023c8 <terminal_backspace>:

//*****************************************************************************
inline static void terminal_backspace (microrl_t * pThis)
{
 80023c8:	b580      	push	{r7, lr}
 80023ca:	b082      	sub	sp, #8
 80023cc:	af00      	add	r7, sp, #0
 80023ce:	6078      	str	r0, [r7, #4]
		pThis->print ("\033[D \033[D");
 80023d0:	687b      	ldr	r3, [r7, #4]
 80023d2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80023d6:	4803      	ldr	r0, [pc, #12]	; (80023e4 <terminal_backspace+0x1c>)
 80023d8:	4798      	blx	r3
}
 80023da:	bf00      	nop
 80023dc:	3708      	adds	r7, #8
 80023de:	46bd      	mov	sp, r7
 80023e0:	bd80      	pop	{r7, pc}
 80023e2:	bf00      	nop
 80023e4:	08003bcc 	.word	0x08003bcc

080023e8 <terminal_newline>:

//*****************************************************************************
inline static void terminal_newline (microrl_t * pThis)
{
 80023e8:	b580      	push	{r7, lr}
 80023ea:	b082      	sub	sp, #8
 80023ec:	af00      	add	r7, sp, #0
 80023ee:	6078      	str	r0, [r7, #4]
	pThis->print (ENDL);
 80023f0:	687b      	ldr	r3, [r7, #4]
 80023f2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80023f6:	4803      	ldr	r0, [pc, #12]	; (8002404 <terminal_newline+0x1c>)
 80023f8:	4798      	blx	r3
}
 80023fa:	bf00      	nop
 80023fc:	3708      	adds	r7, #8
 80023fe:	46bd      	mov	sp, r7
 8002400:	bd80      	pop	{r7, pc}
 8002402:	bf00      	nop
 8002404:	08003bd4 	.word	0x08003bd4

08002408 <u16bit_to_str>:
//*****************************************************************************
// convert 16 bit value to string
// 0 value not supported!!! just make empty string
// Returns pointer to a buffer tail
static char *u16bit_to_str (unsigned int nmb, char * buf)
{
 8002408:	b480      	push	{r7}
 800240a:	b087      	sub	sp, #28
 800240c:	af00      	add	r7, sp, #0
 800240e:	6078      	str	r0, [r7, #4]
 8002410:	6039      	str	r1, [r7, #0]
	char tmp_str [6] = {0,};
 8002412:	f107 0308 	add.w	r3, r7, #8
 8002416:	2200      	movs	r2, #0
 8002418:	601a      	str	r2, [r3, #0]
 800241a:	809a      	strh	r2, [r3, #4]
	int i = 0, j;
 800241c:	2300      	movs	r3, #0
 800241e:	617b      	str	r3, [r7, #20]
	if (nmb <= 0xFFFF) {
 8002420:	687b      	ldr	r3, [r7, #4]
 8002422:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002426:	d235      	bcs.n	8002494 <u16bit_to_str+0x8c>
		while (nmb > 0) {
 8002428:	e01a      	b.n	8002460 <u16bit_to_str+0x58>
			tmp_str[i++] = (nmb % 10) + '0';
 800242a:	6979      	ldr	r1, [r7, #20]
 800242c:	1c4b      	adds	r3, r1, #1
 800242e:	617b      	str	r3, [r7, #20]
 8002430:	6878      	ldr	r0, [r7, #4]
 8002432:	4b1d      	ldr	r3, [pc, #116]	; (80024a8 <u16bit_to_str+0xa0>)
 8002434:	fba3 2300 	umull	r2, r3, r3, r0
 8002438:	08da      	lsrs	r2, r3, #3
 800243a:	4613      	mov	r3, r2
 800243c:	009b      	lsls	r3, r3, #2
 800243e:	4413      	add	r3, r2
 8002440:	005b      	lsls	r3, r3, #1
 8002442:	1ac2      	subs	r2, r0, r3
 8002444:	b2d3      	uxtb	r3, r2
 8002446:	3330      	adds	r3, #48	; 0x30
 8002448:	b2da      	uxtb	r2, r3
 800244a:	f107 0318 	add.w	r3, r7, #24
 800244e:	440b      	add	r3, r1
 8002450:	f803 2c10 	strb.w	r2, [r3, #-16]
			nmb /=10;
 8002454:	687b      	ldr	r3, [r7, #4]
 8002456:	4a14      	ldr	r2, [pc, #80]	; (80024a8 <u16bit_to_str+0xa0>)
 8002458:	fba2 2303 	umull	r2, r3, r2, r3
 800245c:	08db      	lsrs	r3, r3, #3
 800245e:	607b      	str	r3, [r7, #4]
static char *u16bit_to_str (unsigned int nmb, char * buf)
{
	char tmp_str [6] = {0,};
	int i = 0, j;
	if (nmb <= 0xFFFF) {
		while (nmb > 0) {
 8002460:	687b      	ldr	r3, [r7, #4]
 8002462:	2b00      	cmp	r3, #0
 8002464:	d1e1      	bne.n	800242a <u16bit_to_str+0x22>
			tmp_str[i++] = (nmb % 10) + '0';
			nmb /=10;
		}
		for (j = 0; j < i; ++j)
 8002466:	2300      	movs	r3, #0
 8002468:	613b      	str	r3, [r7, #16]
 800246a:	e00f      	b.n	800248c <u16bit_to_str+0x84>
			*(buf++) = tmp_str [i-j-1];
 800246c:	683b      	ldr	r3, [r7, #0]
 800246e:	1c5a      	adds	r2, r3, #1
 8002470:	603a      	str	r2, [r7, #0]
 8002472:	6979      	ldr	r1, [r7, #20]
 8002474:	693a      	ldr	r2, [r7, #16]
 8002476:	1a8a      	subs	r2, r1, r2
 8002478:	3a01      	subs	r2, #1
 800247a:	f107 0118 	add.w	r1, r7, #24
 800247e:	440a      	add	r2, r1
 8002480:	f812 2c10 	ldrb.w	r2, [r2, #-16]
 8002484:	701a      	strb	r2, [r3, #0]
	if (nmb <= 0xFFFF) {
		while (nmb > 0) {
			tmp_str[i++] = (nmb % 10) + '0';
			nmb /=10;
		}
		for (j = 0; j < i; ++j)
 8002486:	693b      	ldr	r3, [r7, #16]
 8002488:	3301      	adds	r3, #1
 800248a:	613b      	str	r3, [r7, #16]
 800248c:	693a      	ldr	r2, [r7, #16]
 800248e:	697b      	ldr	r3, [r7, #20]
 8002490:	429a      	cmp	r2, r3
 8002492:	dbeb      	blt.n	800246c <u16bit_to_str+0x64>
			*(buf++) = tmp_str [i-j-1];
	}
	*buf = '\0';
 8002494:	683b      	ldr	r3, [r7, #0]
 8002496:	2200      	movs	r2, #0
 8002498:	701a      	strb	r2, [r3, #0]
	return buf;
 800249a:	683b      	ldr	r3, [r7, #0]
}
 800249c:	4618      	mov	r0, r3
 800249e:	371c      	adds	r7, #28
 80024a0:	46bd      	mov	sp, r7
 80024a2:	bc80      	pop	{r7}
 80024a4:	4770      	bx	lr
 80024a6:	bf00      	nop
 80024a8:	cccccccd 	.word	0xcccccccd

080024ac <terminal_move_cursor>:


//*****************************************************************************
// set cursor at position from begin cmdline (after prompt) + offset
static void terminal_move_cursor (microrl_t * pThis, int offset)
{
 80024ac:	b580      	push	{r7, lr}
 80024ae:	b088      	sub	sp, #32
 80024b0:	af00      	add	r7, sp, #0
 80024b2:	6078      	str	r0, [r7, #4]
 80024b4:	6039      	str	r1, [r7, #0]
	char str[16] = {0,};
 80024b6:	f107 030c 	add.w	r3, r7, #12
 80024ba:	2200      	movs	r2, #0
 80024bc:	601a      	str	r2, [r3, #0]
 80024be:	605a      	str	r2, [r3, #4]
 80024c0:	609a      	str	r2, [r3, #8]
 80024c2:	60da      	str	r2, [r3, #12]
	} else if (offset < 0) {
		snprintf (str, 16, "\033[%dD", -(offset));
	}
#else 
	char *endstr;
	strcpy (str, "\033[");
 80024c4:	f107 030c 	add.w	r3, r7, #12
 80024c8:	4a1c      	ldr	r2, [pc, #112]	; (800253c <terminal_move_cursor+0x90>)
 80024ca:	6812      	ldr	r2, [r2, #0]
 80024cc:	4611      	mov	r1, r2
 80024ce:	8019      	strh	r1, [r3, #0]
 80024d0:	3302      	adds	r3, #2
 80024d2:	0c12      	lsrs	r2, r2, #16
 80024d4:	701a      	strb	r2, [r3, #0]
	if (offset > 0) {
 80024d6:	683b      	ldr	r3, [r7, #0]
 80024d8:	2b00      	cmp	r3, #0
 80024da:	dd0f      	ble.n	80024fc <terminal_move_cursor+0x50>
		endstr = u16bit_to_str (offset, str+2);
 80024dc:	683a      	ldr	r2, [r7, #0]
 80024de:	f107 030c 	add.w	r3, r7, #12
 80024e2:	3302      	adds	r3, #2
 80024e4:	4619      	mov	r1, r3
 80024e6:	4610      	mov	r0, r2
 80024e8:	f7ff ff8e 	bl	8002408 <u16bit_to_str>
 80024ec:	61f8      	str	r0, [r7, #28]
		strcpy (endstr, "C");
 80024ee:	69fb      	ldr	r3, [r7, #28]
 80024f0:	4913      	ldr	r1, [pc, #76]	; (8002540 <terminal_move_cursor+0x94>)
 80024f2:	461a      	mov	r2, r3
 80024f4:	460b      	mov	r3, r1
 80024f6:	881b      	ldrh	r3, [r3, #0]
 80024f8:	8013      	strh	r3, [r2, #0]
 80024fa:	e013      	b.n	8002524 <terminal_move_cursor+0x78>
	} else if (offset < 0) {
 80024fc:	683b      	ldr	r3, [r7, #0]
 80024fe:	2b00      	cmp	r3, #0
 8002500:	da18      	bge.n	8002534 <terminal_move_cursor+0x88>
		endstr = u16bit_to_str (-(offset), str+2);
 8002502:	683b      	ldr	r3, [r7, #0]
 8002504:	425b      	negs	r3, r3
 8002506:	461a      	mov	r2, r3
 8002508:	f107 030c 	add.w	r3, r7, #12
 800250c:	3302      	adds	r3, #2
 800250e:	4619      	mov	r1, r3
 8002510:	4610      	mov	r0, r2
 8002512:	f7ff ff79 	bl	8002408 <u16bit_to_str>
 8002516:	61f8      	str	r0, [r7, #28]
		strcpy (endstr, "D");
 8002518:	69fb      	ldr	r3, [r7, #28]
 800251a:	490a      	ldr	r1, [pc, #40]	; (8002544 <terminal_move_cursor+0x98>)
 800251c:	461a      	mov	r2, r3
 800251e:	460b      	mov	r3, r1
 8002520:	881b      	ldrh	r3, [r3, #0]
 8002522:	8013      	strh	r3, [r2, #0]
	} else
		return;
#endif	
	pThis->print (str);
 8002524:	687b      	ldr	r3, [r7, #4]
 8002526:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800252a:	f107 020c 	add.w	r2, r7, #12
 800252e:	4610      	mov	r0, r2
 8002530:	4798      	blx	r3
 8002532:	e000      	b.n	8002536 <terminal_move_cursor+0x8a>
		strcpy (endstr, "C");
	} else if (offset < 0) {
		endstr = u16bit_to_str (-(offset), str+2);
		strcpy (endstr, "D");
	} else
		return;
 8002534:	bf00      	nop
#endif	
	pThis->print (str);
}
 8002536:	3720      	adds	r7, #32
 8002538:	46bd      	mov	sp, r7
 800253a:	bd80      	pop	{r7, pc}
 800253c:	08003bd8 	.word	0x08003bd8
 8002540:	08003bdc 	.word	0x08003bdc
 8002544:	08003be0 	.word	0x08003be0

08002548 <terminal_reset_cursor>:

//*****************************************************************************
static void terminal_reset_cursor (microrl_t * pThis)
{
 8002548:	b580      	push	{r7, lr}
 800254a:	b088      	sub	sp, #32
 800254c:	af00      	add	r7, sp, #0
 800254e:	6078      	str	r0, [r7, #4]
	snprintf (str, 16, "\033[%dD\033[%dC", \
						_COMMAND_LINE_LEN + _PROMPT_LEN + 2, _PROMPT_LEN);

#else
	char *endstr;
	strcpy (str, "\033[");
 8002550:	f107 030c 	add.w	r3, r7, #12
 8002554:	4a15      	ldr	r2, [pc, #84]	; (80025ac <terminal_reset_cursor+0x64>)
 8002556:	6812      	ldr	r2, [r2, #0]
 8002558:	4611      	mov	r1, r2
 800255a:	8019      	strh	r1, [r3, #0]
 800255c:	3302      	adds	r3, #2
 800255e:	0c12      	lsrs	r2, r2, #16
 8002560:	701a      	strb	r2, [r3, #0]
	endstr = u16bit_to_str ( _COMMAND_LINE_LEN + _PROMPT_LEN + 2,str+2);
 8002562:	f107 030c 	add.w	r3, r7, #12
 8002566:	3302      	adds	r3, #2
 8002568:	4619      	mov	r1, r3
 800256a:	206e      	movs	r0, #110	; 0x6e
 800256c:	f7ff ff4c 	bl	8002408 <u16bit_to_str>
 8002570:	61f8      	str	r0, [r7, #28]
	strcpy (endstr, "D\033["); endstr += 3;
 8002572:	69fb      	ldr	r3, [r7, #28]
 8002574:	4a0e      	ldr	r2, [pc, #56]	; (80025b0 <terminal_reset_cursor+0x68>)
 8002576:	6810      	ldr	r0, [r2, #0]
 8002578:	6018      	str	r0, [r3, #0]
 800257a:	69fb      	ldr	r3, [r7, #28]
 800257c:	3303      	adds	r3, #3
 800257e:	61fb      	str	r3, [r7, #28]
	endstr = u16bit_to_str (_PROMPT_LEN, endstr);
 8002580:	69f9      	ldr	r1, [r7, #28]
 8002582:	2007      	movs	r0, #7
 8002584:	f7ff ff40 	bl	8002408 <u16bit_to_str>
 8002588:	61f8      	str	r0, [r7, #28]
	strcpy (endstr, "C");
 800258a:	69fb      	ldr	r3, [r7, #28]
 800258c:	4909      	ldr	r1, [pc, #36]	; (80025b4 <terminal_reset_cursor+0x6c>)
 800258e:	461a      	mov	r2, r3
 8002590:	460b      	mov	r3, r1
 8002592:	881b      	ldrh	r3, [r3, #0]
 8002594:	8013      	strh	r3, [r2, #0]
#endif
	pThis->print (str);
 8002596:	687b      	ldr	r3, [r7, #4]
 8002598:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800259c:	f107 020c 	add.w	r2, r7, #12
 80025a0:	4610      	mov	r0, r2
 80025a2:	4798      	blx	r3
}
 80025a4:	bf00      	nop
 80025a6:	3720      	adds	r7, #32
 80025a8:	46bd      	mov	sp, r7
 80025aa:	bd80      	pop	{r7, pc}
 80025ac:	08003bd8 	.word	0x08003bd8
 80025b0:	08003be4 	.word	0x08003be4
 80025b4:	08003bdc 	.word	0x08003bdc

080025b8 <terminal_print_line>:

//*****************************************************************************
// print cmdline to screen, replace '\0' to wihitespace 
static void terminal_print_line (microrl_t * pThis, int pos, int cursor)
{
 80025b8:	b580      	push	{r7, lr}
 80025ba:	b086      	sub	sp, #24
 80025bc:	af00      	add	r7, sp, #0
 80025be:	60f8      	str	r0, [r7, #12]
 80025c0:	60b9      	str	r1, [r7, #8]
 80025c2:	607a      	str	r2, [r7, #4]
	pThis->print ("\033[K");    // delete all from cursor to end
 80025c4:	68fb      	ldr	r3, [r7, #12]
 80025c6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80025ca:	4817      	ldr	r0, [pc, #92]	; (8002628 <terminal_print_line+0x70>)
 80025cc:	4798      	blx	r3

	char nch [] = {0,0};
 80025ce:	2300      	movs	r3, #0
 80025d0:	743b      	strb	r3, [r7, #16]
 80025d2:	2300      	movs	r3, #0
 80025d4:	747b      	strb	r3, [r7, #17]
	int i;
	for (i = pos; i < pThis->cmdlen; i++) {
 80025d6:	68bb      	ldr	r3, [r7, #8]
 80025d8:	617b      	str	r3, [r7, #20]
 80025da:	e014      	b.n	8002606 <terminal_print_line+0x4e>
		nch [0] = pThis->cmdline [i];
 80025dc:	68fa      	ldr	r2, [r7, #12]
 80025de:	697b      	ldr	r3, [r7, #20]
 80025e0:	4413      	add	r3, r2
 80025e2:	3354      	adds	r3, #84	; 0x54
 80025e4:	781b      	ldrb	r3, [r3, #0]
 80025e6:	743b      	strb	r3, [r7, #16]
		if (nch[0] == '\0')
 80025e8:	7c3b      	ldrb	r3, [r7, #16]
 80025ea:	2b00      	cmp	r3, #0
 80025ec:	d101      	bne.n	80025f2 <terminal_print_line+0x3a>
			nch[0] = ' ';
 80025ee:	2320      	movs	r3, #32
 80025f0:	743b      	strb	r3, [r7, #16]
		pThis->print (nch);
 80025f2:	68fb      	ldr	r3, [r7, #12]
 80025f4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80025f8:	f107 0210 	add.w	r2, r7, #16
 80025fc:	4610      	mov	r0, r2
 80025fe:	4798      	blx	r3
{
	pThis->print ("\033[K");    // delete all from cursor to end

	char nch [] = {0,0};
	int i;
	for (i = pos; i < pThis->cmdlen; i++) {
 8002600:	697b      	ldr	r3, [r7, #20]
 8002602:	3301      	adds	r3, #1
 8002604:	617b      	str	r3, [r7, #20]
 8002606:	68fb      	ldr	r3, [r7, #12]
 8002608:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 800260c:	697b      	ldr	r3, [r7, #20]
 800260e:	429a      	cmp	r2, r3
 8002610:	dce4      	bgt.n	80025dc <terminal_print_line+0x24>
		if (nch[0] == '\0')
			nch[0] = ' ';
		pThis->print (nch);
	}
	
	terminal_reset_cursor (pThis);
 8002612:	68f8      	ldr	r0, [r7, #12]
 8002614:	f7ff ff98 	bl	8002548 <terminal_reset_cursor>
	terminal_move_cursor (pThis, cursor);
 8002618:	6879      	ldr	r1, [r7, #4]
 800261a:	68f8      	ldr	r0, [r7, #12]
 800261c:	f7ff ff46 	bl	80024ac <terminal_move_cursor>
}
 8002620:	bf00      	nop
 8002622:	3718      	adds	r7, #24
 8002624:	46bd      	mov	sp, r7
 8002626:	bd80      	pop	{r7, pc}
 8002628:	08003be8 	.word	0x08003be8

0800262c <microrl_init>:

//*****************************************************************************
void microrl_init (microrl_t * pThis, void (*print) (const char *)) 
{
 800262c:	b580      	push	{r7, lr}
 800262e:	b082      	sub	sp, #8
 8002630:	af00      	add	r7, sp, #0
 8002632:	6078      	str	r0, [r7, #4]
 8002634:	6039      	str	r1, [r7, #0]
	memset(pThis->cmdline, 0, _COMMAND_LINE_LEN);
 8002636:	687b      	ldr	r3, [r7, #4]
 8002638:	3354      	adds	r3, #84	; 0x54
 800263a:	2265      	movs	r2, #101	; 0x65
 800263c:	2100      	movs	r1, #0
 800263e:	4618      	mov	r0, r3
 8002640:	f001 fa88 	bl	8003b54 <memset>
#ifdef _USE_HISTORY
	memset(pThis->ring_hist.ring_buf, 0, _RING_HISTORY_LEN);
 8002644:	687b      	ldr	r3, [r7, #4]
 8002646:	3304      	adds	r3, #4
 8002648:	2240      	movs	r2, #64	; 0x40
 800264a:	2100      	movs	r1, #0
 800264c:	4618      	mov	r0, r3
 800264e:	f001 fa81 	bl	8003b54 <memset>
	pThis->ring_hist.begin = 0;
 8002652:	687b      	ldr	r3, [r7, #4]
 8002654:	2200      	movs	r2, #0
 8002656:	645a      	str	r2, [r3, #68]	; 0x44
	pThis->ring_hist.end = 0;
 8002658:	687b      	ldr	r3, [r7, #4]
 800265a:	2200      	movs	r2, #0
 800265c:	649a      	str	r2, [r3, #72]	; 0x48
	pThis->ring_hist.cur = 0;
 800265e:	687b      	ldr	r3, [r7, #4]
 8002660:	2200      	movs	r2, #0
 8002662:	64da      	str	r2, [r3, #76]	; 0x4c
#endif
	pThis->cmdlen =0;
 8002664:	687b      	ldr	r3, [r7, #4]
 8002666:	2200      	movs	r2, #0
 8002668:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
	pThis->cursor = 0;
 800266c:	687b      	ldr	r3, [r7, #4]
 800266e:	2200      	movs	r2, #0
 8002670:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	pThis->execute = NULL;
 8002674:	687b      	ldr	r3, [r7, #4]
 8002676:	2200      	movs	r2, #0
 8002678:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
	pThis->get_completion = NULL;
 800267c:	687b      	ldr	r3, [r7, #4]
 800267e:	2200      	movs	r2, #0
 8002680:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
#ifdef _USE_CTLR_C
	pThis->sigint = NULL;
 8002684:	687b      	ldr	r3, [r7, #4]
 8002686:	2200      	movs	r2, #0
 8002688:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
#endif
	pThis->prompt_str = prompt_default;
 800268c:	4b09      	ldr	r3, [pc, #36]	; (80026b4 <microrl_init+0x88>)
 800268e:	681a      	ldr	r2, [r3, #0]
 8002690:	687b      	ldr	r3, [r7, #4]
 8002692:	651a      	str	r2, [r3, #80]	; 0x50
	pThis->print = print;
 8002694:	687b      	ldr	r3, [r7, #4]
 8002696:	683a      	ldr	r2, [r7, #0]
 8002698:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
#ifdef _ENABLE_INIT_PROMPT
	pThis->print(ENDL);
 800269c:	687b      	ldr	r3, [r7, #4]
 800269e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80026a2:	4805      	ldr	r0, [pc, #20]	; (80026b8 <microrl_init+0x8c>)
 80026a4:	4798      	blx	r3
	print_prompt (pThis);
 80026a6:	6878      	ldr	r0, [r7, #4]
 80026a8:	f7ff fe7e 	bl	80023a8 <print_prompt>
#endif
}
 80026ac:	bf00      	nop
 80026ae:	3708      	adds	r7, #8
 80026b0:	46bd      	mov	sp, r7
 80026b2:	bd80      	pop	{r7, pc}
 80026b4:	20000020 	.word	0x20000020
 80026b8:	08003bd4 	.word	0x08003bd4

080026bc <microrl_set_complete_callback>:

//*****************************************************************************
void microrl_set_complete_callback (microrl_t * pThis, char ** (*get_completion)(int, const char* const*))
{
 80026bc:	b480      	push	{r7}
 80026be:	b083      	sub	sp, #12
 80026c0:	af00      	add	r7, sp, #0
 80026c2:	6078      	str	r0, [r7, #4]
 80026c4:	6039      	str	r1, [r7, #0]
	pThis->get_completion = get_completion;
 80026c6:	687b      	ldr	r3, [r7, #4]
 80026c8:	683a      	ldr	r2, [r7, #0]
 80026ca:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
 80026ce:	bf00      	nop
 80026d0:	370c      	adds	r7, #12
 80026d2:	46bd      	mov	sp, r7
 80026d4:	bc80      	pop	{r7}
 80026d6:	4770      	bx	lr

080026d8 <microrl_set_execute_callback>:

//*****************************************************************************
void microrl_set_execute_callback (microrl_t * pThis, int (*execute)(int, const char* const*))
{
 80026d8:	b480      	push	{r7}
 80026da:	b083      	sub	sp, #12
 80026dc:	af00      	add	r7, sp, #0
 80026de:	6078      	str	r0, [r7, #4]
 80026e0:	6039      	str	r1, [r7, #0]
	pThis->execute = execute;
 80026e2:	687b      	ldr	r3, [r7, #4]
 80026e4:	683a      	ldr	r2, [r7, #0]
 80026e6:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
}
 80026ea:	bf00      	nop
 80026ec:	370c      	adds	r7, #12
 80026ee:	46bd      	mov	sp, r7
 80026f0:	bc80      	pop	{r7}
 80026f2:	4770      	bx	lr

080026f4 <microrl_set_sigint_callback>:
#ifdef _USE_CTLR_C
//*****************************************************************************
void microrl_set_sigint_callback (microrl_t * pThis, void (*sigintf)(void))
{
 80026f4:	b480      	push	{r7}
 80026f6:	b083      	sub	sp, #12
 80026f8:	af00      	add	r7, sp, #0
 80026fa:	6078      	str	r0, [r7, #4]
 80026fc:	6039      	str	r1, [r7, #0]
	pThis->sigint = sigintf;
 80026fe:	687b      	ldr	r3, [r7, #4]
 8002700:	683a      	ldr	r2, [r7, #0]
 8002702:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
}
 8002706:	bf00      	nop
 8002708:	370c      	adds	r7, #12
 800270a:	46bd      	mov	sp, r7
 800270c:	bc80      	pop	{r7}
 800270e:	4770      	bx	lr

08002710 <hist_search>:
#endif

#ifdef _USE_ESC_SEQ
static void hist_search (microrl_t * pThis, int dir)
{
 8002710:	b580      	push	{r7, lr}
 8002712:	b084      	sub	sp, #16
 8002714:	af00      	add	r7, sp, #0
 8002716:	6078      	str	r0, [r7, #4]
 8002718:	6039      	str	r1, [r7, #0]
	int len = hist_restore_line (&pThis->ring_hist, pThis->cmdline, dir);
 800271a:	687b      	ldr	r3, [r7, #4]
 800271c:	1d18      	adds	r0, r3, #4
 800271e:	687b      	ldr	r3, [r7, #4]
 8002720:	3354      	adds	r3, #84	; 0x54
 8002722:	683a      	ldr	r2, [r7, #0]
 8002724:	4619      	mov	r1, r3
 8002726:	f7ff fced 	bl	8002104 <hist_restore_line>
 800272a:	60f8      	str	r0, [r7, #12]
	if (len >= 0) {
 800272c:	68fb      	ldr	r3, [r7, #12]
 800272e:	2b00      	cmp	r3, #0
 8002730:	db14      	blt.n	800275c <hist_search+0x4c>
		pThis->cursor = pThis->cmdlen = len;
 8002732:	687b      	ldr	r3, [r7, #4]
 8002734:	68fa      	ldr	r2, [r7, #12]
 8002736:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
 800273a:	687b      	ldr	r3, [r7, #4]
 800273c:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 8002740:	687b      	ldr	r3, [r7, #4]
 8002742:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		terminal_reset_cursor (pThis);
 8002746:	6878      	ldr	r0, [r7, #4]
 8002748:	f7ff fefe 	bl	8002548 <terminal_reset_cursor>
		terminal_print_line (pThis, 0, pThis->cursor);
 800274c:	687b      	ldr	r3, [r7, #4]
 800274e:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002752:	461a      	mov	r2, r3
 8002754:	2100      	movs	r1, #0
 8002756:	6878      	ldr	r0, [r7, #4]
 8002758:	f7ff ff2e 	bl	80025b8 <terminal_print_line>
	}
}
 800275c:	bf00      	nop
 800275e:	3710      	adds	r7, #16
 8002760:	46bd      	mov	sp, r7
 8002762:	bd80      	pop	{r7, pc}

08002764 <escape_process>:

//*****************************************************************************
// handling escape sequences
static int escape_process (microrl_t * pThis, char ch)
{
 8002764:	b580      	push	{r7, lr}
 8002766:	b082      	sub	sp, #8
 8002768:	af00      	add	r7, sp, #0
 800276a:	6078      	str	r0, [r7, #4]
 800276c:	460b      	mov	r3, r1
 800276e:	70fb      	strb	r3, [r7, #3]
	if (ch == '[') {
 8002770:	78fb      	ldrb	r3, [r7, #3]
 8002772:	2b5b      	cmp	r3, #91	; 0x5b
 8002774:	d104      	bne.n	8002780 <escape_process+0x1c>
		pThis->escape_seq = _ESC_BRACKET;
 8002776:	687b      	ldr	r3, [r7, #4]
 8002778:	2201      	movs	r2, #1
 800277a:	701a      	strb	r2, [r3, #0]
		return 0;
 800277c:	2300      	movs	r3, #0
 800277e:	e07b      	b.n	8002878 <escape_process+0x114>
	} else if (pThis->escape_seq == _ESC_BRACKET) {
 8002780:	687b      	ldr	r3, [r7, #4]
 8002782:	781b      	ldrb	r3, [r3, #0]
 8002784:	2b01      	cmp	r3, #1
 8002786:	d14f      	bne.n	8002828 <escape_process+0xc4>
		if (ch == 'A') {
 8002788:	78fb      	ldrb	r3, [r7, #3]
 800278a:	2b41      	cmp	r3, #65	; 0x41
 800278c:	d105      	bne.n	800279a <escape_process+0x36>
#ifdef _USE_HISTORY
			hist_search (pThis, _HIST_UP);
 800278e:	2100      	movs	r1, #0
 8002790:	6878      	ldr	r0, [r7, #4]
 8002792:	f7ff ffbd 	bl	8002710 <hist_search>
#endif
			return 1;
 8002796:	2301      	movs	r3, #1
 8002798:	e06e      	b.n	8002878 <escape_process+0x114>
		} else if (ch == 'B') {
 800279a:	78fb      	ldrb	r3, [r7, #3]
 800279c:	2b42      	cmp	r3, #66	; 0x42
 800279e:	d105      	bne.n	80027ac <escape_process+0x48>
#ifdef _USE_HISTORY
			hist_search (pThis, _HIST_DOWN);
 80027a0:	2101      	movs	r1, #1
 80027a2:	6878      	ldr	r0, [r7, #4]
 80027a4:	f7ff ffb4 	bl	8002710 <hist_search>
#endif
			return 1;
 80027a8:	2301      	movs	r3, #1
 80027aa:	e065      	b.n	8002878 <escape_process+0x114>
		} else if (ch == 'C') {
 80027ac:	78fb      	ldrb	r3, [r7, #3]
 80027ae:	2b43      	cmp	r3, #67	; 0x43
 80027b0:	d114      	bne.n	80027dc <escape_process+0x78>
			if (pThis->cursor < pThis->cmdlen) {
 80027b2:	687b      	ldr	r3, [r7, #4]
 80027b4:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 80027b8:	687b      	ldr	r3, [r7, #4]
 80027ba:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 80027be:	429a      	cmp	r2, r3
 80027c0:	da0a      	bge.n	80027d8 <escape_process+0x74>
				terminal_move_cursor (pThis, 1);
 80027c2:	2101      	movs	r1, #1
 80027c4:	6878      	ldr	r0, [r7, #4]
 80027c6:	f7ff fe71 	bl	80024ac <terminal_move_cursor>
				pThis->cursor++;
 80027ca:	687b      	ldr	r3, [r7, #4]
 80027cc:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80027d0:	1c5a      	adds	r2, r3, #1
 80027d2:	687b      	ldr	r3, [r7, #4]
 80027d4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
			}
			return 1;
 80027d8:	2301      	movs	r3, #1
 80027da:	e04d      	b.n	8002878 <escape_process+0x114>
		} else if (ch == 'D') {
 80027dc:	78fb      	ldrb	r3, [r7, #3]
 80027de:	2b44      	cmp	r3, #68	; 0x44
 80027e0:	d112      	bne.n	8002808 <escape_process+0xa4>
			if (pThis->cursor > 0) {
 80027e2:	687b      	ldr	r3, [r7, #4]
 80027e4:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80027e8:	2b00      	cmp	r3, #0
 80027ea:	dd0b      	ble.n	8002804 <escape_process+0xa0>
				terminal_move_cursor (pThis, -1);
 80027ec:	f04f 31ff 	mov.w	r1, #4294967295
 80027f0:	6878      	ldr	r0, [r7, #4]
 80027f2:	f7ff fe5b 	bl	80024ac <terminal_move_cursor>
				pThis->cursor--;
 80027f6:	687b      	ldr	r3, [r7, #4]
 80027f8:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80027fc:	1e5a      	subs	r2, r3, #1
 80027fe:	687b      	ldr	r3, [r7, #4]
 8002800:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
			}
			return 1;
 8002804:	2301      	movs	r3, #1
 8002806:	e037      	b.n	8002878 <escape_process+0x114>
		} else if (ch == '7') {
 8002808:	78fb      	ldrb	r3, [r7, #3]
 800280a:	2b37      	cmp	r3, #55	; 0x37
 800280c:	d104      	bne.n	8002818 <escape_process+0xb4>
			pThis->escape_seq = _ESC_HOME;
 800280e:	687b      	ldr	r3, [r7, #4]
 8002810:	2202      	movs	r2, #2
 8002812:	701a      	strb	r2, [r3, #0]
			return 0;
 8002814:	2300      	movs	r3, #0
 8002816:	e02f      	b.n	8002878 <escape_process+0x114>
		} else if (ch == '8') {
 8002818:	78fb      	ldrb	r3, [r7, #3]
 800281a:	2b38      	cmp	r3, #56	; 0x38
 800281c:	d12b      	bne.n	8002876 <escape_process+0x112>
			pThis->escape_seq = _ESC_END;
 800281e:	687b      	ldr	r3, [r7, #4]
 8002820:	2203      	movs	r2, #3
 8002822:	701a      	strb	r2, [r3, #0]
			return 0;
 8002824:	2300      	movs	r3, #0
 8002826:	e027      	b.n	8002878 <escape_process+0x114>
		} 
	} else if (ch == '~') {
 8002828:	78fb      	ldrb	r3, [r7, #3]
 800282a:	2b7e      	cmp	r3, #126	; 0x7e
 800282c:	d123      	bne.n	8002876 <escape_process+0x112>
		if (pThis->escape_seq == _ESC_HOME) {
 800282e:	687b      	ldr	r3, [r7, #4]
 8002830:	781b      	ldrb	r3, [r3, #0]
 8002832:	2b02      	cmp	r3, #2
 8002834:	d108      	bne.n	8002848 <escape_process+0xe4>
			terminal_reset_cursor (pThis);
 8002836:	6878      	ldr	r0, [r7, #4]
 8002838:	f7ff fe86 	bl	8002548 <terminal_reset_cursor>
			pThis->cursor = 0;
 800283c:	687b      	ldr	r3, [r7, #4]
 800283e:	2200      	movs	r2, #0
 8002840:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
			return 1;
 8002844:	2301      	movs	r3, #1
 8002846:	e017      	b.n	8002878 <escape_process+0x114>
		} else if (pThis->escape_seq == _ESC_END) {
 8002848:	687b      	ldr	r3, [r7, #4]
 800284a:	781b      	ldrb	r3, [r3, #0]
 800284c:	2b03      	cmp	r3, #3
 800284e:	d112      	bne.n	8002876 <escape_process+0x112>
			terminal_move_cursor (pThis, pThis->cmdlen-pThis->cursor);
 8002850:	687b      	ldr	r3, [r7, #4]
 8002852:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 8002856:	687b      	ldr	r3, [r7, #4]
 8002858:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800285c:	1ad3      	subs	r3, r2, r3
 800285e:	4619      	mov	r1, r3
 8002860:	6878      	ldr	r0, [r7, #4]
 8002862:	f7ff fe23 	bl	80024ac <terminal_move_cursor>
			pThis->cursor = pThis->cmdlen;
 8002866:	687b      	ldr	r3, [r7, #4]
 8002868:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 800286c:	687b      	ldr	r3, [r7, #4]
 800286e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
			return 1;
 8002872:	2301      	movs	r3, #1
 8002874:	e000      	b.n	8002878 <escape_process+0x114>
		}
	}

	/* unknown escape sequence, stop */
	return 1;
 8002876:	2301      	movs	r3, #1
}
 8002878:	4618      	mov	r0, r3
 800287a:	3708      	adds	r7, #8
 800287c:	46bd      	mov	sp, r7
 800287e:	bd80      	pop	{r7, pc}

08002880 <microrl_insert_text>:
#endif

//*****************************************************************************
// insert len char of text at cursor position
static int microrl_insert_text (microrl_t * pThis, char * text, int len)
{
 8002880:	b580      	push	{r7, lr}
 8002882:	b086      	sub	sp, #24
 8002884:	af00      	add	r7, sp, #0
 8002886:	60f8      	str	r0, [r7, #12]
 8002888:	60b9      	str	r1, [r7, #8]
 800288a:	607a      	str	r2, [r7, #4]
	int i;
	if (pThis->cmdlen + len < _COMMAND_LINE_LEN) {
 800288c:	68fb      	ldr	r3, [r7, #12]
 800288e:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 8002892:	687b      	ldr	r3, [r7, #4]
 8002894:	4413      	add	r3, r2
 8002896:	2b64      	cmp	r3, #100	; 0x64
 8002898:	dc60      	bgt.n	800295c <microrl_insert_text+0xdc>
		memmove (pThis->cmdline + pThis->cursor + len,
 800289a:	68fb      	ldr	r3, [r7, #12]
 800289c:	f103 0254 	add.w	r2, r3, #84	; 0x54
 80028a0:	68fb      	ldr	r3, [r7, #12]
 80028a2:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80028a6:	4619      	mov	r1, r3
 80028a8:	687b      	ldr	r3, [r7, #4]
 80028aa:	440b      	add	r3, r1
 80028ac:	18d0      	adds	r0, r2, r3
						 pThis->cmdline + pThis->cursor,
 80028ae:	68fb      	ldr	r3, [r7, #12]
 80028b0:	3354      	adds	r3, #84	; 0x54
 80028b2:	68fa      	ldr	r2, [r7, #12]
 80028b4:	f8d2 20c0 	ldr.w	r2, [r2, #192]	; 0xc0
// insert len char of text at cursor position
static int microrl_insert_text (microrl_t * pThis, char * text, int len)
{
	int i;
	if (pThis->cmdlen + len < _COMMAND_LINE_LEN) {
		memmove (pThis->cmdline + pThis->cursor + len,
 80028b8:	1899      	adds	r1, r3, r2
						 pThis->cmdline + pThis->cursor,
						 pThis->cmdlen - pThis->cursor);
 80028ba:	68fb      	ldr	r3, [r7, #12]
 80028bc:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 80028c0:	68fb      	ldr	r3, [r7, #12]
 80028c2:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80028c6:	1ad3      	subs	r3, r2, r3
// insert len char of text at cursor position
static int microrl_insert_text (microrl_t * pThis, char * text, int len)
{
	int i;
	if (pThis->cmdlen + len < _COMMAND_LINE_LEN) {
		memmove (pThis->cmdline + pThis->cursor + len,
 80028c8:	461a      	mov	r2, r3
 80028ca:	f001 f928 	bl	8003b1e <memmove>
						 pThis->cmdline + pThis->cursor,
						 pThis->cmdlen - pThis->cursor);
		for (i = 0; i < len; i++) {
 80028ce:	2300      	movs	r3, #0
 80028d0:	617b      	str	r3, [r7, #20]
 80028d2:	e025      	b.n	8002920 <microrl_insert_text+0xa0>
			pThis->cmdline [pThis->cursor + i] = text [i];
 80028d4:	68fb      	ldr	r3, [r7, #12]
 80028d6:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 80028da:	697b      	ldr	r3, [r7, #20]
 80028dc:	4413      	add	r3, r2
 80028de:	697a      	ldr	r2, [r7, #20]
 80028e0:	68b9      	ldr	r1, [r7, #8]
 80028e2:	440a      	add	r2, r1
 80028e4:	7811      	ldrb	r1, [r2, #0]
 80028e6:	68fa      	ldr	r2, [r7, #12]
 80028e8:	4413      	add	r3, r2
 80028ea:	460a      	mov	r2, r1
 80028ec:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
			if (pThis->cmdline [pThis->cursor + i] == ' ') {
 80028f0:	68fb      	ldr	r3, [r7, #12]
 80028f2:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 80028f6:	697b      	ldr	r3, [r7, #20]
 80028f8:	4413      	add	r3, r2
 80028fa:	68fa      	ldr	r2, [r7, #12]
 80028fc:	4413      	add	r3, r2
 80028fe:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8002902:	2b20      	cmp	r3, #32
 8002904:	d109      	bne.n	800291a <microrl_insert_text+0x9a>
				pThis->cmdline [pThis->cursor + i] = 0;
 8002906:	68fb      	ldr	r3, [r7, #12]
 8002908:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 800290c:	697b      	ldr	r3, [r7, #20]
 800290e:	4413      	add	r3, r2
 8002910:	68fa      	ldr	r2, [r7, #12]
 8002912:	4413      	add	r3, r2
 8002914:	2200      	movs	r2, #0
 8002916:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	int i;
	if (pThis->cmdlen + len < _COMMAND_LINE_LEN) {
		memmove (pThis->cmdline + pThis->cursor + len,
						 pThis->cmdline + pThis->cursor,
						 pThis->cmdlen - pThis->cursor);
		for (i = 0; i < len; i++) {
 800291a:	697b      	ldr	r3, [r7, #20]
 800291c:	3301      	adds	r3, #1
 800291e:	617b      	str	r3, [r7, #20]
 8002920:	697a      	ldr	r2, [r7, #20]
 8002922:	687b      	ldr	r3, [r7, #4]
 8002924:	429a      	cmp	r2, r3
 8002926:	dbd5      	blt.n	80028d4 <microrl_insert_text+0x54>
			pThis->cmdline [pThis->cursor + i] = text [i];
			if (pThis->cmdline [pThis->cursor + i] == ' ') {
				pThis->cmdline [pThis->cursor + i] = 0;
			}
		}
		pThis->cursor += len;
 8002928:	68fb      	ldr	r3, [r7, #12]
 800292a:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 800292e:	687b      	ldr	r3, [r7, #4]
 8002930:	441a      	add	r2, r3
 8002932:	68fb      	ldr	r3, [r7, #12]
 8002934:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		pThis->cmdlen += len;
 8002938:	68fb      	ldr	r3, [r7, #12]
 800293a:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 800293e:	687b      	ldr	r3, [r7, #4]
 8002940:	441a      	add	r2, r3
 8002942:	68fb      	ldr	r3, [r7, #12]
 8002944:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
		pThis->cmdline [pThis->cmdlen] = '\0';
 8002948:	68fb      	ldr	r3, [r7, #12]
 800294a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800294e:	68fa      	ldr	r2, [r7, #12]
 8002950:	4413      	add	r3, r2
 8002952:	2200      	movs	r2, #0
 8002954:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
		return true;
 8002958:	2301      	movs	r3, #1
 800295a:	e000      	b.n	800295e <microrl_insert_text+0xde>
	}
	return false;
 800295c:	2300      	movs	r3, #0
}
 800295e:	4618      	mov	r0, r3
 8002960:	3718      	adds	r7, #24
 8002962:	46bd      	mov	sp, r7
 8002964:	bd80      	pop	{r7, pc}
 8002966:	bf00      	nop

08002968 <microrl_backspace>:

//*****************************************************************************
// remove one char at cursor
static void microrl_backspace (microrl_t * pThis)
{
 8002968:	b580      	push	{r7, lr}
 800296a:	b082      	sub	sp, #8
 800296c:	af00      	add	r7, sp, #0
 800296e:	6078      	str	r0, [r7, #4]
	if (pThis->cursor > 0) {
 8002970:	687b      	ldr	r3, [r7, #4]
 8002972:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002976:	2b00      	cmp	r3, #0
 8002978:	dd31      	ble.n	80029de <microrl_backspace+0x76>
		terminal_backspace (pThis);
 800297a:	6878      	ldr	r0, [r7, #4]
 800297c:	f7ff fd24 	bl	80023c8 <terminal_backspace>
		memmove (pThis->cmdline + pThis->cursor-1,
 8002980:	687b      	ldr	r3, [r7, #4]
 8002982:	f103 0254 	add.w	r2, r3, #84	; 0x54
 8002986:	687b      	ldr	r3, [r7, #4]
 8002988:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800298c:	3b01      	subs	r3, #1
 800298e:	18d0      	adds	r0, r2, r3
						 pThis->cmdline + pThis->cursor,
 8002990:	687b      	ldr	r3, [r7, #4]
 8002992:	3354      	adds	r3, #84	; 0x54
 8002994:	687a      	ldr	r2, [r7, #4]
 8002996:	f8d2 20c0 	ldr.w	r2, [r2, #192]	; 0xc0
// remove one char at cursor
static void microrl_backspace (microrl_t * pThis)
{
	if (pThis->cursor > 0) {
		terminal_backspace (pThis);
		memmove (pThis->cmdline + pThis->cursor-1,
 800299a:	1899      	adds	r1, r3, r2
						 pThis->cmdline + pThis->cursor,
						 pThis->cmdlen-pThis->cursor+1);
 800299c:	687b      	ldr	r3, [r7, #4]
 800299e:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 80029a2:	687b      	ldr	r3, [r7, #4]
 80029a4:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80029a8:	1ad3      	subs	r3, r2, r3
 80029aa:	3301      	adds	r3, #1
// remove one char at cursor
static void microrl_backspace (microrl_t * pThis)
{
	if (pThis->cursor > 0) {
		terminal_backspace (pThis);
		memmove (pThis->cmdline + pThis->cursor-1,
 80029ac:	461a      	mov	r2, r3
 80029ae:	f001 f8b6 	bl	8003b1e <memmove>
						 pThis->cmdline + pThis->cursor,
						 pThis->cmdlen-pThis->cursor+1);
		pThis->cursor--;
 80029b2:	687b      	ldr	r3, [r7, #4]
 80029b4:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80029b8:	1e5a      	subs	r2, r3, #1
 80029ba:	687b      	ldr	r3, [r7, #4]
 80029bc:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		pThis->cmdline [pThis->cmdlen] = '\0';
 80029c0:	687b      	ldr	r3, [r7, #4]
 80029c2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 80029c6:	687a      	ldr	r2, [r7, #4]
 80029c8:	4413      	add	r3, r2
 80029ca:	2200      	movs	r2, #0
 80029cc:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
		pThis->cmdlen--;
 80029d0:	687b      	ldr	r3, [r7, #4]
 80029d2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 80029d6:	1e5a      	subs	r2, r3, #1
 80029d8:	687b      	ldr	r3, [r7, #4]
 80029da:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
	}
}
 80029de:	bf00      	nop
 80029e0:	3708      	adds	r7, #8
 80029e2:	46bd      	mov	sp, r7
 80029e4:	bd80      	pop	{r7, pc}
 80029e6:	bf00      	nop

080029e8 <common_len>:

#ifdef _USE_COMPLETE

//*****************************************************************************
static int common_len (char ** arr)
{
 80029e8:	b480      	push	{r7}
 80029ea:	b085      	sub	sp, #20
 80029ec:	af00      	add	r7, sp, #0
 80029ee:	6078      	str	r0, [r7, #4]
	int len = 0;
 80029f0:	2300      	movs	r3, #0
 80029f2:	60fb      	str	r3, [r7, #12]
	int i = 1;
 80029f4:	2301      	movs	r3, #1
 80029f6:	60bb      	str	r3, [r7, #8]
	while (1) {
		while (arr[i]!=NULL) {
 80029f8:	e030      	b.n	8002a5c <common_len+0x74>
			if ((arr[i][len] != arr[i-1][len]) || 
 80029fa:	68bb      	ldr	r3, [r7, #8]
 80029fc:	009b      	lsls	r3, r3, #2
 80029fe:	687a      	ldr	r2, [r7, #4]
 8002a00:	4413      	add	r3, r2
 8002a02:	681a      	ldr	r2, [r3, #0]
 8002a04:	68fb      	ldr	r3, [r7, #12]
 8002a06:	4413      	add	r3, r2
 8002a08:	781a      	ldrb	r2, [r3, #0]
 8002a0a:	68bb      	ldr	r3, [r7, #8]
 8002a0c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002a10:	3b01      	subs	r3, #1
 8002a12:	009b      	lsls	r3, r3, #2
 8002a14:	6879      	ldr	r1, [r7, #4]
 8002a16:	440b      	add	r3, r1
 8002a18:	6819      	ldr	r1, [r3, #0]
 8002a1a:	68fb      	ldr	r3, [r7, #12]
 8002a1c:	440b      	add	r3, r1
 8002a1e:	781b      	ldrb	r3, [r3, #0]
 8002a20:	429a      	cmp	r2, r3
 8002a22:	d116      	bne.n	8002a52 <common_len+0x6a>
					(arr[i][len] == '\0') || 
 8002a24:	68bb      	ldr	r3, [r7, #8]
 8002a26:	009b      	lsls	r3, r3, #2
 8002a28:	687a      	ldr	r2, [r7, #4]
 8002a2a:	4413      	add	r3, r2
 8002a2c:	681a      	ldr	r2, [r3, #0]
 8002a2e:	68fb      	ldr	r3, [r7, #12]
 8002a30:	4413      	add	r3, r2
 8002a32:	781b      	ldrb	r3, [r3, #0]
{
	int len = 0;
	int i = 1;
	while (1) {
		while (arr[i]!=NULL) {
			if ((arr[i][len] != arr[i-1][len]) || 
 8002a34:	2b00      	cmp	r3, #0
 8002a36:	d00c      	beq.n	8002a52 <common_len+0x6a>
					(arr[i][len] == '\0') || 
					(arr[i-1][len]=='\0')) 
 8002a38:	68bb      	ldr	r3, [r7, #8]
 8002a3a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002a3e:	3b01      	subs	r3, #1
 8002a40:	009b      	lsls	r3, r3, #2
 8002a42:	687a      	ldr	r2, [r7, #4]
 8002a44:	4413      	add	r3, r2
 8002a46:	681a      	ldr	r2, [r3, #0]
 8002a48:	68fb      	ldr	r3, [r7, #12]
 8002a4a:	4413      	add	r3, r2
 8002a4c:	781b      	ldrb	r3, [r3, #0]
	int len = 0;
	int i = 1;
	while (1) {
		while (arr[i]!=NULL) {
			if ((arr[i][len] != arr[i-1][len]) || 
					(arr[i][len] == '\0') || 
 8002a4e:	2b00      	cmp	r3, #0
 8002a50:	d101      	bne.n	8002a56 <common_len+0x6e>
					(arr[i-1][len]=='\0')) 
				return len;
 8002a52:	68fb      	ldr	r3, [r7, #12]
 8002a54:	e00d      	b.n	8002a72 <common_len+0x8a>
			len++;
 8002a56:	68fb      	ldr	r3, [r7, #12]
 8002a58:	3301      	adds	r3, #1
 8002a5a:	60fb      	str	r3, [r7, #12]
static int common_len (char ** arr)
{
	int len = 0;
	int i = 1;
	while (1) {
		while (arr[i]!=NULL) {
 8002a5c:	68bb      	ldr	r3, [r7, #8]
 8002a5e:	009b      	lsls	r3, r3, #2
 8002a60:	687a      	ldr	r2, [r7, #4]
 8002a62:	4413      	add	r3, r2
 8002a64:	681b      	ldr	r3, [r3, #0]
 8002a66:	2b00      	cmp	r3, #0
 8002a68:	d1c7      	bne.n	80029fa <common_len+0x12>
					(arr[i][len] == '\0') || 
					(arr[i-1][len]=='\0')) 
				return len;
			len++;
		}
		i++;
 8002a6a:	68bb      	ldr	r3, [r7, #8]
 8002a6c:	3301      	adds	r3, #1
 8002a6e:	60bb      	str	r3, [r7, #8]
	}
 8002a70:	e7c2      	b.n	80029f8 <common_len+0x10>
	return 0;
}
 8002a72:	4618      	mov	r0, r3
 8002a74:	3714      	adds	r7, #20
 8002a76:	46bd      	mov	sp, r7
 8002a78:	bc80      	pop	{r7}
 8002a7a:	4770      	bx	lr

08002a7c <microrl_get_complite>:

//*****************************************************************************
static void microrl_get_complite (microrl_t * pThis) 
{
 8002a7c:	b5b0      	push	{r4, r5, r7, lr}
 8002a7e:	b08e      	sub	sp, #56	; 0x38
 8002a80:	af00      	add	r7, sp, #0
 8002a82:	6078      	str	r0, [r7, #4]
	char const * tkn_arr[_COMMAND_TOKEN_NMB];
	char ** compl_token; 
	
	if (pThis->get_completion == NULL) // callback was not set
 8002a84:	687b      	ldr	r3, [r7, #4]
 8002a86:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8002a8a:	2b00      	cmp	r3, #0
 8002a8c:	f000 809c 	beq.w	8002bc8 <microrl_get_complite+0x14c>
		return;
	
	int status = split (pThis, pThis->cursor, tkn_arr);
 8002a90:	687b      	ldr	r3, [r7, #4]
 8002a92:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002a96:	f107 0208 	add.w	r2, r7, #8
 8002a9a:	4619      	mov	r1, r3
 8002a9c:	6878      	ldr	r0, [r7, #4]
 8002a9e:	f7ff fc39 	bl	8002314 <split>
 8002aa2:	6378      	str	r0, [r7, #52]	; 0x34
	if (pThis->cmdline[pThis->cursor-1] == '\0')
 8002aa4:	687b      	ldr	r3, [r7, #4]
 8002aa6:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002aaa:	3b01      	subs	r3, #1
 8002aac:	687a      	ldr	r2, [r7, #4]
 8002aae:	4413      	add	r3, r2
 8002ab0:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8002ab4:	2b00      	cmp	r3, #0
 8002ab6:	d109      	bne.n	8002acc <microrl_get_complite+0x50>
		tkn_arr[status++] = "";
 8002ab8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002aba:	1c5a      	adds	r2, r3, #1
 8002abc:	637a      	str	r2, [r7, #52]	; 0x34
 8002abe:	009b      	lsls	r3, r3, #2
 8002ac0:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8002ac4:	4413      	add	r3, r2
 8002ac6:	4a42      	ldr	r2, [pc, #264]	; (8002bd0 <microrl_get_complite+0x154>)
 8002ac8:	f843 2c30 	str.w	r2, [r3, #-48]
	compl_token = pThis->get_completion (status, tkn_arr);
 8002acc:	687b      	ldr	r3, [r7, #4]
 8002ace:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8002ad2:	f107 0208 	add.w	r2, r7, #8
 8002ad6:	4611      	mov	r1, r2
 8002ad8:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8002ada:	4798      	blx	r3
 8002adc:	62b8      	str	r0, [r7, #40]	; 0x28
	if (compl_token[0] != NULL) {
 8002ade:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ae0:	681b      	ldr	r3, [r3, #0]
 8002ae2:	2b00      	cmp	r3, #0
 8002ae4:	d071      	beq.n	8002bca <microrl_get_complite+0x14e>
		int i = 0;
 8002ae6:	2300      	movs	r3, #0
 8002ae8:	633b      	str	r3, [r7, #48]	; 0x30
		int len;

		if (compl_token[1] == NULL) {
 8002aea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002aec:	3304      	adds	r3, #4
 8002aee:	681b      	ldr	r3, [r3, #0]
 8002af0:	2b00      	cmp	r3, #0
 8002af2:	d107      	bne.n	8002b04 <microrl_get_complite+0x88>
			len = strlen (compl_token[0]);
 8002af4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002af6:	681b      	ldr	r3, [r3, #0]
 8002af8:	4618      	mov	r0, r3
 8002afa:	f7fd fb9d 	bl	8000238 <strlen>
 8002afe:	4603      	mov	r3, r0
 8002b00:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002b02:	e026      	b.n	8002b52 <microrl_get_complite+0xd6>
		} else {
			len = common_len (compl_token);
 8002b04:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8002b06:	f7ff ff6f 	bl	80029e8 <common_len>
 8002b0a:	62f8      	str	r0, [r7, #44]	; 0x2c
			terminal_newline (pThis);
 8002b0c:	6878      	ldr	r0, [r7, #4]
 8002b0e:	f7ff fc6b 	bl	80023e8 <terminal_newline>
			while (compl_token [i] != NULL) {
 8002b12:	e011      	b.n	8002b38 <microrl_get_complite+0xbc>
				pThis->print (compl_token[i]);
 8002b14:	687b      	ldr	r3, [r7, #4]
 8002b16:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8002b1a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8002b1c:	0092      	lsls	r2, r2, #2
 8002b1e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8002b20:	440a      	add	r2, r1
 8002b22:	6812      	ldr	r2, [r2, #0]
 8002b24:	4610      	mov	r0, r2
 8002b26:	4798      	blx	r3
				pThis->print (" ");
 8002b28:	687b      	ldr	r3, [r7, #4]
 8002b2a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8002b2e:	4829      	ldr	r0, [pc, #164]	; (8002bd4 <microrl_get_complite+0x158>)
 8002b30:	4798      	blx	r3
				i++;
 8002b32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002b34:	3301      	adds	r3, #1
 8002b36:	633b      	str	r3, [r7, #48]	; 0x30
		if (compl_token[1] == NULL) {
			len = strlen (compl_token[0]);
		} else {
			len = common_len (compl_token);
			terminal_newline (pThis);
			while (compl_token [i] != NULL) {
 8002b38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002b3a:	009b      	lsls	r3, r3, #2
 8002b3c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002b3e:	4413      	add	r3, r2
 8002b40:	681b      	ldr	r3, [r3, #0]
 8002b42:	2b00      	cmp	r3, #0
 8002b44:	d1e6      	bne.n	8002b14 <microrl_get_complite+0x98>
				pThis->print (compl_token[i]);
				pThis->print (" ");
				i++;
			}
			terminal_newline (pThis);
 8002b46:	6878      	ldr	r0, [r7, #4]
 8002b48:	f7ff fc4e 	bl	80023e8 <terminal_newline>
			print_prompt (pThis);
 8002b4c:	6878      	ldr	r0, [r7, #4]
 8002b4e:	f7ff fc2b 	bl	80023a8 <print_prompt>
		}
		
		if (len) {
 8002b52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002b54:	2b00      	cmp	r3, #0
 8002b56:	d02b      	beq.n	8002bb0 <microrl_get_complite+0x134>
			microrl_insert_text (pThis, compl_token[0] + strlen(tkn_arr[status-1]), 
 8002b58:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002b5a:	681c      	ldr	r4, [r3, #0]
 8002b5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002b5e:	3b01      	subs	r3, #1
 8002b60:	009b      	lsls	r3, r3, #2
 8002b62:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8002b66:	4413      	add	r3, r2
 8002b68:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8002b6c:	4618      	mov	r0, r3
 8002b6e:	f7fd fb63 	bl	8000238 <strlen>
 8002b72:	4603      	mov	r3, r0
 8002b74:	18e5      	adds	r5, r4, r3
																	len - strlen(tkn_arr[status-1]));
 8002b76:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 8002b78:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002b7a:	3b01      	subs	r3, #1
 8002b7c:	009b      	lsls	r3, r3, #2
 8002b7e:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8002b82:	4413      	add	r3, r2
 8002b84:	f853 3c30 	ldr.w	r3, [r3, #-48]
 8002b88:	4618      	mov	r0, r3
 8002b8a:	f7fd fb55 	bl	8000238 <strlen>
 8002b8e:	4603      	mov	r3, r0
 8002b90:	1ae3      	subs	r3, r4, r3
			terminal_newline (pThis);
			print_prompt (pThis);
		}
		
		if (len) {
			microrl_insert_text (pThis, compl_token[0] + strlen(tkn_arr[status-1]), 
 8002b92:	461a      	mov	r2, r3
 8002b94:	4629      	mov	r1, r5
 8002b96:	6878      	ldr	r0, [r7, #4]
 8002b98:	f7ff fe72 	bl	8002880 <microrl_insert_text>
																	len - strlen(tkn_arr[status-1]));
			if (compl_token[1] == NULL) 
 8002b9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002b9e:	3304      	adds	r3, #4
 8002ba0:	681b      	ldr	r3, [r3, #0]
 8002ba2:	2b00      	cmp	r3, #0
 8002ba4:	d104      	bne.n	8002bb0 <microrl_get_complite+0x134>
				microrl_insert_text (pThis, " ", 1);
 8002ba6:	2201      	movs	r2, #1
 8002ba8:	490a      	ldr	r1, [pc, #40]	; (8002bd4 <microrl_get_complite+0x158>)
 8002baa:	6878      	ldr	r0, [r7, #4]
 8002bac:	f7ff fe68 	bl	8002880 <microrl_insert_text>
		}
		terminal_reset_cursor (pThis);
 8002bb0:	6878      	ldr	r0, [r7, #4]
 8002bb2:	f7ff fcc9 	bl	8002548 <terminal_reset_cursor>
		terminal_print_line (pThis, 0, pThis->cursor);
 8002bb6:	687b      	ldr	r3, [r7, #4]
 8002bb8:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002bbc:	461a      	mov	r2, r3
 8002bbe:	2100      	movs	r1, #0
 8002bc0:	6878      	ldr	r0, [r7, #4]
 8002bc2:	f7ff fcf9 	bl	80025b8 <terminal_print_line>
 8002bc6:	e000      	b.n	8002bca <microrl_get_complite+0x14e>
{
	char const * tkn_arr[_COMMAND_TOKEN_NMB];
	char ** compl_token; 
	
	if (pThis->get_completion == NULL) // callback was not set
		return;
 8002bc8:	bf00      	nop
				microrl_insert_text (pThis, " ", 1);
		}
		terminal_reset_cursor (pThis);
		terminal_print_line (pThis, 0, pThis->cursor);
	} 
}
 8002bca:	3738      	adds	r7, #56	; 0x38
 8002bcc:	46bd      	mov	sp, r7
 8002bce:	bdb0      	pop	{r4, r5, r7, pc}
 8002bd0:	08003bec 	.word	0x08003bec
 8002bd4:	08003bf0 	.word	0x08003bf0

08002bd8 <new_line_handler>:
#endif

//*****************************************************************************
void new_line_handler(microrl_t * pThis){
 8002bd8:	b580      	push	{r7, lr}
 8002bda:	b08c      	sub	sp, #48	; 0x30
 8002bdc:	af00      	add	r7, sp, #0
 8002bde:	6078      	str	r0, [r7, #4]
	char const * tkn_arr [_COMMAND_TOKEN_NMB];
	int status;

	terminal_newline (pThis);
 8002be0:	6878      	ldr	r0, [r7, #4]
 8002be2:	f7ff fc01 	bl	80023e8 <terminal_newline>
#ifdef _USE_HISTORY
	if (pThis->cmdlen > 0)
 8002be6:	687b      	ldr	r3, [r7, #4]
 8002be8:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8002bec:	2b00      	cmp	r3, #0
 8002bee:	dd0a      	ble.n	8002c06 <new_line_handler+0x2e>
		hist_save_line (&pThis->ring_hist, pThis->cmdline, pThis->cmdlen);
 8002bf0:	687b      	ldr	r3, [r7, #4]
 8002bf2:	1d18      	adds	r0, r3, #4
 8002bf4:	687b      	ldr	r3, [r7, #4]
 8002bf6:	f103 0154 	add.w	r1, r3, #84	; 0x54
 8002bfa:	687b      	ldr	r3, [r7, #4]
 8002bfc:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8002c00:	461a      	mov	r2, r3
 8002c02:	f7ff fa0f 	bl	8002024 <hist_save_line>
#endif
	status = split (pThis, pThis->cmdlen, tkn_arr);
 8002c06:	687b      	ldr	r3, [r7, #4]
 8002c08:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8002c0c:	f107 020c 	add.w	r2, r7, #12
 8002c10:	4619      	mov	r1, r3
 8002c12:	6878      	ldr	r0, [r7, #4]
 8002c14:	f7ff fb7e 	bl	8002314 <split>
 8002c18:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (status == -1){
 8002c1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002c1c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002c20:	d109      	bne.n	8002c36 <new_line_handler+0x5e>
		//          pThis->print ("ERROR: Max token amount exseed\n");
		pThis->print ("ERROR:too many tokens");
 8002c22:	687b      	ldr	r3, [r7, #4]
 8002c24:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8002c28:	4817      	ldr	r0, [pc, #92]	; (8002c88 <new_line_handler+0xb0>)
 8002c2a:	4798      	blx	r3
		pThis->print (ENDL);
 8002c2c:	687b      	ldr	r3, [r7, #4]
 8002c2e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8002c32:	4816      	ldr	r0, [pc, #88]	; (8002c8c <new_line_handler+0xb4>)
 8002c34:	4798      	blx	r3
	}
	if ((status > 0) && (pThis->execute != NULL))
 8002c36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	dd0c      	ble.n	8002c56 <new_line_handler+0x7e>
 8002c3c:	687b      	ldr	r3, [r7, #4]
 8002c3e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8002c42:	2b00      	cmp	r3, #0
 8002c44:	d007      	beq.n	8002c56 <new_line_handler+0x7e>
		pThis->execute (status, tkn_arr);
 8002c46:	687b      	ldr	r3, [r7, #4]
 8002c48:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8002c4c:	f107 020c 	add.w	r2, r7, #12
 8002c50:	4611      	mov	r1, r2
 8002c52:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8002c54:	4798      	blx	r3
	print_prompt (pThis);
 8002c56:	6878      	ldr	r0, [r7, #4]
 8002c58:	f7ff fba6 	bl	80023a8 <print_prompt>
	pThis->cmdlen = 0;
 8002c5c:	687b      	ldr	r3, [r7, #4]
 8002c5e:	2200      	movs	r2, #0
 8002c60:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
	pThis->cursor = 0;
 8002c64:	687b      	ldr	r3, [r7, #4]
 8002c66:	2200      	movs	r2, #0
 8002c68:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	memset(pThis->cmdline, 0, _COMMAND_LINE_LEN);
 8002c6c:	687b      	ldr	r3, [r7, #4]
 8002c6e:	3354      	adds	r3, #84	; 0x54
 8002c70:	2265      	movs	r2, #101	; 0x65
 8002c72:	2100      	movs	r1, #0
 8002c74:	4618      	mov	r0, r3
 8002c76:	f000 ff6d 	bl	8003b54 <memset>
#ifdef _USE_HISTORY
	pThis->ring_hist.cur = 0;
 8002c7a:	687b      	ldr	r3, [r7, #4]
 8002c7c:	2200      	movs	r2, #0
 8002c7e:	64da      	str	r2, [r3, #76]	; 0x4c
#endif
}
 8002c80:	bf00      	nop
 8002c82:	3730      	adds	r7, #48	; 0x30
 8002c84:	46bd      	mov	sp, r7
 8002c86:	bd80      	pop	{r7, pc}
 8002c88:	08003bf4 	.word	0x08003bf4
 8002c8c:	08003bd4 	.word	0x08003bd4

08002c90 <microrl_insert_char>:

//*****************************************************************************

void microrl_insert_char (microrl_t * pThis, int ch)
{
 8002c90:	b580      	push	{r7, lr}
 8002c92:	b082      	sub	sp, #8
 8002c94:	af00      	add	r7, sp, #0
 8002c96:	6078      	str	r0, [r7, #4]
 8002c98:	6039      	str	r1, [r7, #0]
#ifdef _USE_ESC_SEQ
	if (pThis->escape) {
 8002c9a:	687b      	ldr	r3, [r7, #4]
 8002c9c:	785b      	ldrb	r3, [r3, #1]
 8002c9e:	2b00      	cmp	r3, #0
 8002ca0:	d00d      	beq.n	8002cbe <microrl_insert_char+0x2e>
		if (escape_process(pThis, ch))
 8002ca2:	683b      	ldr	r3, [r7, #0]
 8002ca4:	b2db      	uxtb	r3, r3
 8002ca6:	4619      	mov	r1, r3
 8002ca8:	6878      	ldr	r0, [r7, #4]
 8002caa:	f7ff fd5b 	bl	8002764 <escape_process>
 8002cae:	4603      	mov	r3, r0
 8002cb0:	2b00      	cmp	r3, #0
 8002cb2:	f000 81bf 	beq.w	8003034 <microrl_insert_char+0x3a4>
			pThis->escape = 0;
 8002cb6:	687b      	ldr	r3, [r7, #4]
 8002cb8:	2200      	movs	r2, #0
 8002cba:	705a      	strb	r2, [r3, #1]
			break;
		}
#ifdef _USE_ESC_SEQ
	}
#endif
}
 8002cbc:	e1ba      	b.n	8003034 <microrl_insert_char+0x3a4>
	if (pThis->escape) {
		if (escape_process(pThis, ch))
			pThis->escape = 0;
	} else {
#endif
		switch (ch) {
 8002cbe:	683b      	ldr	r3, [r7, #0]
 8002cc0:	3b01      	subs	r3, #1
 8002cc2:	2b7e      	cmp	r3, #126	; 0x7e
 8002cc4:	f200 818d 	bhi.w	8002fe2 <microrl_insert_char+0x352>
 8002cc8:	a201      	add	r2, pc, #4	; (adr r2, 8002cd0 <microrl_insert_char+0x40>)
 8002cca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002cce:	bf00      	nop
 8002cd0:	08002f43 	.word	0x08002f43
 8002cd4:	08002f7b 	.word	0x08002f7b
 8002cd8:	08002fcf 	.word	0x08002fcf
 8002cdc:	08002fe3 	.word	0x08002fe3
 8002ce0:	08002f1f 	.word	0x08002f1f
 8002ce4:	08002f53 	.word	0x08002f53
 8002ce8:	08002fe3 	.word	0x08002fe3
 8002cec:	08002fb3 	.word	0x08002fb3
 8002cf0:	08002ed5 	.word	0x08002ed5
 8002cf4:	08003023 	.word	0x08003023
 8002cf8:	08002f07 	.word	0x08002f07
 8002cfc:	08002fe3 	.word	0x08002fe3
 8002d00:	08002ecd 	.word	0x08002ecd
 8002d04:	08002fa9 	.word	0x08002fa9
 8002d08:	08002fe3 	.word	0x08002fe3
 8002d0c:	08002f9f 	.word	0x08002f9f
 8002d10:	08002fe3 	.word	0x08002fe3
 8002d14:	08002fe3 	.word	0x08002fe3
 8002d18:	08002fe3 	.word	0x08002fe3
 8002d1c:	08002fe3 	.word	0x08002fe3
 8002d20:	08002eeb 	.word	0x08002eeb
 8002d24:	08002fe3 	.word	0x08002fe3
 8002d28:	08002fe3 	.word	0x08002fe3
 8002d2c:	08002fe3 	.word	0x08002fe3
 8002d30:	08002fe3 	.word	0x08002fe3
 8002d34:	08002fe3 	.word	0x08002fe3
 8002d38:	08002edd 	.word	0x08002edd
 8002d3c:	08002fe3 	.word	0x08002fe3
 8002d40:	08002fe3 	.word	0x08002fe3
 8002d44:	08002fe3 	.word	0x08002fe3
 8002d48:	08002fe3 	.word	0x08002fe3
 8002d4c:	08002fe3 	.word	0x08002fe3
 8002d50:	08002fe3 	.word	0x08002fe3
 8002d54:	08002fe3 	.word	0x08002fe3
 8002d58:	08002fe3 	.word	0x08002fe3
 8002d5c:	08002fe3 	.word	0x08002fe3
 8002d60:	08002fe3 	.word	0x08002fe3
 8002d64:	08002fe3 	.word	0x08002fe3
 8002d68:	08002fe3 	.word	0x08002fe3
 8002d6c:	08002fe3 	.word	0x08002fe3
 8002d70:	08002fe3 	.word	0x08002fe3
 8002d74:	08002fe3 	.word	0x08002fe3
 8002d78:	08002fe3 	.word	0x08002fe3
 8002d7c:	08002fe3 	.word	0x08002fe3
 8002d80:	08002fe3 	.word	0x08002fe3
 8002d84:	08002fe3 	.word	0x08002fe3
 8002d88:	08002fe3 	.word	0x08002fe3
 8002d8c:	08002fe3 	.word	0x08002fe3
 8002d90:	08002fe3 	.word	0x08002fe3
 8002d94:	08002fe3 	.word	0x08002fe3
 8002d98:	08002fe3 	.word	0x08002fe3
 8002d9c:	08002fe3 	.word	0x08002fe3
 8002da0:	08002fe3 	.word	0x08002fe3
 8002da4:	08002fe3 	.word	0x08002fe3
 8002da8:	08002fe3 	.word	0x08002fe3
 8002dac:	08002fe3 	.word	0x08002fe3
 8002db0:	08002fe3 	.word	0x08002fe3
 8002db4:	08002fe3 	.word	0x08002fe3
 8002db8:	08002fe3 	.word	0x08002fe3
 8002dbc:	08002fe3 	.word	0x08002fe3
 8002dc0:	08002fe3 	.word	0x08002fe3
 8002dc4:	08002fe3 	.word	0x08002fe3
 8002dc8:	08002fe3 	.word	0x08002fe3
 8002dcc:	08002fe3 	.word	0x08002fe3
 8002dd0:	08002fe3 	.word	0x08002fe3
 8002dd4:	08002fe3 	.word	0x08002fe3
 8002dd8:	08002fe3 	.word	0x08002fe3
 8002ddc:	08002fe3 	.word	0x08002fe3
 8002de0:	08002fe3 	.word	0x08002fe3
 8002de4:	08002fe3 	.word	0x08002fe3
 8002de8:	08002fe3 	.word	0x08002fe3
 8002dec:	08002fe3 	.word	0x08002fe3
 8002df0:	08002fe3 	.word	0x08002fe3
 8002df4:	08002fe3 	.word	0x08002fe3
 8002df8:	08002fe3 	.word	0x08002fe3
 8002dfc:	08002fe3 	.word	0x08002fe3
 8002e00:	08002fe3 	.word	0x08002fe3
 8002e04:	08002fe3 	.word	0x08002fe3
 8002e08:	08002fe3 	.word	0x08002fe3
 8002e0c:	08002fe3 	.word	0x08002fe3
 8002e10:	08002fe3 	.word	0x08002fe3
 8002e14:	08002fe3 	.word	0x08002fe3
 8002e18:	08002fe3 	.word	0x08002fe3
 8002e1c:	08002fe3 	.word	0x08002fe3
 8002e20:	08002fe3 	.word	0x08002fe3
 8002e24:	08002fe3 	.word	0x08002fe3
 8002e28:	08002fe3 	.word	0x08002fe3
 8002e2c:	08002fe3 	.word	0x08002fe3
 8002e30:	08002fe3 	.word	0x08002fe3
 8002e34:	08002fe3 	.word	0x08002fe3
 8002e38:	08002fe3 	.word	0x08002fe3
 8002e3c:	08002fe3 	.word	0x08002fe3
 8002e40:	08002fe3 	.word	0x08002fe3
 8002e44:	08002fe3 	.word	0x08002fe3
 8002e48:	08002fe3 	.word	0x08002fe3
 8002e4c:	08002fe3 	.word	0x08002fe3
 8002e50:	08002fe3 	.word	0x08002fe3
 8002e54:	08002fe3 	.word	0x08002fe3
 8002e58:	08002fe3 	.word	0x08002fe3
 8002e5c:	08002fe3 	.word	0x08002fe3
 8002e60:	08002fe3 	.word	0x08002fe3
 8002e64:	08002fe3 	.word	0x08002fe3
 8002e68:	08002fe3 	.word	0x08002fe3
 8002e6c:	08002fe3 	.word	0x08002fe3
 8002e70:	08002fe3 	.word	0x08002fe3
 8002e74:	08002fe3 	.word	0x08002fe3
 8002e78:	08002fe3 	.word	0x08002fe3
 8002e7c:	08002fe3 	.word	0x08002fe3
 8002e80:	08002fe3 	.word	0x08002fe3
 8002e84:	08002fe3 	.word	0x08002fe3
 8002e88:	08002fe3 	.word	0x08002fe3
 8002e8c:	08002fe3 	.word	0x08002fe3
 8002e90:	08002fe3 	.word	0x08002fe3
 8002e94:	08002fe3 	.word	0x08002fe3
 8002e98:	08002fe3 	.word	0x08002fe3
 8002e9c:	08002fe3 	.word	0x08002fe3
 8002ea0:	08002fe3 	.word	0x08002fe3
 8002ea4:	08002fe3 	.word	0x08002fe3
 8002ea8:	08002fe3 	.word	0x08002fe3
 8002eac:	08002fe3 	.word	0x08002fe3
 8002eb0:	08002fe3 	.word	0x08002fe3
 8002eb4:	08002fe3 	.word	0x08002fe3
 8002eb8:	08002fe3 	.word	0x08002fe3
 8002ebc:	08002fe3 	.word	0x08002fe3
 8002ec0:	08002fe3 	.word	0x08002fe3
 8002ec4:	08002fe3 	.word	0x08002fe3
 8002ec8:	08002fb3 	.word	0x08002fb3
			//-----------------------------------------------------
#ifdef _ENDL_CR
			case KEY_CR:
				new_line_handler(pThis);
 8002ecc:	6878      	ldr	r0, [r7, #4]
 8002ece:	f7ff fe83 	bl	8002bd8 <new_line_handler>
			break;
 8002ed2:	e0af      	b.n	8003034 <microrl_insert_char+0x3a4>
			break;
#endif
			//-----------------------------------------------------
#ifdef _USE_COMPLETE
			case KEY_HT:
				microrl_get_complite (pThis);
 8002ed4:	6878      	ldr	r0, [r7, #4]
 8002ed6:	f7ff fdd1 	bl	8002a7c <microrl_get_complite>
			break;
 8002eda:	e0ab      	b.n	8003034 <microrl_insert_char+0x3a4>
#endif
			//-----------------------------------------------------
			case KEY_ESC:
#ifdef _USE_ESC_SEQ
				pThis->escape = 1;
 8002edc:	687b      	ldr	r3, [r7, #4]
 8002ede:	2201      	movs	r2, #1
 8002ee0:	705a      	strb	r2, [r3, #1]
#endif
			break;
 8002ee2:	e0a7      	b.n	8003034 <microrl_insert_char+0x3a4>
			//-----------------------------------------------------
			case KEY_NAK: // ^U
					while (pThis->cursor > 0) {
					microrl_backspace (pThis);
 8002ee4:	6878      	ldr	r0, [r7, #4]
 8002ee6:	f7ff fd3f 	bl	8002968 <microrl_backspace>
				pThis->escape = 1;
#endif
			break;
			//-----------------------------------------------------
			case KEY_NAK: // ^U
					while (pThis->cursor > 0) {
 8002eea:	687b      	ldr	r3, [r7, #4]
 8002eec:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002ef0:	2b00      	cmp	r3, #0
 8002ef2:	dcf7      	bgt.n	8002ee4 <microrl_insert_char+0x254>
					microrl_backspace (pThis);
				}
				terminal_print_line (pThis, 0, pThis->cursor);
 8002ef4:	687b      	ldr	r3, [r7, #4]
 8002ef6:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002efa:	461a      	mov	r2, r3
 8002efc:	2100      	movs	r1, #0
 8002efe:	6878      	ldr	r0, [r7, #4]
 8002f00:	f7ff fb5a 	bl	80025b8 <terminal_print_line>
			break;
 8002f04:	e096      	b.n	8003034 <microrl_insert_char+0x3a4>
			//-----------------------------------------------------
			case KEY_VT:  // ^K
				pThis->print ("\033[K");
 8002f06:	687b      	ldr	r3, [r7, #4]
 8002f08:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8002f0c:	484b      	ldr	r0, [pc, #300]	; (800303c <microrl_insert_char+0x3ac>)
 8002f0e:	4798      	blx	r3
				pThis->cmdlen = pThis->cursor;
 8002f10:	687b      	ldr	r3, [r7, #4]
 8002f12:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 8002f16:	687b      	ldr	r3, [r7, #4]
 8002f18:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
			break;
 8002f1c:	e08a      	b.n	8003034 <microrl_insert_char+0x3a4>
			//-----------------------------------------------------
			case KEY_ENQ: // ^E
				terminal_move_cursor (pThis, pThis->cmdlen-pThis->cursor);
 8002f1e:	687b      	ldr	r3, [r7, #4]
 8002f20:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 8002f24:	687b      	ldr	r3, [r7, #4]
 8002f26:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002f2a:	1ad3      	subs	r3, r2, r3
 8002f2c:	4619      	mov	r1, r3
 8002f2e:	6878      	ldr	r0, [r7, #4]
 8002f30:	f7ff fabc 	bl	80024ac <terminal_move_cursor>
				pThis->cursor = pThis->cmdlen;
 8002f34:	687b      	ldr	r3, [r7, #4]
 8002f36:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 8002f3a:	687b      	ldr	r3, [r7, #4]
 8002f3c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
			break;
 8002f40:	e078      	b.n	8003034 <microrl_insert_char+0x3a4>
			//-----------------------------------------------------
			case KEY_SOH: // ^A
				terminal_reset_cursor (pThis);
 8002f42:	6878      	ldr	r0, [r7, #4]
 8002f44:	f7ff fb00 	bl	8002548 <terminal_reset_cursor>
				pThis->cursor = 0;
 8002f48:	687b      	ldr	r3, [r7, #4]
 8002f4a:	2200      	movs	r2, #0
 8002f4c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
			break;
 8002f50:	e070      	b.n	8003034 <microrl_insert_char+0x3a4>
			//-----------------------------------------------------
			case KEY_ACK: // ^F
			if (pThis->cursor < pThis->cmdlen) {
 8002f52:	687b      	ldr	r3, [r7, #4]
 8002f54:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 8002f58:	687b      	ldr	r3, [r7, #4]
 8002f5a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8002f5e:	429a      	cmp	r2, r3
 8002f60:	da61      	bge.n	8003026 <microrl_insert_char+0x396>
				terminal_move_cursor (pThis, 1);
 8002f62:	2101      	movs	r1, #1
 8002f64:	6878      	ldr	r0, [r7, #4]
 8002f66:	f7ff faa1 	bl	80024ac <terminal_move_cursor>
				pThis->cursor++;
 8002f6a:	687b      	ldr	r3, [r7, #4]
 8002f6c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002f70:	1c5a      	adds	r2, r3, #1
 8002f72:	687b      	ldr	r3, [r7, #4]
 8002f74:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
			}
			break;
 8002f78:	e055      	b.n	8003026 <microrl_insert_char+0x396>
			//-----------------------------------------------------
			case KEY_STX: // ^B
			if (pThis->cursor) {
 8002f7a:	687b      	ldr	r3, [r7, #4]
 8002f7c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002f80:	2b00      	cmp	r3, #0
 8002f82:	d052      	beq.n	800302a <microrl_insert_char+0x39a>
				terminal_move_cursor (pThis, -1);
 8002f84:	f04f 31ff 	mov.w	r1, #4294967295
 8002f88:	6878      	ldr	r0, [r7, #4]
 8002f8a:	f7ff fa8f 	bl	80024ac <terminal_move_cursor>
				pThis->cursor--;
 8002f8e:	687b      	ldr	r3, [r7, #4]
 8002f90:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002f94:	1e5a      	subs	r2, r3, #1
 8002f96:	687b      	ldr	r3, [r7, #4]
 8002f98:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
			}
			break;
 8002f9c:	e045      	b.n	800302a <microrl_insert_char+0x39a>
			//-----------------------------------------------------
			case KEY_DLE: //^P
#ifdef _USE_HISTORY
			hist_search (pThis, _HIST_UP);
 8002f9e:	2100      	movs	r1, #0
 8002fa0:	6878      	ldr	r0, [r7, #4]
 8002fa2:	f7ff fbb5 	bl	8002710 <hist_search>
#endif
			break;
 8002fa6:	e045      	b.n	8003034 <microrl_insert_char+0x3a4>
			//-----------------------------------------------------
			case KEY_SO: //^N
#ifdef _USE_HISTORY
			hist_search (pThis, _HIST_DOWN);
 8002fa8:	2101      	movs	r1, #1
 8002faa:	6878      	ldr	r0, [r7, #4]
 8002fac:	f7ff fbb0 	bl	8002710 <hist_search>
#endif
			break;
 8002fb0:	e040      	b.n	8003034 <microrl_insert_char+0x3a4>
			//-----------------------------------------------------
			case KEY_DEL: // Backspace
			case KEY_BS: // ^U
				microrl_backspace (pThis);
 8002fb2:	6878      	ldr	r0, [r7, #4]
 8002fb4:	f7ff fcd8 	bl	8002968 <microrl_backspace>
				terminal_print_line (pThis, pThis->cursor, pThis->cursor);
 8002fb8:	687b      	ldr	r3, [r7, #4]
 8002fba:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
 8002fbe:	687b      	ldr	r3, [r7, #4]
 8002fc0:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8002fc4:	461a      	mov	r2, r3
 8002fc6:	6878      	ldr	r0, [r7, #4]
 8002fc8:	f7ff faf6 	bl	80025b8 <terminal_print_line>
			break;
 8002fcc:	e032      	b.n	8003034 <microrl_insert_char+0x3a4>
#ifdef _USE_CTLR_C
			case KEY_ETX:
			if (pThis->sigint != NULL)
 8002fce:	687b      	ldr	r3, [r7, #4]
 8002fd0:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 8002fd4:	2b00      	cmp	r3, #0
 8002fd6:	d02a      	beq.n	800302e <microrl_insert_char+0x39e>
				pThis->sigint();
 8002fd8:	687b      	ldr	r3, [r7, #4]
 8002fda:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 8002fde:	4798      	blx	r3
			break;
 8002fe0:	e025      	b.n	800302e <microrl_insert_char+0x39e>
#endif
			//-----------------------------------------------------
			default:
			if (((ch == ' ') && (pThis->cmdlen == 0)) || IS_CONTROL_CHAR(ch))
 8002fe2:	683b      	ldr	r3, [r7, #0]
 8002fe4:	2b20      	cmp	r3, #32
 8002fe6:	d104      	bne.n	8002ff2 <microrl_insert_char+0x362>
 8002fe8:	687b      	ldr	r3, [r7, #4]
 8002fea:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8002fee:	2b00      	cmp	r3, #0
 8002ff0:	d020      	beq.n	8003034 <microrl_insert_char+0x3a4>
 8002ff2:	683b      	ldr	r3, [r7, #0]
 8002ff4:	2b1f      	cmp	r3, #31
 8002ff6:	dd1d      	ble.n	8003034 <microrl_insert_char+0x3a4>
				break;
			if (microrl_insert_text (pThis, (char*)&ch, 1))
 8002ff8:	463b      	mov	r3, r7
 8002ffa:	2201      	movs	r2, #1
 8002ffc:	4619      	mov	r1, r3
 8002ffe:	6878      	ldr	r0, [r7, #4]
 8003000:	f7ff fc3e 	bl	8002880 <microrl_insert_text>
 8003004:	4603      	mov	r3, r0
 8003006:	2b00      	cmp	r3, #0
 8003008:	d013      	beq.n	8003032 <microrl_insert_char+0x3a2>
				terminal_print_line (pThis, pThis->cursor-1, pThis->cursor);
 800300a:	687b      	ldr	r3, [r7, #4]
 800300c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8003010:	1e59      	subs	r1, r3, #1
 8003012:	687b      	ldr	r3, [r7, #4]
 8003014:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8003018:	461a      	mov	r2, r3
 800301a:	6878      	ldr	r0, [r7, #4]
 800301c:	f7ff facc 	bl	80025b8 <terminal_print_line>
			
			break;
 8003020:	e007      	b.n	8003032 <microrl_insert_char+0x3a2>
#ifdef _ENDL_CR
			case KEY_CR:
				new_line_handler(pThis);
			break;
			case KEY_LF:
			break;
 8003022:	bf00      	nop
 8003024:	e006      	b.n	8003034 <microrl_insert_char+0x3a4>
			case KEY_ACK: // ^F
			if (pThis->cursor < pThis->cmdlen) {
				terminal_move_cursor (pThis, 1);
				pThis->cursor++;
			}
			break;
 8003026:	bf00      	nop
 8003028:	e004      	b.n	8003034 <microrl_insert_char+0x3a4>
			case KEY_STX: // ^B
			if (pThis->cursor) {
				terminal_move_cursor (pThis, -1);
				pThis->cursor--;
			}
			break;
 800302a:	bf00      	nop
 800302c:	e002      	b.n	8003034 <microrl_insert_char+0x3a4>
			break;
#ifdef _USE_CTLR_C
			case KEY_ETX:
			if (pThis->sigint != NULL)
				pThis->sigint();
			break;
 800302e:	bf00      	nop
 8003030:	e000      	b.n	8003034 <microrl_insert_char+0x3a4>
			if (((ch == ' ') && (pThis->cmdlen == 0)) || IS_CONTROL_CHAR(ch))
				break;
			if (microrl_insert_text (pThis, (char*)&ch, 1))
				terminal_print_line (pThis, pThis->cursor-1, pThis->cursor);
			
			break;
 8003032:	bf00      	nop
		}
#ifdef _USE_ESC_SEQ
	}
#endif
}
 8003034:	bf00      	nop
 8003036:	3708      	adds	r7, #8
 8003038:	46bd      	mov	sp, r7
 800303a:	bd80      	pop	{r7, pc}
 800303c:	08003be8 	.word	0x08003be8

08003040 <NVIC_SystemReset>:
/** \brief  System Reset

    This function initiate a system reset request to reset the MCU.
 */
static __INLINE void NVIC_SystemReset(void)
{
 8003040:	b480      	push	{r7}
 8003042:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier. 
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) static __INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
 8003044:	f3bf 8f4f 	dsb	sy
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
 8003048:	4905      	ldr	r1, [pc, #20]	; (8003060 <NVIC_SystemReset+0x20>)
                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800304a:	4b05      	ldr	r3, [pc, #20]	; (8003060 <NVIC_SystemReset+0x20>)
 800304c:	68db      	ldr	r3, [r3, #12]
 800304e:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 8003052:	4b04      	ldr	r3, [pc, #16]	; (8003064 <NVIC_SystemReset+0x24>)
 8003054:	4313      	orrs	r3, r2
 */
static __INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
 8003056:	60cb      	str	r3, [r1, #12]
 8003058:	f3bf 8f4f 	dsb	sy
                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
  __DSB();                                                     /* Ensure completion of memory access */
  while(1);                                                    /* wait until reset */
 800305c:	e7fe      	b.n	800305c <NVIC_SystemReset+0x1c>
 800305e:	bf00      	nop
 8003060:	e000ed00 	.word	0xe000ed00
 8003064:	05fa0004 	.word	0x05fa0004

08003068 <microrl_terminalInit>:
static int prv_TerminalFunc_about(int argc, const char * const * argv);
static int prv_TerminalFunc_help(int argc, const char * const * argv);
static int prv_TerminalFunc_clear(int argc, const char * const * argv);

void microrl_terminalInit()
{
 8003068:	b580      	push	{r7, lr}
 800306a:	af00      	add	r7, sp, #0
	prv_registerBasicTerminalFuncs();
 800306c:	f000 f88e 	bl	800318c <prv_registerBasicTerminalFuncs>

	microrl_init(prl, microrl_sendString);
 8003070:	4b0c      	ldr	r3, [pc, #48]	; (80030a4 <microrl_terminalInit+0x3c>)
 8003072:	681b      	ldr	r3, [r3, #0]
 8003074:	490c      	ldr	r1, [pc, #48]	; (80030a8 <microrl_terminalInit+0x40>)
 8003076:	4618      	mov	r0, r3
 8003078:	f7ff fad8 	bl	800262c <microrl_init>
	microrl_set_execute_callback (prl, prv_execute);
 800307c:	4b09      	ldr	r3, [pc, #36]	; (80030a4 <microrl_terminalInit+0x3c>)
 800307e:	681b      	ldr	r3, [r3, #0]
 8003080:	490a      	ldr	r1, [pc, #40]	; (80030ac <microrl_terminalInit+0x44>)
 8003082:	4618      	mov	r0, r3
 8003084:	f7ff fb28 	bl	80026d8 <microrl_set_execute_callback>

	#ifdef _USE_COMPLETE
	microrl_set_complete_callback (prl, prv_complet);
 8003088:	4b06      	ldr	r3, [pc, #24]	; (80030a4 <microrl_terminalInit+0x3c>)
 800308a:	681b      	ldr	r3, [r3, #0]
 800308c:	4908      	ldr	r1, [pc, #32]	; (80030b0 <microrl_terminalInit+0x48>)
 800308e:	4618      	mov	r0, r3
 8003090:	f7ff fb14 	bl	80026bc <microrl_set_complete_callback>
	#endif

	#ifdef _USE_CTLR_C
	microrl_set_sigint_callback (prl, prv_sigint);
 8003094:	4b03      	ldr	r3, [pc, #12]	; (80030a4 <microrl_terminalInit+0x3c>)
 8003096:	681b      	ldr	r3, [r3, #0]
 8003098:	4906      	ldr	r1, [pc, #24]	; (80030b4 <microrl_terminalInit+0x4c>)
 800309a:	4618      	mov	r0, r3
 800309c:	f7ff fb2a 	bl	80026f4 <microrl_set_sigint_callback>
	#endif
}
 80030a0:	bf00      	nop
 80030a2:	bd80      	pop	{r7, pc}
 80030a4:	20000024 	.word	0x20000024
 80030a8:	080038b1 	.word	0x080038b1
 80030ac:	08003229 	.word	0x08003229
 80030b0:	08003289 	.word	0x08003289
 80030b4:	08003335 	.word	0x08003335

080030b8 <microrl_terminalProcess>:
void microrl_terminalProcess()
{
 80030b8:	b598      	push	{r3, r4, r7, lr}
 80030ba:	af00      	add	r7, sp, #0
	microrl_insert_char (prl, microrl_getChar());
 80030bc:	4b05      	ldr	r3, [pc, #20]	; (80030d4 <microrl_terminalProcess+0x1c>)
 80030be:	681c      	ldr	r4, [r3, #0]
 80030c0:	f000 fc4c 	bl	800395c <UART_GetCharBlocking>
 80030c4:	4603      	mov	r3, r0
 80030c6:	4619      	mov	r1, r3
 80030c8:	4620      	mov	r0, r4
 80030ca:	f7ff fde1 	bl	8002c90 <microrl_insert_char>
}
 80030ce:	bf00      	nop
 80030d0:	bd98      	pop	{r3, r4, r7, pc}
 80030d2:	bf00      	nop
 80030d4:	20000024 	.word	0x20000024

080030d8 <microrl_registerExecuteFunc>:

void microrl_registerExecuteFunc(int (*func)(int, const char* const*), const char* name, const char* help)
{
 80030d8:	b480      	push	{r7}
 80030da:	b085      	sub	sp, #20
 80030dc:	af00      	add	r7, sp, #0
 80030de:	60f8      	str	r0, [r7, #12]
 80030e0:	60b9      	str	r1, [r7, #8]
 80030e2:	607a      	str	r2, [r7, #4]
	assert_param(terminalFuncArrayIndex < microrlNUM_OF_TERMINAL_FUNC);

	terminalFuncArray[terminalFuncArrayIndex].func = func;
 80030e4:	4b14      	ldr	r3, [pc, #80]	; (8003138 <microrl_registerExecuteFunc+0x60>)
 80030e6:	681a      	ldr	r2, [r3, #0]
 80030e8:	4914      	ldr	r1, [pc, #80]	; (800313c <microrl_registerExecuteFunc+0x64>)
 80030ea:	4613      	mov	r3, r2
 80030ec:	005b      	lsls	r3, r3, #1
 80030ee:	4413      	add	r3, r2
 80030f0:	009b      	lsls	r3, r3, #2
 80030f2:	440b      	add	r3, r1
 80030f4:	3308      	adds	r3, #8
 80030f6:	68fa      	ldr	r2, [r7, #12]
 80030f8:	601a      	str	r2, [r3, #0]
	terminalFuncArray[terminalFuncArrayIndex].name = name;
 80030fa:	4b0f      	ldr	r3, [pc, #60]	; (8003138 <microrl_registerExecuteFunc+0x60>)
 80030fc:	681a      	ldr	r2, [r3, #0]
 80030fe:	490f      	ldr	r1, [pc, #60]	; (800313c <microrl_registerExecuteFunc+0x64>)
 8003100:	4613      	mov	r3, r2
 8003102:	005b      	lsls	r3, r3, #1
 8003104:	4413      	add	r3, r2
 8003106:	009b      	lsls	r3, r3, #2
 8003108:	440b      	add	r3, r1
 800310a:	68ba      	ldr	r2, [r7, #8]
 800310c:	601a      	str	r2, [r3, #0]
	terminalFuncArray[terminalFuncArrayIndex].help = help;
 800310e:	4b0a      	ldr	r3, [pc, #40]	; (8003138 <microrl_registerExecuteFunc+0x60>)
 8003110:	681a      	ldr	r2, [r3, #0]
 8003112:	490a      	ldr	r1, [pc, #40]	; (800313c <microrl_registerExecuteFunc+0x64>)
 8003114:	4613      	mov	r3, r2
 8003116:	005b      	lsls	r3, r3, #1
 8003118:	4413      	add	r3, r2
 800311a:	009b      	lsls	r3, r3, #2
 800311c:	440b      	add	r3, r1
 800311e:	3304      	adds	r3, #4
 8003120:	687a      	ldr	r2, [r7, #4]
 8003122:	601a      	str	r2, [r3, #0]

	terminalFuncArrayIndex++;
 8003124:	4b04      	ldr	r3, [pc, #16]	; (8003138 <microrl_registerExecuteFunc+0x60>)
 8003126:	681b      	ldr	r3, [r3, #0]
 8003128:	3301      	adds	r3, #1
 800312a:	4a03      	ldr	r2, [pc, #12]	; (8003138 <microrl_registerExecuteFunc+0x60>)
 800312c:	6013      	str	r3, [r2, #0]
}
 800312e:	bf00      	nop
 8003130:	3714      	adds	r7, #20
 8003132:	46bd      	mov	sp, r7
 8003134:	bc80      	pop	{r7}
 8003136:	4770      	bx	lr
 8003138:	20001954 	.word	0x20001954
 800313c:	20001a58 	.word	0x20001a58

08003140 <microrl_printString>:

void microrl_printString(const char *str)
{
 8003140:	b580      	push	{r7, lr}
 8003142:	b082      	sub	sp, #8
 8003144:	af00      	add	r7, sp, #0
 8003146:	6078      	str	r0, [r7, #4]
	microrl_sendString(str);
 8003148:	6878      	ldr	r0, [r7, #4]
 800314a:	f000 fbb1 	bl	80038b0 <UART_SendString>
}
 800314e:	bf00      	nop
 8003150:	3708      	adds	r7, #8
 8003152:	46bd      	mov	sp, r7
 8003154:	bd80      	pop	{r7, pc}
 8003156:	bf00      	nop

08003158 <microrl_printStringWithEndl>:

void microrl_printStringWithEndl(const char *str)
{
 8003158:	b580      	push	{r7, lr}
 800315a:	b082      	sub	sp, #8
 800315c:	af00      	add	r7, sp, #0
 800315e:	6078      	str	r0, [r7, #4]
	microrl_sendString(str);
 8003160:	6878      	ldr	r0, [r7, #4]
 8003162:	f000 fba5 	bl	80038b0 <UART_SendString>
	microrl_sendString(ENDL);
 8003166:	4803      	ldr	r0, [pc, #12]	; (8003174 <microrl_printStringWithEndl+0x1c>)
 8003168:	f000 fba2 	bl	80038b0 <UART_SendString>
}
 800316c:	bf00      	nop
 800316e:	3708      	adds	r7, #8
 8003170:	46bd      	mov	sp, r7
 8003172:	bd80      	pop	{r7, pc}
 8003174:	08003c0c 	.word	0x08003c0c

08003178 <microrl_printEndl>:

void microrl_printEndl()
{
 8003178:	b580      	push	{r7, lr}
 800317a:	af00      	add	r7, sp, #0
	microrl_sendString(ENDL);
 800317c:	4802      	ldr	r0, [pc, #8]	; (8003188 <microrl_printEndl+0x10>)
 800317e:	f000 fb97 	bl	80038b0 <UART_SendString>
}
 8003182:	bf00      	nop
 8003184:	bd80      	pop	{r7, pc}
 8003186:	bf00      	nop
 8003188:	08003c0c 	.word	0x08003c0c

0800318c <prv_registerBasicTerminalFuncs>:

static void prv_registerBasicTerminalFuncs()
{
 800318c:	b580      	push	{r7, lr}
 800318e:	af00      	add	r7, sp, #0
	microrl_registerExecuteFunc(prv_TerminalFunc_about, "about", NULL);
 8003190:	2200      	movs	r2, #0
 8003192:	4908      	ldr	r1, [pc, #32]	; (80031b4 <prv_registerBasicTerminalFuncs+0x28>)
 8003194:	4808      	ldr	r0, [pc, #32]	; (80031b8 <prv_registerBasicTerminalFuncs+0x2c>)
 8003196:	f7ff ff9f 	bl	80030d8 <microrl_registerExecuteFunc>
	microrl_registerExecuteFunc(prv_TerminalFunc_help, "help", "This function allows to view the available options and their descriptions.");
 800319a:	4a08      	ldr	r2, [pc, #32]	; (80031bc <prv_registerBasicTerminalFuncs+0x30>)
 800319c:	4908      	ldr	r1, [pc, #32]	; (80031c0 <prv_registerBasicTerminalFuncs+0x34>)
 800319e:	4809      	ldr	r0, [pc, #36]	; (80031c4 <prv_registerBasicTerminalFuncs+0x38>)
 80031a0:	f7ff ff9a 	bl	80030d8 <microrl_registerExecuteFunc>
	microrl_registerExecuteFunc(prv_TerminalFunc_clear, "clear", "This function clears the screen.");
 80031a4:	4a08      	ldr	r2, [pc, #32]	; (80031c8 <prv_registerBasicTerminalFuncs+0x3c>)
 80031a6:	4909      	ldr	r1, [pc, #36]	; (80031cc <prv_registerBasicTerminalFuncs+0x40>)
 80031a8:	4809      	ldr	r0, [pc, #36]	; (80031d0 <prv_registerBasicTerminalFuncs+0x44>)
 80031aa:	f7ff ff95 	bl	80030d8 <microrl_registerExecuteFunc>
}
 80031ae:	bf00      	nop
 80031b0:	bd80      	pop	{r7, pc}
 80031b2:	bf00      	nop
 80031b4:	08003c10 	.word	0x08003c10
 80031b8:	08003341 	.word	0x08003341
 80031bc:	08003c18 	.word	0x08003c18
 80031c0:	08003c64 	.word	0x08003c64
 80031c4:	08003369 	.word	0x08003369
 80031c8:	08003c6c 	.word	0x08003c6c
 80031cc:	08003c90 	.word	0x08003c90
 80031d0:	08003479 	.word	0x08003479

080031d4 <prv_getFuncArrayIndex>:

static int prv_getFuncArrayIndex(const char * name)
{
 80031d4:	b580      	push	{r7, lr}
 80031d6:	b084      	sub	sp, #16
 80031d8:	af00      	add	r7, sp, #0
 80031da:	6078      	str	r0, [r7, #4]
	int i;
	for (i = 0; i < terminalFuncArrayIndex; ++i) {
 80031dc:	2300      	movs	r3, #0
 80031de:	60fb      	str	r3, [r7, #12]
 80031e0:	e013      	b.n	800320a <prv_getFuncArrayIndex+0x36>
		if (strcmp(name, terminalFuncArray[i].name) == 0)	{
 80031e2:	490f      	ldr	r1, [pc, #60]	; (8003220 <prv_getFuncArrayIndex+0x4c>)
 80031e4:	68fa      	ldr	r2, [r7, #12]
 80031e6:	4613      	mov	r3, r2
 80031e8:	005b      	lsls	r3, r3, #1
 80031ea:	4413      	add	r3, r2
 80031ec:	009b      	lsls	r3, r3, #2
 80031ee:	440b      	add	r3, r1
 80031f0:	681b      	ldr	r3, [r3, #0]
 80031f2:	4619      	mov	r1, r3
 80031f4:	6878      	ldr	r0, [r7, #4]
 80031f6:	f7fd f815 	bl	8000224 <strcmp>
 80031fa:	4603      	mov	r3, r0
 80031fc:	2b00      	cmp	r3, #0
 80031fe:	d101      	bne.n	8003204 <prv_getFuncArrayIndex+0x30>
			return i;
 8003200:	68fb      	ldr	r3, [r7, #12]
 8003202:	e009      	b.n	8003218 <prv_getFuncArrayIndex+0x44>
}

static int prv_getFuncArrayIndex(const char * name)
{
	int i;
	for (i = 0; i < terminalFuncArrayIndex; ++i) {
 8003204:	68fb      	ldr	r3, [r7, #12]
 8003206:	3301      	adds	r3, #1
 8003208:	60fb      	str	r3, [r7, #12]
 800320a:	4b06      	ldr	r3, [pc, #24]	; (8003224 <prv_getFuncArrayIndex+0x50>)
 800320c:	681b      	ldr	r3, [r3, #0]
 800320e:	68fa      	ldr	r2, [r7, #12]
 8003210:	429a      	cmp	r2, r3
 8003212:	dbe6      	blt.n	80031e2 <prv_getFuncArrayIndex+0xe>
		if (strcmp(name, terminalFuncArray[i].name) == 0)	{
			return i;
		}
	}
	return (-1);
 8003214:	f04f 33ff 	mov.w	r3, #4294967295
}
 8003218:	4618      	mov	r0, r3
 800321a:	3710      	adds	r7, #16
 800321c:	46bd      	mov	sp, r7
 800321e:	bd80      	pop	{r7, pc}
 8003220:	20001a58 	.word	0x20001a58
 8003224:	20001954 	.word	0x20001954

08003228 <prv_execute>:

static int prv_execute(int argc, const char * const * argv)
{
 8003228:	b580      	push	{r7, lr}
 800322a:	b084      	sub	sp, #16
 800322c:	af00      	add	r7, sp, #0
 800322e:	6078      	str	r0, [r7, #4]
 8003230:	6039      	str	r1, [r7, #0]
	int funcIndex;

	funcIndex = prv_getFuncArrayIndex(argv[0]);
 8003232:	683b      	ldr	r3, [r7, #0]
 8003234:	681b      	ldr	r3, [r3, #0]
 8003236:	4618      	mov	r0, r3
 8003238:	f7ff ffcc 	bl	80031d4 <prv_getFuncArrayIndex>
 800323c:	60f8      	str	r0, [r7, #12]
	if (funcIndex == (-1))	{
 800323e:	68fb      	ldr	r3, [r7, #12]
 8003240:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003244:	d105      	bne.n	8003252 <prv_execute+0x2a>
		microrl_printStringWithEndl("Unknown command. Type \"help\" to see available commands");
 8003246:	480e      	ldr	r0, [pc, #56]	; (8003280 <prv_execute+0x58>)
 8003248:	f7ff ff86 	bl	8003158 <microrl_printStringWithEndl>
		return (-1);
 800324c:	f04f 33ff 	mov.w	r3, #4294967295
 8003250:	e012      	b.n	8003278 <prv_execute+0x50>
	}
	return terminalFuncArray[funcIndex].func(--argc, ++argv);
 8003252:	490c      	ldr	r1, [pc, #48]	; (8003284 <prv_execute+0x5c>)
 8003254:	68fa      	ldr	r2, [r7, #12]
 8003256:	4613      	mov	r3, r2
 8003258:	005b      	lsls	r3, r3, #1
 800325a:	4413      	add	r3, r2
 800325c:	009b      	lsls	r3, r3, #2
 800325e:	440b      	add	r3, r1
 8003260:	3308      	adds	r3, #8
 8003262:	681b      	ldr	r3, [r3, #0]
 8003264:	687a      	ldr	r2, [r7, #4]
 8003266:	3a01      	subs	r2, #1
 8003268:	607a      	str	r2, [r7, #4]
 800326a:	683a      	ldr	r2, [r7, #0]
 800326c:	3204      	adds	r2, #4
 800326e:	603a      	str	r2, [r7, #0]
 8003270:	6839      	ldr	r1, [r7, #0]
 8003272:	6878      	ldr	r0, [r7, #4]
 8003274:	4798      	blx	r3
 8003276:	4603      	mov	r3, r0
}
 8003278:	4618      	mov	r0, r3
 800327a:	3710      	adds	r7, #16
 800327c:	46bd      	mov	sp, r7
 800327e:	bd80      	pop	{r7, pc}
 8003280:	08003c98 	.word	0x08003c98
 8003284:	20001a58 	.word	0x20001a58

08003288 <prv_complet>:

#ifdef _USE_COMPLETE
//TODO simplify this. Quite difficult.
static char ** prv_complet (int argc, const char * const * argv)
{
 8003288:	b580      	push	{r7, lr}
 800328a:	b086      	sub	sp, #24
 800328c:	af00      	add	r7, sp, #0
 800328e:	6078      	str	r0, [r7, #4]
 8003290:	6039      	str	r1, [r7, #0]
	static char * compl_world [microrlNUM_OF_TERMINAL_FUNC + 1];
	int j = 0, i;
 8003292:	2300      	movs	r3, #0
 8003294:	617b      	str	r3, [r7, #20]
	compl_world[0] = NULL;
 8003296:	4b24      	ldr	r3, [pc, #144]	; (8003328 <prv_complet+0xa0>)
 8003298:	2200      	movs	r2, #0
 800329a:	601a      	str	r2, [r3, #0]
	if (argc == 1)	{
 800329c:	687b      	ldr	r3, [r7, #4]
 800329e:	2b01      	cmp	r3, #1
 80032a0:	d137      	bne.n	8003312 <prv_complet+0x8a>
		char * bit = (char*)argv [argc-1];
 80032a2:	687b      	ldr	r3, [r7, #4]
 80032a4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80032a8:	3b01      	subs	r3, #1
 80032aa:	009b      	lsls	r3, r3, #2
 80032ac:	683a      	ldr	r2, [r7, #0]
 80032ae:	4413      	add	r3, r2
 80032b0:	681b      	ldr	r3, [r3, #0]
 80032b2:	60fb      	str	r3, [r7, #12]
		for (i = 0; i < terminalFuncArrayIndex; i++) {
 80032b4:	2300      	movs	r3, #0
 80032b6:	613b      	str	r3, [r7, #16]
 80032b8:	e026      	b.n	8003308 <prv_complet+0x80>
			if (strstr(terminalFuncArray[i].name, bit) == terminalFuncArray[i].name) {
 80032ba:	491c      	ldr	r1, [pc, #112]	; (800332c <prv_complet+0xa4>)
 80032bc:	693a      	ldr	r2, [r7, #16]
 80032be:	4613      	mov	r3, r2
 80032c0:	005b      	lsls	r3, r3, #1
 80032c2:	4413      	add	r3, r2
 80032c4:	009b      	lsls	r3, r3, #2
 80032c6:	440b      	add	r3, r1
 80032c8:	681b      	ldr	r3, [r3, #0]
 80032ca:	68f9      	ldr	r1, [r7, #12]
 80032cc:	4618      	mov	r0, r3
 80032ce:	f000 fc49 	bl	8003b64 <strstr>
 80032d2:	4916      	ldr	r1, [pc, #88]	; (800332c <prv_complet+0xa4>)
 80032d4:	693a      	ldr	r2, [r7, #16]
 80032d6:	4613      	mov	r3, r2
 80032d8:	005b      	lsls	r3, r3, #1
 80032da:	4413      	add	r3, r2
 80032dc:	009b      	lsls	r3, r3, #2
 80032de:	440b      	add	r3, r1
 80032e0:	681b      	ldr	r3, [r3, #0]
 80032e2:	4298      	cmp	r0, r3
 80032e4:	d10d      	bne.n	8003302 <prv_complet+0x7a>
				compl_world [j++] = (char*)(terminalFuncArray[i].name);
 80032e6:	697a      	ldr	r2, [r7, #20]
 80032e8:	1c53      	adds	r3, r2, #1
 80032ea:	617b      	str	r3, [r7, #20]
 80032ec:	480f      	ldr	r0, [pc, #60]	; (800332c <prv_complet+0xa4>)
 80032ee:	6939      	ldr	r1, [r7, #16]
 80032f0:	460b      	mov	r3, r1
 80032f2:	005b      	lsls	r3, r3, #1
 80032f4:	440b      	add	r3, r1
 80032f6:	009b      	lsls	r3, r3, #2
 80032f8:	4403      	add	r3, r0
 80032fa:	681b      	ldr	r3, [r3, #0]
 80032fc:	490a      	ldr	r1, [pc, #40]	; (8003328 <prv_complet+0xa0>)
 80032fe:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	static char * compl_world [microrlNUM_OF_TERMINAL_FUNC + 1];
	int j = 0, i;
	compl_world[0] = NULL;
	if (argc == 1)	{
		char * bit = (char*)argv [argc-1];
		for (i = 0; i < terminalFuncArrayIndex; i++) {
 8003302:	693b      	ldr	r3, [r7, #16]
 8003304:	3301      	adds	r3, #1
 8003306:	613b      	str	r3, [r7, #16]
 8003308:	4b09      	ldr	r3, [pc, #36]	; (8003330 <prv_complet+0xa8>)
 800330a:	681b      	ldr	r3, [r3, #0]
 800330c:	693a      	ldr	r2, [r7, #16]
 800330e:	429a      	cmp	r2, r3
 8003310:	dbd3      	blt.n	80032ba <prv_complet+0x32>
			if (strstr(terminalFuncArray[i].name, bit) == terminalFuncArray[i].name) {
				compl_world [j++] = (char*)(terminalFuncArray[i].name);
			}
		}
	}
	compl_world [j] = NULL;
 8003312:	4a05      	ldr	r2, [pc, #20]	; (8003328 <prv_complet+0xa0>)
 8003314:	697b      	ldr	r3, [r7, #20]
 8003316:	2100      	movs	r1, #0
 8003318:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	return compl_world;
 800331c:	4b02      	ldr	r3, [pc, #8]	; (8003328 <prv_complet+0xa0>)
}
 800331e:	4618      	mov	r0, r3
 8003320:	3718      	adds	r7, #24
 8003322:	46bd      	mov	sp, r7
 8003324:	bd80      	pop	{r7, pc}
 8003326:	bf00      	nop
 8003328:	20001958 	.word	0x20001958
 800332c:	20001a58 	.word	0x20001a58
 8003330:	20001954 	.word	0x20001954

08003334 <prv_sigint>:
#endif

#ifdef _USE_CTLR_C
static void prv_sigint (void)
{
 8003334:	b580      	push	{r7, lr}
 8003336:	af00      	add	r7, sp, #0
	NVIC_SystemReset();
 8003338:	f7ff fe82 	bl	8003040 <NVIC_SystemReset>
}
 800333c:	bf00      	nop
 800333e:	bd80      	pop	{r7, pc}

08003340 <prv_TerminalFunc_about>:
#endif

static int prv_TerminalFunc_about(int argc, const char * const * argv)
{
 8003340:	b580      	push	{r7, lr}
 8003342:	b082      	sub	sp, #8
 8003344:	af00      	add	r7, sp, #0
 8003346:	6078      	str	r0, [r7, #4]
 8003348:	6039      	str	r1, [r7, #0]
	microrl_printString("Microrl based terminal. Ver. ");
 800334a:	4805      	ldr	r0, [pc, #20]	; (8003360 <prv_TerminalFunc_about+0x20>)
 800334c:	f7ff fef8 	bl	8003140 <microrl_printString>
	microrl_printStringWithEndl(MICRORL_LIB_VER);
 8003350:	4804      	ldr	r0, [pc, #16]	; (8003364 <prv_TerminalFunc_about+0x24>)
 8003352:	f7ff ff01 	bl	8003158 <microrl_printStringWithEndl>
	return 0;
 8003356:	2300      	movs	r3, #0
}
 8003358:	4618      	mov	r0, r3
 800335a:	3708      	adds	r7, #8
 800335c:	46bd      	mov	sp, r7
 800335e:	bd80      	pop	{r7, pc}
 8003360:	08003cd0 	.word	0x08003cd0
 8003364:	08003cf0 	.word	0x08003cf0

08003368 <prv_TerminalFunc_help>:

static int prv_TerminalFunc_help(int argc, const char * const * argv)
{
 8003368:	b580      	push	{r7, lr}
 800336a:	b082      	sub	sp, #8
 800336c:	af00      	add	r7, sp, #0
 800336e:	6078      	str	r0, [r7, #4]
 8003370:	6039      	str	r1, [r7, #0]
	switch (argc)
 8003372:	687b      	ldr	r3, [r7, #4]
 8003374:	2b00      	cmp	r3, #0
 8003376:	d002      	beq.n	800337e <prv_TerminalFunc_help+0x16>
 8003378:	2b01      	cmp	r3, #1
 800337a:	d003      	beq.n	8003384 <prv_TerminalFunc_help+0x1c>
 800337c:	e008      	b.n	8003390 <prv_TerminalFunc_help+0x28>
	{
	case 0:
		prv_printMainHelp();
 800337e:	f000 f813 	bl	80033a8 <prv_printMainHelp>
		break;
 8003382:	e009      	b.n	8003398 <prv_TerminalFunc_help+0x30>
	case 1:
		prv_printTerminalFuncHelp(argv[0]);
 8003384:	683b      	ldr	r3, [r7, #0]
 8003386:	681b      	ldr	r3, [r3, #0]
 8003388:	4618      	mov	r0, r3
 800338a:	f000 f841 	bl	8003410 <prv_printTerminalFuncHelp>
		break;
 800338e:	e003      	b.n	8003398 <prv_TerminalFunc_help+0x30>
	default:
		microrl_printStringWithEndl("Help is available only for high-level commands. It isn't available for subcommands.");
 8003390:	4804      	ldr	r0, [pc, #16]	; (80033a4 <prv_TerminalFunc_help+0x3c>)
 8003392:	f7ff fee1 	bl	8003158 <microrl_printStringWithEndl>
		break;
 8003396:	bf00      	nop
	}
	return 0;
 8003398:	2300      	movs	r3, #0
}
 800339a:	4618      	mov	r0, r3
 800339c:	3708      	adds	r7, #8
 800339e:	46bd      	mov	sp, r7
 80033a0:	bd80      	pop	{r7, pc}
 80033a2:	bf00      	nop
 80033a4:	08003cf8 	.word	0x08003cf8

080033a8 <prv_printMainHelp>:

static void prv_printMainHelp()
{
 80033a8:	b580      	push	{r7, lr}
 80033aa:	b082      	sub	sp, #8
 80033ac:	af00      	add	r7, sp, #0
	microrl_printStringWithEndl("type \"help\" <command> for more details.");
 80033ae:	4813      	ldr	r0, [pc, #76]	; (80033fc <prv_printMainHelp+0x54>)
 80033b0:	f7ff fed2 	bl	8003158 <microrl_printStringWithEndl>
	microrl_printEndl();
 80033b4:	f7ff fee0 	bl	8003178 <microrl_printEndl>
	microrl_printStringWithEndl("Available commands:");
 80033b8:	4811      	ldr	r0, [pc, #68]	; (8003400 <prv_printMainHelp+0x58>)
 80033ba:	f7ff fecd 	bl	8003158 <microrl_printStringWithEndl>
	int i;
	for (i = 0; i < terminalFuncArrayIndex; ++i) {
 80033be:	2300      	movs	r3, #0
 80033c0:	607b      	str	r3, [r7, #4]
 80033c2:	e010      	b.n	80033e6 <prv_printMainHelp+0x3e>
		microrl_printString(terminalFuncArray[i].name);
 80033c4:	490f      	ldr	r1, [pc, #60]	; (8003404 <prv_printMainHelp+0x5c>)
 80033c6:	687a      	ldr	r2, [r7, #4]
 80033c8:	4613      	mov	r3, r2
 80033ca:	005b      	lsls	r3, r3, #1
 80033cc:	4413      	add	r3, r2
 80033ce:	009b      	lsls	r3, r3, #2
 80033d0:	440b      	add	r3, r1
 80033d2:	681b      	ldr	r3, [r3, #0]
 80033d4:	4618      	mov	r0, r3
 80033d6:	f7ff feb3 	bl	8003140 <microrl_printString>
		microrl_printString(" ");
 80033da:	480b      	ldr	r0, [pc, #44]	; (8003408 <prv_printMainHelp+0x60>)
 80033dc:	f7ff feb0 	bl	8003140 <microrl_printString>
{
	microrl_printStringWithEndl("type \"help\" <command> for more details.");
	microrl_printEndl();
	microrl_printStringWithEndl("Available commands:");
	int i;
	for (i = 0; i < terminalFuncArrayIndex; ++i) {
 80033e0:	687b      	ldr	r3, [r7, #4]
 80033e2:	3301      	adds	r3, #1
 80033e4:	607b      	str	r3, [r7, #4]
 80033e6:	4b09      	ldr	r3, [pc, #36]	; (800340c <prv_printMainHelp+0x64>)
 80033e8:	681b      	ldr	r3, [r3, #0]
 80033ea:	687a      	ldr	r2, [r7, #4]
 80033ec:	429a      	cmp	r2, r3
 80033ee:	dbe9      	blt.n	80033c4 <prv_printMainHelp+0x1c>
		microrl_printString(terminalFuncArray[i].name);
		microrl_printString(" ");
	}
	microrl_printEndl();
 80033f0:	f7ff fec2 	bl	8003178 <microrl_printEndl>
}
 80033f4:	bf00      	nop
 80033f6:	3708      	adds	r7, #8
 80033f8:	46bd      	mov	sp, r7
 80033fa:	bd80      	pop	{r7, pc}
 80033fc:	08003d4c 	.word	0x08003d4c
 8003400:	08003d74 	.word	0x08003d74
 8003404:	20001a58 	.word	0x20001a58
 8003408:	08003d88 	.word	0x08003d88
 800340c:	20001954 	.word	0x20001954

08003410 <prv_printTerminalFuncHelp>:

static void prv_printTerminalFuncHelp(const char *name)
{
 8003410:	b580      	push	{r7, lr}
 8003412:	b084      	sub	sp, #16
 8003414:	af00      	add	r7, sp, #0
 8003416:	6078      	str	r0, [r7, #4]
	int funcIndex = prv_getFuncArrayIndex(name);
 8003418:	6878      	ldr	r0, [r7, #4]
 800341a:	f7ff fedb 	bl	80031d4 <prv_getFuncArrayIndex>
 800341e:	60f8      	str	r0, [r7, #12]
	if (funcIndex == (-1))	{
 8003420:	68fb      	ldr	r3, [r7, #12]
 8003422:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003426:	d103      	bne.n	8003430 <prv_printTerminalFuncHelp+0x20>
		microrl_printStringWithEndl("Command not found.");
 8003428:	4810      	ldr	r0, [pc, #64]	; (800346c <prv_printTerminalFuncHelp+0x5c>)
 800342a:	f7ff fe95 	bl	8003158 <microrl_printStringWithEndl>
		return;
 800342e:	e01a      	b.n	8003466 <prv_printTerminalFuncHelp+0x56>
	}
	if (terminalFuncArray[funcIndex].help != NULL)	{
 8003430:	490f      	ldr	r1, [pc, #60]	; (8003470 <prv_printTerminalFuncHelp+0x60>)
 8003432:	68fa      	ldr	r2, [r7, #12]
 8003434:	4613      	mov	r3, r2
 8003436:	005b      	lsls	r3, r3, #1
 8003438:	4413      	add	r3, r2
 800343a:	009b      	lsls	r3, r3, #2
 800343c:	440b      	add	r3, r1
 800343e:	3304      	adds	r3, #4
 8003440:	681b      	ldr	r3, [r3, #0]
 8003442:	2b00      	cmp	r3, #0
 8003444:	d00c      	beq.n	8003460 <prv_printTerminalFuncHelp+0x50>
		microrl_printStringWithEndl(terminalFuncArray[funcIndex].help);
 8003446:	490a      	ldr	r1, [pc, #40]	; (8003470 <prv_printTerminalFuncHelp+0x60>)
 8003448:	68fa      	ldr	r2, [r7, #12]
 800344a:	4613      	mov	r3, r2
 800344c:	005b      	lsls	r3, r3, #1
 800344e:	4413      	add	r3, r2
 8003450:	009b      	lsls	r3, r3, #2
 8003452:	440b      	add	r3, r1
 8003454:	3304      	adds	r3, #4
 8003456:	681b      	ldr	r3, [r3, #0]
 8003458:	4618      	mov	r0, r3
 800345a:	f7ff fe7d 	bl	8003158 <microrl_printStringWithEndl>
 800345e:	e002      	b.n	8003466 <prv_printTerminalFuncHelp+0x56>
	}
	else	{
		microrl_printStringWithEndl("Help is not available for this command.");
 8003460:	4804      	ldr	r0, [pc, #16]	; (8003474 <prv_printTerminalFuncHelp+0x64>)
 8003462:	f7ff fe79 	bl	8003158 <microrl_printStringWithEndl>
	}
}
 8003466:	3710      	adds	r7, #16
 8003468:	46bd      	mov	sp, r7
 800346a:	bd80      	pop	{r7, pc}
 800346c:	08003d8c 	.word	0x08003d8c
 8003470:	20001a58 	.word	0x20001a58
 8003474:	08003da0 	.word	0x08003da0

08003478 <prv_TerminalFunc_clear>:

static int prv_TerminalFunc_clear(int argc, const char * const * argv)
{
 8003478:	b580      	push	{r7, lr}
 800347a:	b082      	sub	sp, #8
 800347c:	af00      	add	r7, sp, #0
 800347e:	6078      	str	r0, [r7, #4]
 8003480:	6039      	str	r1, [r7, #0]
	microrl_printString ("\033[2J");    // ESC seq for clear entire screen
 8003482:	4805      	ldr	r0, [pc, #20]	; (8003498 <prv_TerminalFunc_clear+0x20>)
 8003484:	f7ff fe5c 	bl	8003140 <microrl_printString>
	microrl_printString ("\033[H");     // ESC seq for move cursor at left-top corner
 8003488:	4804      	ldr	r0, [pc, #16]	; (800349c <prv_TerminalFunc_clear+0x24>)
 800348a:	f7ff fe59 	bl	8003140 <microrl_printString>
	return 0;
 800348e:	2300      	movs	r3, #0
}
 8003490:	4618      	mov	r0, r3
 8003492:	3708      	adds	r7, #8
 8003494:	46bd      	mov	sp, r7
 8003496:	bd80      	pop	{r7, pc}
 8003498:	08003dc8 	.word	0x08003dc8
 800349c:	08003dd0 	.word	0x08003dd0

080034a0 <vBlinker>:

void vBlinker(void *pvParameters);
void microrl_run(void *pvParameters);

void vBlinker(void *pvParameters)
{
 80034a0:	b580      	push	{r7, lr}
 80034a2:	b084      	sub	sp, #16
 80034a4:	af00      	add	r7, sp, #0
 80034a6:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef gpio;

	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
 80034a8:	2310      	movs	r3, #16
 80034aa:	73fb      	strb	r3, [r7, #15]
	gpio.GPIO_Pin = ((ledTiming_t*)pvParameters)->pin;
 80034ac:	687b      	ldr	r3, [r7, #4]
 80034ae:	891b      	ldrh	r3, [r3, #8]
 80034b0:	81bb      	strh	r3, [r7, #12]
	gpio.GPIO_Speed = GPIO_Speed_50MHz;
 80034b2:	2303      	movs	r3, #3
 80034b4:	73bb      	strb	r3, [r7, #14]
	GPIO_Init(((ledTiming_t*)pvParameters)->gpio, &gpio);
 80034b6:	687b      	ldr	r3, [r7, #4]
 80034b8:	685b      	ldr	r3, [r3, #4]
 80034ba:	f107 020c 	add.w	r2, r7, #12
 80034be:	4611      	mov	r1, r2
 80034c0:	4618      	mov	r0, r3
 80034c2:	f7fe fa05 	bl	80018d0 <GPIO_Init>

	while (1) {
		GPIO_WriteBit(((ledTiming_t*)pvParameters)->gpio, ((ledTiming_t*)pvParameters)->pin, Bit_RESET);
 80034c6:	687b      	ldr	r3, [r7, #4]
 80034c8:	6858      	ldr	r0, [r3, #4]
 80034ca:	687b      	ldr	r3, [r7, #4]
 80034cc:	891b      	ldrh	r3, [r3, #8]
 80034ce:	2200      	movs	r2, #0
 80034d0:	4619      	mov	r1, r3
 80034d2:	f7fe fab9 	bl	8001a48 <GPIO_WriteBit>
		vTaskDelay(((ledTiming_t*)pvParameters)->timeOff);
 80034d6:	687b      	ldr	r3, [r7, #4]
 80034d8:	885b      	ldrh	r3, [r3, #2]
 80034da:	4618      	mov	r0, r3
 80034dc:	f7fd fd1a 	bl	8000f14 <vTaskDelay>
		GPIO_WriteBit(((ledTiming_t*)pvParameters)->gpio, ((ledTiming_t*)pvParameters)->pin, Bit_SET);
 80034e0:	687b      	ldr	r3, [r7, #4]
 80034e2:	6858      	ldr	r0, [r3, #4]
 80034e4:	687b      	ldr	r3, [r7, #4]
 80034e6:	891b      	ldrh	r3, [r3, #8]
 80034e8:	2201      	movs	r2, #1
 80034ea:	4619      	mov	r1, r3
 80034ec:	f7fe faac 	bl	8001a48 <GPIO_WriteBit>
		vTaskDelay(((ledTiming_t*)pvParameters)->timeOn);
 80034f0:	687b      	ldr	r3, [r7, #4]
 80034f2:	881b      	ldrh	r3, [r3, #0]
 80034f4:	4618      	mov	r0, r3
 80034f6:	f7fd fd0d 	bl	8000f14 <vTaskDelay>
	}
 80034fa:	e7e4      	b.n	80034c6 <vBlinker+0x26>

080034fc <microrl_run>:
}

void microrl_run(void *pvParameters)
{
 80034fc:	b580      	push	{r7, lr}
 80034fe:	b082      	sub	sp, #8
 8003500:	af00      	add	r7, sp, #0
 8003502:	6078      	str	r0, [r7, #4]
	microrl_terminalInit();
 8003504:	f7ff fdb0 	bl	8003068 <microrl_terminalInit>
	while(1)
	{
		microrl_terminalProcess();
 8003508:	f7ff fdd6 	bl	80030b8 <microrl_terminalProcess>
	}
 800350c:	e7fc      	b.n	8003508 <microrl_run+0xc>
 800350e:	bf00      	nop

08003510 <main>:
}

int main(void)
{
 8003510:	b580      	push	{r7, lr}
 8003512:	b086      	sub	sp, #24
 8003514:	af04      	add	r7, sp, #16
	UART_Init();
 8003516:	f000 f963 	bl	80037e0 <UART_Init>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
 800351a:	2101      	movs	r1, #1
 800351c:	2010      	movs	r0, #16
 800351e:	f7fe fb5b 	bl	8001bd8 <RCC_APB2PeriphClockCmd>

	ledTiming_t* ptrLedTiming = pvPortMalloc(sizeof(ledTiming_t));
 8003522:	200c      	movs	r0, #12
 8003524:	f7fc ff8e 	bl	8000444 <pvPortMalloc>
 8003528:	6078      	str	r0, [r7, #4]
	ptrLedTiming->gpio = GPIOC;
 800352a:	687b      	ldr	r3, [r7, #4]
 800352c:	4a28      	ldr	r2, [pc, #160]	; (80035d0 <main+0xc0>)
 800352e:	605a      	str	r2, [r3, #4]
	ptrLedTiming->pin = GPIO_Pin_13;
 8003530:	687b      	ldr	r3, [r7, #4]
 8003532:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8003536:	811a      	strh	r2, [r3, #8]
	ptrLedTiming->timeOff = 480;
 8003538:	687b      	ldr	r3, [r7, #4]
 800353a:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 800353e:	805a      	strh	r2, [r3, #2]
	ptrLedTiming->timeOn = 20;
 8003540:	687b      	ldr	r3, [r7, #4]
 8003542:	2214      	movs	r2, #20
 8003544:	801a      	strh	r2, [r3, #0]

	xTaskCreate(	vBlinker,
 8003546:	2300      	movs	r3, #0
 8003548:	9303      	str	r3, [sp, #12]
 800354a:	2300      	movs	r3, #0
 800354c:	9302      	str	r3, [sp, #8]
 800354e:	2300      	movs	r3, #0
 8003550:	9301      	str	r3, [sp, #4]
 8003552:	2301      	movs	r3, #1
 8003554:	9300      	str	r3, [sp, #0]
 8003556:	687b      	ldr	r3, [r7, #4]
 8003558:	2280      	movs	r2, #128	; 0x80
 800355a:	491e      	ldr	r1, [pc, #120]	; (80035d4 <main+0xc4>)
 800355c:	481e      	ldr	r0, [pc, #120]	; (80035d8 <main+0xc8>)
 800355e:	f7fd fc3d 	bl	8000ddc <xTaskGenericCreate>
					configMINIMAL_STACK_SIZE,
					(void*)ptrLedTiming,
					tskIDLE_PRIORITY + 1,
					NULL);

	ledTiming_t* ptrLedTiming2 = pvPortMalloc(sizeof(ledTiming_t));
 8003562:	200c      	movs	r0, #12
 8003564:	f7fc ff6e 	bl	8000444 <pvPortMalloc>
 8003568:	6038      	str	r0, [r7, #0]
	ptrLedTiming2->gpio = GPIOC;
 800356a:	683b      	ldr	r3, [r7, #0]
 800356c:	4a18      	ldr	r2, [pc, #96]	; (80035d0 <main+0xc0>)
 800356e:	605a      	str	r2, [r3, #4]
	ptrLedTiming2->pin = GPIO_Pin_14;
 8003570:	683b      	ldr	r3, [r7, #0]
 8003572:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8003576:	811a      	strh	r2, [r3, #8]
	ptrLedTiming2->timeOff = 460;
 8003578:	683b      	ldr	r3, [r7, #0]
 800357a:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
 800357e:	805a      	strh	r2, [r3, #2]
	ptrLedTiming2->timeOn = 20;
 8003580:	683b      	ldr	r3, [r7, #0]
 8003582:	2214      	movs	r2, #20
 8003584:	801a      	strh	r2, [r3, #0]

	xTaskCreate(	vBlinker,"Blinker2",
 8003586:	2300      	movs	r3, #0
 8003588:	9303      	str	r3, [sp, #12]
 800358a:	2300      	movs	r3, #0
 800358c:	9302      	str	r3, [sp, #8]
 800358e:	2300      	movs	r3, #0
 8003590:	9301      	str	r3, [sp, #4]
 8003592:	2301      	movs	r3, #1
 8003594:	9300      	str	r3, [sp, #0]
 8003596:	683b      	ldr	r3, [r7, #0]
 8003598:	2280      	movs	r2, #128	; 0x80
 800359a:	4910      	ldr	r1, [pc, #64]	; (80035dc <main+0xcc>)
 800359c:	480e      	ldr	r0, [pc, #56]	; (80035d8 <main+0xc8>)
 800359e:	f7fd fc1d 	bl	8000ddc <xTaskGenericCreate>
					configMINIMAL_STACK_SIZE,
					(void*)ptrLedTiming2,
					tskIDLE_PRIORITY + 1,
					NULL);

	xTaskCreate(	microrl_run,"microrl",
 80035a2:	2300      	movs	r3, #0
 80035a4:	9303      	str	r3, [sp, #12]
 80035a6:	2300      	movs	r3, #0
 80035a8:	9302      	str	r3, [sp, #8]
 80035aa:	2300      	movs	r3, #0
 80035ac:	9301      	str	r3, [sp, #4]
 80035ae:	2301      	movs	r3, #1
 80035b0:	9300      	str	r3, [sp, #0]
 80035b2:	2300      	movs	r3, #0
 80035b4:	f44f 7296 	mov.w	r2, #300	; 0x12c
 80035b8:	4909      	ldr	r1, [pc, #36]	; (80035e0 <main+0xd0>)
 80035ba:	480a      	ldr	r0, [pc, #40]	; (80035e4 <main+0xd4>)
 80035bc:	f7fd fc0e 	bl	8000ddc <xTaskGenericCreate>
					300,
					NULL,
					tskIDLE_PRIORITY + 1,
					NULL);

	vTaskStartScheduler();
 80035c0:	f7fd fcd2 	bl	8000f68 <vTaskStartScheduler>
	return 0;
 80035c4:	2300      	movs	r3, #0
}
 80035c6:	4618      	mov	r0, r3
 80035c8:	3708      	adds	r7, #8
 80035ca:	46bd      	mov	sp, r7
 80035cc:	bd80      	pop	{r7, pc}
 80035ce:	bf00      	nop
 80035d0:	40011000 	.word	0x40011000
 80035d4:	08003dd4 	.word	0x08003dd4
 80035d8:	080034a1 	.word	0x080034a1
 80035dc:	08003ddc 	.word	0x08003ddc
 80035e0:	08003de8 	.word	0x08003de8
 80035e4:	080034fd 	.word	0x080034fd

080035e8 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80035e8:	f8df d034 	ldr.w	sp, [pc, #52]	; 8003620 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 80035ec:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80035ee:	e003      	b.n	80035f8 <LoopCopyDataInit>

080035f0 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80035f0:	4b0c      	ldr	r3, [pc, #48]	; (8003624 <LoopFillZerobss+0x18>)
	ldr	r3, [r3, r1]
 80035f2:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80035f4:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80035f6:	3104      	adds	r1, #4

080035f8 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80035f8:	480b      	ldr	r0, [pc, #44]	; (8003628 <LoopFillZerobss+0x1c>)
	ldr	r3, =_edata
 80035fa:	4b0c      	ldr	r3, [pc, #48]	; (800362c <LoopFillZerobss+0x20>)
	adds	r2, r0, r1
 80035fc:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80035fe:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8003600:	d3f6      	bcc.n	80035f0 <CopyDataInit>
	ldr	r2, =_sbss
 8003602:	4a0b      	ldr	r2, [pc, #44]	; (8003630 <LoopFillZerobss+0x24>)
	b	LoopFillZerobss
 8003604:	e002      	b.n	800360c <LoopFillZerobss>

08003606 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8003606:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8003608:	f842 3b04 	str.w	r3, [r2], #4

0800360c <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 800360c:	4b09      	ldr	r3, [pc, #36]	; (8003634 <LoopFillZerobss+0x28>)
	cmp	r2, r3
 800360e:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8003610:	d3f9      	bcc.n	8003606 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8003612:	f000 f813 	bl	800363c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8003616:	f000 fa51 	bl	8003abc <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800361a:	f7ff ff79 	bl	8003510 <main>
	bx	lr
 800361e:	4770      	bx	lr

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8003620:	20010000 	.word	0x20010000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8003624:	08003df8 	.word	0x08003df8
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 8003628:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 800362c:	20000028 	.word	0x20000028
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8003630:	20000028 	.word	0x20000028
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 8003634:	20001be8 	.word	0x20001be8

08003638 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8003638:	e7fe      	b.n	8003638 <ADC1_2_IRQHandler>
	...

0800363c <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 800363c:	b580      	push	{r7, lr}
 800363e:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003640:	4a15      	ldr	r2, [pc, #84]	; (8003698 <SystemInit+0x5c>)
 8003642:	4b15      	ldr	r3, [pc, #84]	; (8003698 <SystemInit+0x5c>)
 8003644:	681b      	ldr	r3, [r3, #0]
 8003646:	f043 0301 	orr.w	r3, r3, #1
 800364a:	6013      	str	r3, [r2, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 800364c:	4912      	ldr	r1, [pc, #72]	; (8003698 <SystemInit+0x5c>)
 800364e:	4b12      	ldr	r3, [pc, #72]	; (8003698 <SystemInit+0x5c>)
 8003650:	685a      	ldr	r2, [r3, #4]
 8003652:	4b12      	ldr	r3, [pc, #72]	; (800369c <SystemInit+0x60>)
 8003654:	4013      	ands	r3, r2
 8003656:	604b      	str	r3, [r1, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003658:	4a0f      	ldr	r2, [pc, #60]	; (8003698 <SystemInit+0x5c>)
 800365a:	4b0f      	ldr	r3, [pc, #60]	; (8003698 <SystemInit+0x5c>)
 800365c:	681b      	ldr	r3, [r3, #0]
 800365e:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 8003662:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003666:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003668:	4a0b      	ldr	r2, [pc, #44]	; (8003698 <SystemInit+0x5c>)
 800366a:	4b0b      	ldr	r3, [pc, #44]	; (8003698 <SystemInit+0x5c>)
 800366c:	681b      	ldr	r3, [r3, #0]
 800366e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003672:	6013      	str	r3, [r2, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8003674:	4a08      	ldr	r2, [pc, #32]	; (8003698 <SystemInit+0x5c>)
 8003676:	4b08      	ldr	r3, [pc, #32]	; (8003698 <SystemInit+0x5c>)
 8003678:	685b      	ldr	r3, [r3, #4]
 800367a:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
 800367e:	6053      	str	r3, [r2, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8003680:	4b05      	ldr	r3, [pc, #20]	; (8003698 <SystemInit+0x5c>)
 8003682:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8003686:	609a      	str	r2, [r3, #8]
  #endif /* DATA_IN_ExtSRAM */
#endif 

  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
  /* Configure the Flash Latency cycles and enable prefetch buffer */
  SetSysClock();
 8003688:	f000 f80c 	bl	80036a4 <SetSysClock>

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 800368c:	4b04      	ldr	r3, [pc, #16]	; (80036a0 <SystemInit+0x64>)
 800368e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8003692:	609a      	str	r2, [r3, #8]
#endif 
}
 8003694:	bf00      	nop
 8003696:	bd80      	pop	{r7, pc}
 8003698:	40021000 	.word	0x40021000
 800369c:	f8ff0000 	.word	0xf8ff0000
 80036a0:	e000ed00 	.word	0xe000ed00

080036a4 <SetSysClock>:
  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 80036a4:	b580      	push	{r7, lr}
 80036a6:	af00      	add	r7, sp, #0
#elif defined SYSCLK_FREQ_48MHz
  SetSysClockTo48();
#elif defined SYSCLK_FREQ_56MHz
  SetSysClockTo56();  
#elif defined SYSCLK_FREQ_72MHz
  SetSysClockTo72();
 80036a8:	f000 f802 	bl	80036b0 <SetSysClockTo72>
#endif
 
 /* If none of the define above is enabled, the HSI is used as System clock
    source (default after reset) */ 
}
 80036ac:	bf00      	nop
 80036ae:	bd80      	pop	{r7, pc}

080036b0 <SetSysClockTo72>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
 80036b0:	b480      	push	{r7}
 80036b2:	b083      	sub	sp, #12
 80036b4:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80036b6:	2300      	movs	r3, #0
 80036b8:	607b      	str	r3, [r7, #4]
 80036ba:	2300      	movs	r3, #0
 80036bc:	603b      	str	r3, [r7, #0]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 80036be:	4a3a      	ldr	r2, [pc, #232]	; (80037a8 <SetSysClockTo72+0xf8>)
 80036c0:	4b39      	ldr	r3, [pc, #228]	; (80037a8 <SetSysClockTo72+0xf8>)
 80036c2:	681b      	ldr	r3, [r3, #0]
 80036c4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80036c8:	6013      	str	r3, [r2, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80036ca:	4b37      	ldr	r3, [pc, #220]	; (80037a8 <SetSysClockTo72+0xf8>)
 80036cc:	681b      	ldr	r3, [r3, #0]
 80036ce:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80036d2:	603b      	str	r3, [r7, #0]
    StartUpCounter++;  
 80036d4:	687b      	ldr	r3, [r7, #4]
 80036d6:	3301      	adds	r3, #1
 80036d8:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80036da:	683b      	ldr	r3, [r7, #0]
 80036dc:	2b00      	cmp	r3, #0
 80036de:	d103      	bne.n	80036e8 <SetSysClockTo72+0x38>
 80036e0:	687b      	ldr	r3, [r7, #4]
 80036e2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80036e6:	d1f0      	bne.n	80036ca <SetSysClockTo72+0x1a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80036e8:	4b2f      	ldr	r3, [pc, #188]	; (80037a8 <SetSysClockTo72+0xf8>)
 80036ea:	681b      	ldr	r3, [r3, #0]
 80036ec:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80036f0:	2b00      	cmp	r3, #0
 80036f2:	d002      	beq.n	80036fa <SetSysClockTo72+0x4a>
  {
    HSEStatus = (uint32_t)0x01;
 80036f4:	2301      	movs	r3, #1
 80036f6:	603b      	str	r3, [r7, #0]
 80036f8:	e001      	b.n	80036fe <SetSysClockTo72+0x4e>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80036fa:	2300      	movs	r3, #0
 80036fc:	603b      	str	r3, [r7, #0]
  }  

  if (HSEStatus == (uint32_t)0x01)
 80036fe:	683b      	ldr	r3, [r7, #0]
 8003700:	2b01      	cmp	r3, #1
 8003702:	d14b      	bne.n	800379c <SetSysClockTo72+0xec>
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 8003704:	4a29      	ldr	r2, [pc, #164]	; (80037ac <SetSysClockTo72+0xfc>)
 8003706:	4b29      	ldr	r3, [pc, #164]	; (80037ac <SetSysClockTo72+0xfc>)
 8003708:	681b      	ldr	r3, [r3, #0]
 800370a:	f043 0310 	orr.w	r3, r3, #16
 800370e:	6013      	str	r3, [r2, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 8003710:	4a26      	ldr	r2, [pc, #152]	; (80037ac <SetSysClockTo72+0xfc>)
 8003712:	4b26      	ldr	r3, [pc, #152]	; (80037ac <SetSysClockTo72+0xfc>)
 8003714:	681b      	ldr	r3, [r3, #0]
 8003716:	f023 0303 	bic.w	r3, r3, #3
 800371a:	6013      	str	r3, [r2, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 800371c:	4a23      	ldr	r2, [pc, #140]	; (80037ac <SetSysClockTo72+0xfc>)
 800371e:	4b23      	ldr	r3, [pc, #140]	; (80037ac <SetSysClockTo72+0xfc>)
 8003720:	681b      	ldr	r3, [r3, #0]
 8003722:	f043 0302 	orr.w	r3, r3, #2
 8003726:	6013      	str	r3, [r2, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8003728:	4a1f      	ldr	r2, [pc, #124]	; (80037a8 <SetSysClockTo72+0xf8>)
 800372a:	4b1f      	ldr	r3, [pc, #124]	; (80037a8 <SetSysClockTo72+0xf8>)
 800372c:	685b      	ldr	r3, [r3, #4]
 800372e:	6053      	str	r3, [r2, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8003730:	4a1d      	ldr	r2, [pc, #116]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003732:	4b1d      	ldr	r3, [pc, #116]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003734:	685b      	ldr	r3, [r3, #4]
 8003736:	6053      	str	r3, [r2, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 8003738:	4a1b      	ldr	r2, [pc, #108]	; (80037a8 <SetSysClockTo72+0xf8>)
 800373a:	4b1b      	ldr	r3, [pc, #108]	; (80037a8 <SetSysClockTo72+0xf8>)
 800373c:	685b      	ldr	r3, [r3, #4]
 800373e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8003742:	6053      	str	r3, [r2, #4]
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
                            RCC_CFGR_PLLMULL9); 
#else    
    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
 8003744:	4a18      	ldr	r2, [pc, #96]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003746:	4b18      	ldr	r3, [pc, #96]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003748:	685b      	ldr	r3, [r3, #4]
 800374a:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 800374e:	6053      	str	r3, [r2, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
 8003750:	4a15      	ldr	r2, [pc, #84]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003752:	4b15      	ldr	r3, [pc, #84]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003754:	685b      	ldr	r3, [r3, #4]
 8003756:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 800375a:	6053      	str	r3, [r2, #4]
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 800375c:	4a12      	ldr	r2, [pc, #72]	; (80037a8 <SetSysClockTo72+0xf8>)
 800375e:	4b12      	ldr	r3, [pc, #72]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003760:	681b      	ldr	r3, [r3, #0]
 8003762:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003766:	6013      	str	r3, [r2, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8003768:	bf00      	nop
 800376a:	4b0f      	ldr	r3, [pc, #60]	; (80037a8 <SetSysClockTo72+0xf8>)
 800376c:	681b      	ldr	r3, [r3, #0]
 800376e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003772:	2b00      	cmp	r3, #0
 8003774:	d0f9      	beq.n	800376a <SetSysClockTo72+0xba>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8003776:	4a0c      	ldr	r2, [pc, #48]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003778:	4b0b      	ldr	r3, [pc, #44]	; (80037a8 <SetSysClockTo72+0xf8>)
 800377a:	685b      	ldr	r3, [r3, #4]
 800377c:	f023 0303 	bic.w	r3, r3, #3
 8003780:	6053      	str	r3, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 8003782:	4a09      	ldr	r2, [pc, #36]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003784:	4b08      	ldr	r3, [pc, #32]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003786:	685b      	ldr	r3, [r3, #4]
 8003788:	f043 0302 	orr.w	r3, r3, #2
 800378c:	6053      	str	r3, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 800378e:	bf00      	nop
 8003790:	4b05      	ldr	r3, [pc, #20]	; (80037a8 <SetSysClockTo72+0xf8>)
 8003792:	685b      	ldr	r3, [r3, #4]
 8003794:	f003 030c 	and.w	r3, r3, #12
 8003798:	2b08      	cmp	r3, #8
 800379a:	d1f9      	bne.n	8003790 <SetSysClockTo72+0xe0>
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }
}
 800379c:	bf00      	nop
 800379e:	370c      	adds	r7, #12
 80037a0:	46bd      	mov	sp, r7
 80037a2:	bc80      	pop	{r7}
 80037a4:	4770      	bx	lr
 80037a6:	bf00      	nop
 80037a8:	40021000 	.word	0x40021000
 80037ac:	40022000 	.word	0x40022000

080037b0 <NVIC_EnableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80037b0:	b480      	push	{r7}
 80037b2:	b083      	sub	sp, #12
 80037b4:	af00      	add	r7, sp, #0
 80037b6:	4603      	mov	r3, r0
 80037b8:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 80037ba:	4908      	ldr	r1, [pc, #32]	; (80037dc <NVIC_EnableIRQ+0x2c>)
 80037bc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80037c0:	095b      	lsrs	r3, r3, #5
 80037c2:	79fa      	ldrb	r2, [r7, #7]
 80037c4:	f002 021f 	and.w	r2, r2, #31
 80037c8:	2001      	movs	r0, #1
 80037ca:	fa00 f202 	lsl.w	r2, r0, r2
 80037ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80037d2:	bf00      	nop
 80037d4:	370c      	adds	r7, #12
 80037d6:	46bd      	mov	sp, r7
 80037d8:	bc80      	pop	{r7}
 80037da:	4770      	bx	lr
 80037dc:	e000e100 	.word	0xe000e100

080037e0 <UART_Init>:
xSemaphoreHandle xTxSemaphore;
#endif
sRingBuf_t sTxRingBuf, sRxRingBuf;

void UART_Init(void)
{
 80037e0:	b580      	push	{r7, lr}
 80037e2:	b086      	sub	sp, #24
 80037e4:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef gpioStruct;
	USART_InitTypeDef usartStruct;

	USART_RCC_INIT;
 80037e6:	2101      	movs	r1, #1
 80037e8:	2004      	movs	r0, #4
 80037ea:	f7fe f9f5 	bl	8001bd8 <RCC_APB2PeriphClockCmd>
 80037ee:	2101      	movs	r1, #1
 80037f0:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80037f4:	f7fe f9f0 	bl	8001bd8 <RCC_APB2PeriphClockCmd>

	gpioStruct.GPIO_Pin = USART_Pin_Tx;
 80037f8:	f44f 7300 	mov.w	r3, #512	; 0x200
 80037fc:	82bb      	strh	r3, [r7, #20]
	gpioStruct.GPIO_Mode = GPIO_Mode_AF_PP;
 80037fe:	2318      	movs	r3, #24
 8003800:	75fb      	strb	r3, [r7, #23]
	gpioStruct.GPIO_Speed = GPIO_Speed_50MHz;
 8003802:	2303      	movs	r3, #3
 8003804:	75bb      	strb	r3, [r7, #22]
	GPIO_Init(USART_GPIO,&gpioStruct);
 8003806:	f107 0314 	add.w	r3, r7, #20
 800380a:	4619      	mov	r1, r3
 800380c:	4824      	ldr	r0, [pc, #144]	; (80038a0 <UART_Init+0xc0>)
 800380e:	f7fe f85f 	bl	80018d0 <GPIO_Init>

	//GPIO_RX
	gpioStruct.GPIO_Pin = USART_Pin_Rx;
 8003812:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003816:	82bb      	strh	r3, [r7, #20]
	gpioStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8003818:	2304      	movs	r3, #4
 800381a:	75fb      	strb	r3, [r7, #23]
	gpioStruct.GPIO_Speed = GPIO_Speed_50MHz;
 800381c:	2303      	movs	r3, #3
 800381e:	75bb      	strb	r3, [r7, #22]
	GPIO_Init(USART_GPIO,&gpioStruct);
 8003820:	f107 0314 	add.w	r3, r7, #20
 8003824:	4619      	mov	r1, r3
 8003826:	481e      	ldr	r0, [pc, #120]	; (80038a0 <UART_Init+0xc0>)
 8003828:	f7fe f852 	bl	80018d0 <GPIO_Init>

	//USART_Settings
	usartStruct.USART_BaudRate = UART_BOUD_RATE;
 800382c:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8003830:	607b      	str	r3, [r7, #4]
	usartStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8003832:	2300      	movs	r3, #0
 8003834:	823b      	strh	r3, [r7, #16]
	usartStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8003836:	230c      	movs	r3, #12
 8003838:	81fb      	strh	r3, [r7, #14]
	usartStruct.USART_Parity = USART_Parity_No;
 800383a:	2300      	movs	r3, #0
 800383c:	81bb      	strh	r3, [r7, #12]
	usartStruct.USART_StopBits = USART_StopBits_1;
 800383e:	2300      	movs	r3, #0
 8003840:	817b      	strh	r3, [r7, #10]
	usartStruct.USART_WordLength = USART_WordLength_8b;
 8003842:	2300      	movs	r3, #0
 8003844:	813b      	strh	r3, [r7, #8]
	USART_Init(USARTx, &usartStruct);
 8003846:	1d3b      	adds	r3, r7, #4
 8003848:	4619      	mov	r1, r3
 800384a:	4816      	ldr	r0, [pc, #88]	; (80038a4 <UART_Init+0xc4>)
 800384c:	f7fe f9e2 	bl	8001c14 <USART_Init>

	USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE);
 8003850:	2201      	movs	r2, #1
 8003852:	f240 5125 	movw	r1, #1317	; 0x525
 8003856:	4813      	ldr	r0, [pc, #76]	; (80038a4 <UART_Init+0xc4>)
 8003858:	f7fe fab6 	bl	8001dc8 <USART_ITConfig>
	USART_Cmd(USARTx, ENABLE);
 800385c:	2101      	movs	r1, #1
 800385e:	4811      	ldr	r0, [pc, #68]	; (80038a4 <UART_Init+0xc4>)
 8003860:	f7fe fa92 	bl	8001d88 <USART_Cmd>
	NVIC_EnableIRQ(USARTx_IRQn);
 8003864:	2025      	movs	r0, #37	; 0x25
 8003866:	f7ff ffa3 	bl	80037b0 <NVIC_EnableIRQ>

#ifdef USE_FREERTOS
	xRxSemaphore = xSemaphoreCreateCounting(10,0);
 800386a:	2100      	movs	r1, #0
 800386c:	200a      	movs	r0, #10
 800386e:	f7fd f815 	bl	800089c <xQueueCreateCountingSemaphore>
 8003872:	4602      	mov	r2, r0
 8003874:	4b0c      	ldr	r3, [pc, #48]	; (80038a8 <UART_Init+0xc8>)
 8003876:	601a      	str	r2, [r3, #0]
	xTxSemaphore = xSemaphoreCreateBinary();
 8003878:	2203      	movs	r2, #3
 800387a:	2100      	movs	r1, #0
 800387c:	2001      	movs	r0, #1
 800387e:	f7fc ffd5 	bl	800082c <xQueueGenericCreate>
 8003882:	4602      	mov	r2, r0
 8003884:	4b09      	ldr	r3, [pc, #36]	; (80038ac <UART_Init+0xcc>)
 8003886:	601a      	str	r2, [r3, #0]
	xSemaphoreGive(xTxSemaphore);
 8003888:	4b08      	ldr	r3, [pc, #32]	; (80038ac <UART_Init+0xcc>)
 800388a:	6818      	ldr	r0, [r3, #0]
 800388c:	2300      	movs	r3, #0
 800388e:	2200      	movs	r2, #0
 8003890:	2100      	movs	r1, #0
 8003892:	f7fd f819 	bl	80008c8 <xQueueGenericSend>
#endif
}
 8003896:	bf00      	nop
 8003898:	3718      	adds	r7, #24
 800389a:	46bd      	mov	sp, r7
 800389c:	bd80      	pop	{r7, pc}
 800389e:	bf00      	nop
 80038a0:	40010800 	.word	0x40010800
 80038a4:	40013800 	.word	0x40013800
 80038a8:	20001b5c 	.word	0x20001b5c
 80038ac:	20001b58 	.word	0x20001b58

080038b0 <UART_SendString>:
	prv_SendChar(data);
	xSemaphoreGive(xTxSemaphore);
}

void UART_SendString(const char *str)
{
 80038b0:	b580      	push	{r7, lr}
 80038b2:	b084      	sub	sp, #16
 80038b4:	af00      	add	r7, sp, #0
 80038b6:	6078      	str	r0, [r7, #4]
	xSemaphoreTake(xTxSemaphore, portMAX_DELAY);
 80038b8:	4b12      	ldr	r3, [pc, #72]	; (8003904 <UART_SendString+0x54>)
 80038ba:	6818      	ldr	r0, [r3, #0]
 80038bc:	2300      	movs	r3, #0
 80038be:	f04f 32ff 	mov.w	r2, #4294967295
 80038c2:	2100      	movs	r1, #0
 80038c4:	f7fd f8cc 	bl	8000a60 <xQueueGenericReceive>
	int i = 0;
 80038c8:	2300      	movs	r3, #0
 80038ca:	60fb      	str	r3, [r7, #12]
	while (str[i] != 0)
 80038cc:	e009      	b.n	80038e2 <UART_SendString+0x32>
	{
		prv_SendChar(str[i]);
 80038ce:	68fb      	ldr	r3, [r7, #12]
 80038d0:	687a      	ldr	r2, [r7, #4]
 80038d2:	4413      	add	r3, r2
 80038d4:	781b      	ldrb	r3, [r3, #0]
 80038d6:	4618      	mov	r0, r3
 80038d8:	f000 f852 	bl	8003980 <prv_SendChar>
		i++;
 80038dc:	68fb      	ldr	r3, [r7, #12]
 80038de:	3301      	adds	r3, #1
 80038e0:	60fb      	str	r3, [r7, #12]

void UART_SendString(const char *str)
{
	xSemaphoreTake(xTxSemaphore, portMAX_DELAY);
	int i = 0;
	while (str[i] != 0)
 80038e2:	68fb      	ldr	r3, [r7, #12]
 80038e4:	687a      	ldr	r2, [r7, #4]
 80038e6:	4413      	add	r3, r2
 80038e8:	781b      	ldrb	r3, [r3, #0]
 80038ea:	2b00      	cmp	r3, #0
 80038ec:	d1ef      	bne.n	80038ce <UART_SendString+0x1e>
	{
		prv_SendChar(str[i]);
		i++;
	}
	xSemaphoreGive(xTxSemaphore);
 80038ee:	4b05      	ldr	r3, [pc, #20]	; (8003904 <UART_SendString+0x54>)
 80038f0:	6818      	ldr	r0, [r3, #0]
 80038f2:	2300      	movs	r3, #0
 80038f4:	2200      	movs	r2, #0
 80038f6:	2100      	movs	r1, #0
 80038f8:	f7fc ffe6 	bl	80008c8 <xQueueGenericSend>
}
 80038fc:	bf00      	nop
 80038fe:	3710      	adds	r7, #16
 8003900:	46bd      	mov	sp, r7
 8003902:	bd80      	pop	{r7, pc}
 8003904:	20001b58 	.word	0x20001b58

08003908 <UART_GetChar>:

int UART_GetChar()
{
 8003908:	b480      	push	{r7}
 800390a:	b083      	sub	sp, #12
 800390c:	af00      	add	r7, sp, #0
	uint8_t data;
	if (sRxRingBuf.wrIdx != sRxRingBuf.rdIdx)	{
 800390e:	4b12      	ldr	r3, [pc, #72]	; (8003958 <UART_GetChar+0x50>)
 8003910:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8003914:	4b10      	ldr	r3, [pc, #64]	; (8003958 <UART_GetChar+0x50>)
 8003916:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800391a:	429a      	cmp	r2, r3
 800391c:	d014      	beq.n	8003948 <UART_GetChar+0x40>
		data = sRxRingBuf.data[sRxRingBuf.rdIdx++];
 800391e:	4b0e      	ldr	r3, [pc, #56]	; (8003958 <UART_GetChar+0x50>)
 8003920:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003924:	1c5a      	adds	r2, r3, #1
 8003926:	490c      	ldr	r1, [pc, #48]	; (8003958 <UART_GetChar+0x50>)
 8003928:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
 800392c:	4a0a      	ldr	r2, [pc, #40]	; (8003958 <UART_GetChar+0x50>)
 800392e:	5cd3      	ldrb	r3, [r2, r3]
 8003930:	71fb      	strb	r3, [r7, #7]
		if (sRxRingBuf.rdIdx >= uartSIZE_OF_RING_BUFFER)	{
 8003932:	4b09      	ldr	r3, [pc, #36]	; (8003958 <UART_GetChar+0x50>)
 8003934:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003938:	2b7f      	cmp	r3, #127	; 0x7f
 800393a:	dd03      	ble.n	8003944 <UART_GetChar+0x3c>
			sRxRingBuf.rdIdx = 0;
 800393c:	4b06      	ldr	r3, [pc, #24]	; (8003958 <UART_GetChar+0x50>)
 800393e:	2200      	movs	r2, #0
 8003940:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		}
		return (int)data;
 8003944:	79fb      	ldrb	r3, [r7, #7]
 8003946:	e001      	b.n	800394c <UART_GetChar+0x44>
	}
	else	{
		return (UART_NO_DATA);
 8003948:	f04f 33ff 	mov.w	r3, #4294967295
	}
}
 800394c:	4618      	mov	r0, r3
 800394e:	370c      	adds	r7, #12
 8003950:	46bd      	mov	sp, r7
 8003952:	bc80      	pop	{r7}
 8003954:	4770      	bx	lr
 8003956:	bf00      	nop
 8003958:	20001b60 	.word	0x20001b60

0800395c <UART_GetCharBlocking>:

#ifdef USE_FREERTOS
int UART_GetCharBlocking()
{
 800395c:	b580      	push	{r7, lr}
 800395e:	af00      	add	r7, sp, #0
	xSemaphoreTake(xRxSemaphore, portMAX_DELAY);
 8003960:	4b06      	ldr	r3, [pc, #24]	; (800397c <UART_GetCharBlocking+0x20>)
 8003962:	6818      	ldr	r0, [r3, #0]
 8003964:	2300      	movs	r3, #0
 8003966:	f04f 32ff 	mov.w	r2, #4294967295
 800396a:	2100      	movs	r1, #0
 800396c:	f7fd f878 	bl	8000a60 <xQueueGenericReceive>
	return UART_GetChar();
 8003970:	f7ff ffca 	bl	8003908 <UART_GetChar>
 8003974:	4603      	mov	r3, r0
}
 8003976:	4618      	mov	r0, r3
 8003978:	bd80      	pop	{r7, pc}
 800397a:	bf00      	nop
 800397c:	20001b5c 	.word	0x20001b5c

08003980 <prv_SendChar>:
#endif

void prv_SendChar(uint8_t data)
{
 8003980:	b580      	push	{r7, lr}
 8003982:	b082      	sub	sp, #8
 8003984:	af00      	add	r7, sp, #0
 8003986:	4603      	mov	r3, r0
 8003988:	71fb      	strb	r3, [r7, #7]
	sTxRingBuf.data[sTxRingBuf.wrIdx++] = data;
 800398a:	4b0e      	ldr	r3, [pc, #56]	; (80039c4 <prv_SendChar+0x44>)
 800398c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003990:	1c5a      	adds	r2, r3, #1
 8003992:	490c      	ldr	r1, [pc, #48]	; (80039c4 <prv_SendChar+0x44>)
 8003994:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
 8003998:	490a      	ldr	r1, [pc, #40]	; (80039c4 <prv_SendChar+0x44>)
 800399a:	79fa      	ldrb	r2, [r7, #7]
 800399c:	54ca      	strb	r2, [r1, r3]
	if (sTxRingBuf.wrIdx >= uartSIZE_OF_RING_BUFFER)	{
 800399e:	4b09      	ldr	r3, [pc, #36]	; (80039c4 <prv_SendChar+0x44>)
 80039a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80039a4:	2b7f      	cmp	r3, #127	; 0x7f
 80039a6:	dd03      	ble.n	80039b0 <prv_SendChar+0x30>
		sTxRingBuf.wrIdx = 0;
 80039a8:	4b06      	ldr	r3, [pc, #24]	; (80039c4 <prv_SendChar+0x44>)
 80039aa:	2200      	movs	r2, #0
 80039ac:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	}
	USART_ITConfig(USARTx, USART_IT_TXE, ENABLE);
 80039b0:	2201      	movs	r2, #1
 80039b2:	f240 7127 	movw	r1, #1831	; 0x727
 80039b6:	4804      	ldr	r0, [pc, #16]	; (80039c8 <prv_SendChar+0x48>)
 80039b8:	f7fe fa06 	bl	8001dc8 <USART_ITConfig>
}
 80039bc:	bf00      	nop
 80039be:	3708      	adds	r7, #8
 80039c0:	46bd      	mov	sp, r7
 80039c2:	bd80      	pop	{r7, pc}
 80039c4:	20001ad0 	.word	0x20001ad0
 80039c8:	40013800 	.word	0x40013800

080039cc <USART1_IRQHandler>:

void USARTx_IRQHandler (void)
{
 80039cc:	b590      	push	{r4, r7, lr}
 80039ce:	b083      	sub	sp, #12
 80039d0:	af00      	add	r7, sp, #0
	if (USART_GetITStatus(USARTx,USART_IT_RXNE) != RESET)	{
 80039d2:	f240 5125 	movw	r1, #1317	; 0x525
 80039d6:	4835      	ldr	r0, [pc, #212]	; (8003aac <USART1_IRQHandler+0xe0>)
 80039d8:	f7fe fa60 	bl	8001e9c <USART_GetITStatus>
 80039dc:	4603      	mov	r3, r0
 80039de:	2b00      	cmp	r3, #0
 80039e0:	d02a      	beq.n	8003a38 <USART1_IRQHandler+0x6c>
		USART_ClearITPendingBit(USARTx, USART_IT_RXNE);
 80039e2:	f240 5125 	movw	r1, #1317	; 0x525
 80039e6:	4831      	ldr	r0, [pc, #196]	; (8003aac <USART1_IRQHandler+0xe0>)
 80039e8:	f7fe fab2 	bl	8001f50 <USART_ClearITPendingBit>
		sRxRingBuf.data[sRxRingBuf.wrIdx++] = USART_ReceiveData(USARTx);
 80039ec:	4b30      	ldr	r3, [pc, #192]	; (8003ab0 <USART1_IRQHandler+0xe4>)
 80039ee:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
 80039f2:	1c63      	adds	r3, r4, #1
 80039f4:	4a2e      	ldr	r2, [pc, #184]	; (8003ab0 <USART1_IRQHandler+0xe4>)
 80039f6:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 80039fa:	482c      	ldr	r0, [pc, #176]	; (8003aac <USART1_IRQHandler+0xe0>)
 80039fc:	f7fe fa3e 	bl	8001e7c <USART_ReceiveData>
 8003a00:	4603      	mov	r3, r0
 8003a02:	b2da      	uxtb	r2, r3
 8003a04:	4b2a      	ldr	r3, [pc, #168]	; (8003ab0 <USART1_IRQHandler+0xe4>)
 8003a06:	551a      	strb	r2, [r3, r4]
		if (sRxRingBuf.wrIdx >= uartSIZE_OF_RING_BUFFER)	{
 8003a08:	4b29      	ldr	r3, [pc, #164]	; (8003ab0 <USART1_IRQHandler+0xe4>)
 8003a0a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003a0e:	2b7f      	cmp	r3, #127	; 0x7f
 8003a10:	dd03      	ble.n	8003a1a <USART1_IRQHandler+0x4e>
			sRxRingBuf.wrIdx = 0;
 8003a12:	4b27      	ldr	r3, [pc, #156]	; (8003ab0 <USART1_IRQHandler+0xe4>)
 8003a14:	2200      	movs	r2, #0
 8003a16:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		}
#ifdef USE_FREERTOS
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 8003a1a:	2300      	movs	r3, #0
 8003a1c:	607b      	str	r3, [r7, #4]
		xSemaphoreGiveFromISR(xRxSemaphore, &xHigherPriorityTaskWoken);
 8003a1e:	4b25      	ldr	r3, [pc, #148]	; (8003ab4 <USART1_IRQHandler+0xe8>)
 8003a20:	6818      	ldr	r0, [r3, #0]
 8003a22:	1d3a      	adds	r2, r7, #4
 8003a24:	2300      	movs	r3, #0
 8003a26:	2100      	movs	r1, #0
 8003a28:	f7fc ffd6 	bl	80009d8 <xQueueGenericSendFromISR>
		if( xHigherPriorityTaskWoken != pdFALSE )	{
 8003a2c:	687b      	ldr	r3, [r7, #4]
 8003a2e:	2b00      	cmp	r3, #0
 8003a30:	d037      	beq.n	8003aa2 <USART1_IRQHandler+0xd6>
			portYIELD();
 8003a32:	f7fc fc7b 	bl	800032c <vPortYield>
			if (sTxRingBuf.wrIdx == sTxRingBuf.rdIdx)	{
				USART_ITConfig(USARTx, USART_IT_TXE, DISABLE);
			}
		}
	}
}
 8003a36:	e034      	b.n	8003aa2 <USART1_IRQHandler+0xd6>
		if( xHigherPriorityTaskWoken != pdFALSE )	{
			portYIELD();
		}
#endif
	}
	else if (USART_GetITStatus(USARTx,USART_IT_TXE) != RESET)	{
 8003a38:	f240 7127 	movw	r1, #1831	; 0x727
 8003a3c:	481b      	ldr	r0, [pc, #108]	; (8003aac <USART1_IRQHandler+0xe0>)
 8003a3e:	f7fe fa2d 	bl	8001e9c <USART_GetITStatus>
 8003a42:	4603      	mov	r3, r0
 8003a44:	2b00      	cmp	r3, #0
 8003a46:	d02c      	beq.n	8003aa2 <USART1_IRQHandler+0xd6>
		if (sTxRingBuf.wrIdx != sTxRingBuf.rdIdx)	{
 8003a48:	4b1b      	ldr	r3, [pc, #108]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a4a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8003a4e:	4b1a      	ldr	r3, [pc, #104]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a50:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003a54:	429a      	cmp	r2, r3
 8003a56:	d024      	beq.n	8003aa2 <USART1_IRQHandler+0xd6>
			USART_SendData(USARTx, sTxRingBuf.data[sTxRingBuf.rdIdx++]);
 8003a58:	4b17      	ldr	r3, [pc, #92]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a5a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003a5e:	1c5a      	adds	r2, r3, #1
 8003a60:	4915      	ldr	r1, [pc, #84]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a62:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
 8003a66:	4a14      	ldr	r2, [pc, #80]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a68:	5cd3      	ldrb	r3, [r2, r3]
 8003a6a:	b29b      	uxth	r3, r3
 8003a6c:	4619      	mov	r1, r3
 8003a6e:	480f      	ldr	r0, [pc, #60]	; (8003aac <USART1_IRQHandler+0xe0>)
 8003a70:	f7fe f9f2 	bl	8001e58 <USART_SendData>
			if (sTxRingBuf.rdIdx >= uartSIZE_OF_RING_BUFFER)	{
 8003a74:	4b10      	ldr	r3, [pc, #64]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a76:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003a7a:	2b7f      	cmp	r3, #127	; 0x7f
 8003a7c:	dd03      	ble.n	8003a86 <USART1_IRQHandler+0xba>
				sTxRingBuf.rdIdx = 0;
 8003a7e:	4b0e      	ldr	r3, [pc, #56]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a80:	2200      	movs	r2, #0
 8003a82:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
			}
			if (sTxRingBuf.wrIdx == sTxRingBuf.rdIdx)	{
 8003a86:	4b0c      	ldr	r3, [pc, #48]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a88:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8003a8c:	4b0a      	ldr	r3, [pc, #40]	; (8003ab8 <USART1_IRQHandler+0xec>)
 8003a8e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003a92:	429a      	cmp	r2, r3
 8003a94:	d105      	bne.n	8003aa2 <USART1_IRQHandler+0xd6>
				USART_ITConfig(USARTx, USART_IT_TXE, DISABLE);
 8003a96:	2200      	movs	r2, #0
 8003a98:	f240 7127 	movw	r1, #1831	; 0x727
 8003a9c:	4803      	ldr	r0, [pc, #12]	; (8003aac <USART1_IRQHandler+0xe0>)
 8003a9e:	f7fe f993 	bl	8001dc8 <USART_ITConfig>
			}
		}
	}
}
 8003aa2:	bf00      	nop
 8003aa4:	370c      	adds	r7, #12
 8003aa6:	46bd      	mov	sp, r7
 8003aa8:	bd90      	pop	{r4, r7, pc}
 8003aaa:	bf00      	nop
 8003aac:	40013800 	.word	0x40013800
 8003ab0:	20001b60 	.word	0x20001b60
 8003ab4:	20001b5c 	.word	0x20001b5c
 8003ab8:	20001ad0 	.word	0x20001ad0

08003abc <__libc_init_array>:
 8003abc:	4b0e      	ldr	r3, [pc, #56]	; (8003af8 <__libc_init_array+0x3c>)
 8003abe:	b570      	push	{r4, r5, r6, lr}
 8003ac0:	461e      	mov	r6, r3
 8003ac2:	4c0e      	ldr	r4, [pc, #56]	; (8003afc <__libc_init_array+0x40>)
 8003ac4:	2500      	movs	r5, #0
 8003ac6:	1ae4      	subs	r4, r4, r3
 8003ac8:	10a4      	asrs	r4, r4, #2
 8003aca:	42a5      	cmp	r5, r4
 8003acc:	d004      	beq.n	8003ad8 <__libc_init_array+0x1c>
 8003ace:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8003ad2:	4798      	blx	r3
 8003ad4:	3501      	adds	r5, #1
 8003ad6:	e7f8      	b.n	8003aca <__libc_init_array+0xe>
 8003ad8:	f000 f85e 	bl	8003b98 <_init>
 8003adc:	4b08      	ldr	r3, [pc, #32]	; (8003b00 <__libc_init_array+0x44>)
 8003ade:	4c09      	ldr	r4, [pc, #36]	; (8003b04 <__libc_init_array+0x48>)
 8003ae0:	461e      	mov	r6, r3
 8003ae2:	1ae4      	subs	r4, r4, r3
 8003ae4:	10a4      	asrs	r4, r4, #2
 8003ae6:	2500      	movs	r5, #0
 8003ae8:	42a5      	cmp	r5, r4
 8003aea:	d004      	beq.n	8003af6 <__libc_init_array+0x3a>
 8003aec:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8003af0:	4798      	blx	r3
 8003af2:	3501      	adds	r5, #1
 8003af4:	e7f8      	b.n	8003ae8 <__libc_init_array+0x2c>
 8003af6:	bd70      	pop	{r4, r5, r6, pc}
 8003af8:	08003df0 	.word	0x08003df0
 8003afc:	08003df0 	.word	0x08003df0
 8003b00:	08003df0 	.word	0x08003df0
 8003b04:	08003df4 	.word	0x08003df4

08003b08 <memcpy>:
 8003b08:	b510      	push	{r4, lr}
 8003b0a:	1e43      	subs	r3, r0, #1
 8003b0c:	440a      	add	r2, r1
 8003b0e:	4291      	cmp	r1, r2
 8003b10:	d004      	beq.n	8003b1c <memcpy+0x14>
 8003b12:	f811 4b01 	ldrb.w	r4, [r1], #1
 8003b16:	f803 4f01 	strb.w	r4, [r3, #1]!
 8003b1a:	e7f8      	b.n	8003b0e <memcpy+0x6>
 8003b1c:	bd10      	pop	{r4, pc}

08003b1e <memmove>:
 8003b1e:	4288      	cmp	r0, r1
 8003b20:	b510      	push	{r4, lr}
 8003b22:	eb01 0302 	add.w	r3, r1, r2
 8003b26:	d801      	bhi.n	8003b2c <memmove+0xe>
 8003b28:	1e42      	subs	r2, r0, #1
 8003b2a:	e00b      	b.n	8003b44 <memmove+0x26>
 8003b2c:	4298      	cmp	r0, r3
 8003b2e:	d2fb      	bcs.n	8003b28 <memmove+0xa>
 8003b30:	1881      	adds	r1, r0, r2
 8003b32:	1ad2      	subs	r2, r2, r3
 8003b34:	42d3      	cmn	r3, r2
 8003b36:	d004      	beq.n	8003b42 <memmove+0x24>
 8003b38:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8003b3c:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8003b40:	e7f8      	b.n	8003b34 <memmove+0x16>
 8003b42:	bd10      	pop	{r4, pc}
 8003b44:	4299      	cmp	r1, r3
 8003b46:	d004      	beq.n	8003b52 <memmove+0x34>
 8003b48:	f811 4b01 	ldrb.w	r4, [r1], #1
 8003b4c:	f802 4f01 	strb.w	r4, [r2, #1]!
 8003b50:	e7f8      	b.n	8003b44 <memmove+0x26>
 8003b52:	bd10      	pop	{r4, pc}

08003b54 <memset>:
 8003b54:	4603      	mov	r3, r0
 8003b56:	4402      	add	r2, r0
 8003b58:	4293      	cmp	r3, r2
 8003b5a:	d002      	beq.n	8003b62 <memset+0xe>
 8003b5c:	f803 1b01 	strb.w	r1, [r3], #1
 8003b60:	e7fa      	b.n	8003b58 <memset+0x4>
 8003b62:	4770      	bx	lr

08003b64 <strstr>:
 8003b64:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b66:	7803      	ldrb	r3, [r0, #0]
 8003b68:	b963      	cbnz	r3, 8003b84 <strstr+0x20>
 8003b6a:	780b      	ldrb	r3, [r1, #0]
 8003b6c:	2b00      	cmp	r3, #0
 8003b6e:	bf18      	it	ne
 8003b70:	2000      	movne	r0, #0
 8003b72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b74:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 8003b78:	b162      	cbz	r2, 8003b94 <strstr+0x30>
 8003b7a:	f814 7f01 	ldrb.w	r7, [r4, #1]!
 8003b7e:	4630      	mov	r0, r6
 8003b80:	4297      	cmp	r7, r2
 8003b82:	d0f7      	beq.n	8003b74 <strstr+0x10>
 8003b84:	4603      	mov	r3, r0
 8003b86:	1c46      	adds	r6, r0, #1
 8003b88:	7800      	ldrb	r0, [r0, #0]
 8003b8a:	b110      	cbz	r0, 8003b92 <strstr+0x2e>
 8003b8c:	1e4d      	subs	r5, r1, #1
 8003b8e:	1e5c      	subs	r4, r3, #1
 8003b90:	e7f0      	b.n	8003b74 <strstr+0x10>
 8003b92:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b94:	4618      	mov	r0, r3
 8003b96:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003b98 <_init>:
 8003b98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003b9a:	bf00      	nop
 8003b9c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003b9e:	bc08      	pop	{r3}
 8003ba0:	469e      	mov	lr, r3
 8003ba2:	4770      	bx	lr

08003ba4 <_fini>:
 8003ba4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003ba6:	bf00      	nop
 8003ba8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003baa:	bc08      	pop	{r3}
 8003bac:	469e      	mov	lr, r3
 8003bae:	4770      	bx	lr
